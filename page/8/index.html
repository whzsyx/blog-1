<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon.ico">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/themes/blue/pace-theme-minimal.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/pace.min.js"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/blog/',
    scheme: 'Pisces',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":true},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":true,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="Dunwu&#39;s Blog">
<meta property="og:type" content="website">
<meta property="og:title" content="Dunwu">
<meta property="og:url" content="https://dunwu.github.io/blog/page/8/index.html">
<meta property="og:site_name" content="Dunwu">
<meta property="og:description" content="Dunwu&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Zhang Peng">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://dunwu.github.io/blog/page/8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Dunwu</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/blog/atom.xml" title="Dunwu" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/blog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Dunwu</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <h1 class="site-subtitle" itemprop="description">大道至简，知易行难</h1>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/blog/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">102</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">37</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">173</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/dunwu" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/2020/06/24/redis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BA%94%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2020/06/24/redis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BA%94%E7%94%A8/" class="post-title-link" itemprop="url">Redis 数据类型和应用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-24 10:45:38" itemprop="dateCreated datePublished" datetime="2020-06-24T10:45:38+08:00">2020-06-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-14 16:45:53" itemprop="dateModified" datetime="2022-04-14T16:45:53+08:00">2022-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">KV数据库</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2020/06/24/redis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BA%94%E7%94%A8/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/06/24/redis-数据类型和应用/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>21k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>19 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="redis-数据类型和应用"><a class="markdownIt-Anchor" href="#redis-数据类型和应用"></a> Redis 数据类型和应用</h1>
<blockquote>
<p>Redis 提供了多种数据类型，每种数据类型有丰富的命令支持。</p>
<p>使用 Redis ，不仅要了解其数据类型的特性，还需要根据业务场景，灵活的、高效的使用其数据类型来建模。</p>
</blockquote>
<h2 id="一-redis-基本数据类型"><a class="markdownIt-Anchor" href="#一-redis-基本数据类型"></a> 一、Redis 基本数据类型</h2>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200226113813.png" alt="Redis 数据类型" /></p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>可以存储的值</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>STRING</td>
<td>字符串、整数或者浮点数</td>
<td>对整个字符串或者字符串的其中一部分执行操作</br> 对整数和浮点数执行自增或者自减操作</td>
</tr>
<tr>
<td>LIST</td>
<td>列表</td>
<td>从两端压入或者弹出元素</br> 读取单个或者多个元素</br> 进行修剪，只保留一个范围内的元素</td>
</tr>
<tr>
<td>SET</td>
<td>无序集合</td>
<td>添加、获取、移除单个元素</br> 检查一个元素是否存在于集合中</br> 计算交集、并集、差集</br> 从集合里面随机获取元素</td>
</tr>
<tr>
<td>HASH</td>
<td>包含键值对的无序散列表</td>
<td>添加、获取、移除单个键值对</br> 获取所有键值对</br> 检查某个键是否存在</td>
</tr>
<tr>
<td>ZSET</td>
<td>有序集合</td>
<td>添加、获取、删除元素</br> 根据分值范围或者成员来获取元素</br> 计算一个键的排名</td>
</tr>
</tbody>
</table>
<blockquote>
<p><a href="https://redislabs.com/ebook/part-1-getting-started/chapter-1-getting-to-know-redis/1-2-what-redis-data-structures-look-like/" target="_blank" rel="noopener">What Redis data structures look like</a></p>
</blockquote>
<h3 id="string"><a class="markdownIt-Anchor" href="#string"></a> STRING</h3>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/database/redis/redis-datatype-string.png" width="400"/>
</div>
**适用场景：缓存、计数器、共享 Session**
<p>命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>行为</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>GET</code></td>
<td>获取存储在给定键中的值。</td>
</tr>
<tr>
<td><code>SET</code></td>
<td>设置存储在给定键中的值。</td>
</tr>
<tr>
<td><code>DEL</code></td>
<td>删除存储在给定键中的值（这个命令可以用于所有类型）。</td>
</tr>
<tr>
<td><code>INCR</code></td>
<td>为键 <code>key</code> 储存的数字值加一</td>
</tr>
<tr>
<td><code>DECR</code></td>
<td>为键 <code>key</code> 储存的数字值减一</td>
</tr>
</tbody>
</table>
<blockquote>
<p>更多命令请参考：<a href="https://redis.io/commands#string" target="_blank" rel="noopener">Redis String 类型命令</a></p>
</blockquote>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set hello world</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get hello</span><br><span class="line">"world"</span><br><span class="line">127.0.0.1:6379&gt; del hello</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; get hello</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>
<h3 id="hash"><a class="markdownIt-Anchor" href="#hash"></a> HASH</h3>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/database/redis/redis-datatype-hash.png" width="400"/>
</div>
**适用场景：存储结构化数据**，如一个对象：用户信息、产品信息等。
<p>命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>行为</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>HSET</code></td>
<td>在散列里面关联起给定的键值对。</td>
</tr>
<tr>
<td><code>HGET</code></td>
<td>获取指定散列键的值。</td>
</tr>
<tr>
<td><code>HGETALL</code></td>
<td>获取散列包含的所有键值对。</td>
</tr>
<tr>
<td><code>HDEL</code></td>
<td>如果给定键存在于散列里面，那么移除这个键。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>更多命令请参考：<a href="https://redis.io/commands#hash" target="_blank" rel="noopener">Redis Hash 类型命令</a></p>
</blockquote>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset hash-key sub-key1 value1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hset hash-key sub-key2 value2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hset hash-key sub-key1 value1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; hset hash-key sub-key3 value2</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; hgetall hash-key</span><br><span class="line">1) "sub-key1"</span><br><span class="line">2) "value1"</span><br><span class="line">3) "sub-key2"</span><br><span class="line">4) "value2"</span><br><span class="line">127.0.0.1:6379&gt; hdel hash-key sub-key2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hdel hash-key sub-key2</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; hget hash-key sub-key1</span><br><span class="line">"value1"</span><br><span class="line">127.0.0.1:6379&gt; hgetall hash-key</span><br><span class="line">1) "sub-key1"</span><br><span class="line">2) "value1"</span><br></pre></td></tr></table></figure>
<h3 id="list"><a class="markdownIt-Anchor" href="#list"></a> LIST</h3>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/database/redis/redis-datatype-list.png" width="400"/>
</div>
**适用场景：用于存储列表型数据**。如：粉丝列表、商品列表等。
<p>命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>行为</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>LPUSH</code></td>
<td>将给定值推入列表的右端。</td>
</tr>
<tr>
<td><code>RPUSH</code></td>
<td>将给定值推入列表的右端。</td>
</tr>
<tr>
<td><code>LPOP</code></td>
<td>从列表的左端弹出一个值，并返回被弹出的值。</td>
</tr>
<tr>
<td><code>RPOP</code></td>
<td>从列表的右端弹出一个值，并返回被弹出的值。</td>
</tr>
<tr>
<td><code>LRANGE</code></td>
<td>获取列表在给定范围上的所有值。</td>
</tr>
<tr>
<td><code>LINDEX</code></td>
<td>获取列表在给定位置上的单个元素。</td>
</tr>
<tr>
<td><code>LREM</code></td>
<td>从列表的左端弹出一个值，并返回被弹出的值。</td>
</tr>
<tr>
<td><code>LTRIM</code></td>
<td>只保留指定区间内的元素，删除其他元素。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>更多命令请参考：<a href="https://redis.io/commands#list" target="_blank" rel="noopener">Redis List 类型命令</a></p>
</blockquote>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush list-key item</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; rpush list-key item2</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; rpush list-key item</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; lrange list-key 0 -1</span><br><span class="line">1) "item"</span><br><span class="line">2) "item2"</span><br><span class="line">3) "item"</span><br><span class="line">127.0.0.1:6379&gt; lindex list-key 1</span><br><span class="line">"item2"</span><br><span class="line">127.0.0.1:6379&gt; lpop list-key</span><br><span class="line">"item"</span><br><span class="line">127.0.0.1:6379&gt; lrange list-key 0 -1</span><br><span class="line">1) "item2"</span><br><span class="line">2) "item"</span><br></pre></td></tr></table></figure>
<h3 id="set"><a class="markdownIt-Anchor" href="#set"></a> SET</h3>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/database/redis/redis-datatype-set.png" width="400"/>
</div>
**适用场景：用于存储去重的列表型数据**。
<p>命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>行为</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>SADD</code></td>
<td>将给定元素添加到集合。</td>
</tr>
<tr>
<td><code>SMEMBERS</code></td>
<td>返回集合包含的所有元素。</td>
</tr>
<tr>
<td><code>SISMEMBER</code></td>
<td>检查给定元素是否存在于集合中。</td>
</tr>
<tr>
<td><code>SREM</code></td>
<td>如果给定的元素存在于集合中，那么移除这个元素。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>更多命令请参考：<a href="https://redis.io/commands#set" target="_blank" rel="noopener">Redis Set 类型命令</a></p>
</blockquote>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd set-key item</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd set-key item2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd set-key item3</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd set-key item</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; smembers set-key</span><br><span class="line">1) "item"</span><br><span class="line">2) "item2"</span><br><span class="line">3) "item3"</span><br><span class="line">127.0.0.1:6379&gt; sismember set-key item4</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; sismember set-key item</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; srem set-key item2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; srem set-key item2</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; smembers set-key</span><br><span class="line">1) "item"</span><br><span class="line">2) "item3"</span><br></pre></td></tr></table></figure>
<h3 id="zset"><a class="markdownIt-Anchor" href="#zset"></a> ZSET</h3>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/database/redis/redis-datatype-zset.png" width="400"/>
</div>
<p>适用场景：由于可以设置 score，且不重复。<strong>适合用于存储各种排行数据</strong>，如：按评分排序的有序商品集合、按时间排序的有序文章集合。</p>
<p>命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>行为</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ZADD</code></td>
<td>将一个带有给定分值的成员添加到有序集合里面。</td>
</tr>
<tr>
<td><code>ZRANGE</code></td>
<td>根据元素在有序排列中所处的位置，从有序集合里面获取多个元素。</td>
</tr>
<tr>
<td><code>ZRANGEBYSCORE</code></td>
<td>获取有序集合在给定分值范围内的所有元素。</td>
</tr>
<tr>
<td><code>ZREM</code></td>
<td>如果给定成员存在于有序集合，那么移除这个成员。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>更多命令请参考：<a href="https://redis.io/commands#sorted_set" target="_blank" rel="noopener">Redis ZSet 类型命令</a></p>
</blockquote>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd zset-key 728 member1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd zset-key 982 member0</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd zset-key 982 member0</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; zrange zset-key 0 -1 withscores</span><br><span class="line">1) "member1"</span><br><span class="line">2) "728"</span><br><span class="line">3) "member0"</span><br><span class="line">4) "982"</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore zset-key 0 800 withscores</span><br><span class="line">1) "member1"</span><br><span class="line">2) "728"</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; zrem zset-key member1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zrem zset-key member1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; zrange zset-key 0 -1 withscores</span><br><span class="line">1) "member0"</span><br><span class="line">2) "982"</span><br></pre></td></tr></table></figure>
<h3 id="通用命令"><a class="markdownIt-Anchor" href="#通用命令"></a> 通用命令</h3>
<h4 id="排序"><a class="markdownIt-Anchor" href="#排序"></a> 排序</h4>
<p>Redis 的 <code>SORT</code> 命令可以对 <code>LIST</code>、<code>SET</code>、<code>ZSET</code> 进行排序。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>SORT</code></td>
<td><code>SORT source-key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern ...]] [ASC | DESC] [ALPHA] [STORE dest-key]</code>—根据给定选项，对输入 <code>LIST</code>、<code>SET</code>、<code>ZSET</code> 进行排序，然后返回或存储排序的结果。</td>
</tr>
</tbody>
</table>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379[15]&gt; RPUSH 'sort-input' 23 15 110 7</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379[15]&gt; SORT 'sort-input'</span><br><span class="line">1) "7"</span><br><span class="line">2) "15"</span><br><span class="line">3) "23"</span><br><span class="line">4) "110"</span><br><span class="line">127.0.0.1:6379[15]&gt; SORT 'sort-input' alpha</span><br><span class="line">1) "110"</span><br><span class="line">2) "15"</span><br><span class="line">3) "23"</span><br><span class="line">4) "7"</span><br><span class="line">127.0.0.1:6379[15]&gt; HSET 'd-7' 'field' 5</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379[15]&gt; HSET 'd-15' 'field' 1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379[15]&gt; HSET 'd-23' 'field' 9</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379[15]&gt; HSET 'd-110' 'field' 3</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379[15]&gt; SORT 'sort-input' by 'd-*-&gt;field'</span><br><span class="line">1) "15"</span><br><span class="line">2) "110"</span><br><span class="line">3) "7"</span><br><span class="line">4) "23"</span><br><span class="line">127.0.0.1:6379[15]&gt; SORT 'sort-input' by 'd-*-&gt;field' get 'd-*-&gt;field'</span><br><span class="line">1) "1"</span><br><span class="line">2) "3"</span><br><span class="line">3) "5"</span><br><span class="line">4) "9"</span><br></pre></td></tr></table></figure>
<h4 id="键的过期时间"><a class="markdownIt-Anchor" href="#键的过期时间"></a> 键的过期时间</h4>
<p>Redis 的 <code>EXPIRE</code> 命令可以指定一个键的过期时间，当达到过期时间后，Redis 会自动删除该键。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>PERSIST</code></td>
<td><code>PERSIST key-name</code>—移除键的过期时间</td>
</tr>
<tr>
<td><code>TTL</code></td>
<td><code>TTL key-name</code>—查看给定键距离过期还有多少秒</td>
</tr>
<tr>
<td><code>EXPIRE</code></td>
<td><code>EXPIRE key-name seconds</code>—让给定键在指定的秒数之后过期</td>
</tr>
<tr>
<td><code>EXPIREAT</code></td>
<td><code>EXPIREAT key-name timestamp</code>—将给定键的过期时间设置为给定的 UNIX 时间戳</td>
</tr>
<tr>
<td><code>PTTL</code></td>
<td><code>PTTL key-name</code>—查看给定键距离过期时间还有多少毫秒（这个命令在 Redis 2.6 或以上版本可用）</td>
</tr>
<tr>
<td><code>PEXPIRE</code></td>
<td><code>PEXPIRE key-name milliseconds</code>—让给定键在指定的毫秒数之后过期（这个命令在 Redis 2.6 或以上版本可用）</td>
</tr>
<tr>
<td><code>PEXPIREAT</code></td>
<td><code>PEXPIREAT key-name timestamp-milliseconds</code>—将一个毫秒级精度的 UNIX 时间戳设置为给定键的过期时间（这个命令在 Redis 2.6 或以上版本可用）</td>
</tr>
</tbody>
</table>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379[15]&gt; SET key value</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[15]&gt; GET key</span><br><span class="line">"value"</span><br><span class="line">127.0.0.1:6379[15]&gt; EXPIRE key 2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379[15]&gt; GET key</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>
<h2 id="二-redis-高级数据类型"><a class="markdownIt-Anchor" href="#二-redis-高级数据类型"></a> 二、Redis 高级数据类型</h2>
<h3 id="bitmap"><a class="markdownIt-Anchor" href="#bitmap"></a> BitMap</h3>
<p>BitMap 即位图。BitMap 不是一个真实的数据结构。而是 STRING 类型上的一组面向 bit 操作的集合。由于 STRING 是二进制安全的 blob，并且它们的最大长度是 512m，所以 BitMap 能最大设置 $$2^{32}$$ 个不同的 bit。</p>
<p>Bitmaps 的最大优点就是存储信息时可以节省大量的空间。例如在一个系统中，不同的用户被一个增长的用户 ID 表示。40 亿（$$2^{32}$$ = $$4<em>1024</em>1024*1024$$ ≈ 40 亿）用户只需要 512M 内存就能记住某种信息，例如用户是否登录过。</p>
<h4 id="bitmap-命令"><a class="markdownIt-Anchor" href="#bitmap-命令"></a> BitMap 命令</h4>
<ul>
<li><a href="http://redisdoc.com/bitmap/setbit.html" target="_blank" rel="noopener">SETBIT</a> - 对 <code>key</code> 所储存的字符串值，设置或清除指定偏移量上的位(bit)。</li>
<li><a href="http://redisdoc.com/bitmap/getbit.html" target="_blank" rel="noopener">GETBIT</a> - 对 <code>key</code> 所储存的字符串值，获取指定偏移量上的位(bit)。</li>
<li><a href="http://redisdoc.com/bitmap/bitcount.html" target="_blank" rel="noopener">BITCOUNT</a> - 计算给定字符串中，被设置为 <code>1</code> 的比特位的数量。</li>
<li><a href="http://redisdoc.com/bitmap/bitpos.html" target="_blank" rel="noopener">BITPOS</a></li>
<li><a href="http://redisdoc.com/bitmap/bitop.html" target="_blank" rel="noopener">BITOP</a></li>
<li><a href="http://redisdoc.com/bitmap/bitfield.html" target="_blank" rel="noopener">BITFIELD</a></li>
</ul>
<h4 id="bitmap-示例"><a class="markdownIt-Anchor" href="#bitmap-示例"></a> BitMap 示例</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 对不存在的 key 或者不存在的 offset 进行 GETBIT， 返回 0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> EXISTS bit</span></span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> GETBIT bit 10086</span></span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 对已存在的 offset 进行 GETBIT</span></span><br><span class="line"></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SETBIT bit 10086 1</span></span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> GETBIT bit 10086</span></span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> BITCOUNT bit</span></span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>
<h4 id="bitmap-应用"><a class="markdownIt-Anchor" href="#bitmap-应用"></a> BitMap 应用</h4>
<p>Bitmap 对于一些特定类型的计算非常有效。例如：使用 bitmap 实现用户上线次数统计。</p>
<p>假设现在我们希望记录自己网站上的用户的上线频率，比如说，计算用户 A 上线了多少天，用户 B 上线了多少天，诸如此类，以此作为数据，从而决定让哪些用户参加 beta 测试等活动 —— 这个模式可以使用 <a href="http://redisdoc.com/bitmap/setbit.html#setbit" target="_blank" rel="noopener">SETBIT key offset value</a> 和 [BITCOUNT key <a href="http://redisdoc.com/bitmap/bitcount.html#bitcount" target="_blank" rel="noopener">start] [end]</a> 来实现。</p>
<p>比如说，每当用户在某一天上线的时候，我们就使用 <a href="http://redisdoc.com/bitmap/setbit.html#setbit" target="_blank" rel="noopener">SETBIT key offset value</a> ，以用户名作为 <code>key</code>，将那天所代表的网站的上线日作为 <code>offset</code> 参数，并将这个 <code>offset</code> 上的为设置为 <code>1</code> 。</p>
<blockquote>
<p>更详细的实现可以参考：</p>
<p><a href="https://blog.csdn.net/u011957758/article/details/74783347" target="_blank" rel="noopener">一看就懂系列之 详解 redis 的 bitmap 在亿级项目中的应用</a></p>
<p><a href="http://blog.getspool.com/2011/11/29/fast-easy-realtime-metrics-using-redis-bitmaps/" target="_blank" rel="noopener">Fast, easy, realtime metrics using Redis bitmaps</a></p>
</blockquote>
<h3 id="hyperloglog"><a class="markdownIt-Anchor" href="#hyperloglog"></a> HyperLogLog</h3>
<p>HyperLogLog 是用于计算唯一事物的概率数据结构（从技术上讲，这被称为估计集合的基数）。如果统计唯一项，项目越多，需要的内存就越多。因为需要记住过去已经看过的项，从而避免多次统计这些项。</p>
<h4 id="hyperloglog-命令"><a class="markdownIt-Anchor" href="#hyperloglog-命令"></a> HyperLogLog 命令</h4>
<ul>
<li><a href="http://redisdoc.com/hyperloglog/pfadd.html" target="_blank" rel="noopener">PFADD</a> - 将任意数量的元素添加到指定的 HyperLogLog 里面。</li>
<li><a href="http://redisdoc.com/hyperloglog/pfcount.html" target="_blank" rel="noopener">PFCOUNT</a> - 返回 HyperLogLog 包含的唯一元素的近似数量。</li>
<li><a href="http://redisdoc.com/hyperloglog/pfmerge.html" target="_blank" rel="noopener">PFMERGE</a> - 将多个 HyperLogLog 合并（merge）为一个 HyperLogLog ， 合并后的 HyperLogLog 的基数接近于所有输入 HyperLogLog 的可见集合（observed set）的并集。合并得出的 HyperLogLog 会被储存在 <code>destkey</code> 键里面， 如果该键并不存在， 那么命令在执行之前， 会先为该键创建一个空的 HyperLogLog 。</li>
</ul>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> PFADD  databases  <span class="string">"Redis"</span>  <span class="string">"MongoDB"</span>  <span class="string">"MySQL"</span></span></span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> PFCOUNT  databases</span></span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> PFADD  databases  <span class="string">"Redis"</span>    <span class="comment"># Redis 已经存在，不必对估计数量进行更新</span></span></span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> PFCOUNT  databases    <span class="comment"># 元素估计数量没有变化</span></span></span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> PFADD  databases  <span class="string">"PostgreSQL"</span>    <span class="comment"># 添加一个不存在的元素</span></span></span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> PFCOUNT  databases    <span class="comment"># 估计数量增一</span></span></span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<h3 id="geo"><a class="markdownIt-Anchor" href="#geo"></a> GEO</h3>
<p>这个功能可以将用户给定的地理位置（经度和纬度）信息储存起来，并对这些信息进行操作。</p>
<h4 id="geo-命令"><a class="markdownIt-Anchor" href="#geo-命令"></a> GEO 命令</h4>
<ul>
<li><a href="http://redisdoc.com/geo/geoadd.html" target="_blank" rel="noopener">GEOADD</a> - 将指定的地理空间位置（纬度、经度、名称）添加到指定的 key 中。</li>
<li><a href="http://redisdoc.com/geo/geopos.html" target="_blank" rel="noopener">GEOPOS</a> - 从 key 里返回所有给定位置元素的位置（经度和纬度）。</li>
<li><a href="http://redisdoc.com/geo/geodist.html" target="_blank" rel="noopener">GEODIST</a> - 返回两个给定位置之间的距离。</li>
<li><a href="http://redisdoc.com/geo/geohash.html" target="_blank" rel="noopener">GEOHASH</a> - 回一个或多个位置元素的标准 Geohash 值，它可以在http://geohash.org/使用。</li>
<li><a href="http://redisdoc.com/geo/georadius.html" target="_blank" rel="noopener">GEORADIUS</a></li>
<li><a href="http://redisdoc.com/geo/georadiusbymember.html" target="_blank" rel="noopener">GEORADIUSBYMEMBER</a></li>
</ul>
<h2 id="三-redis-数据类型应用"><a class="markdownIt-Anchor" href="#三-redis-数据类型应用"></a> 三、Redis 数据类型应用</h2>
<h3 id="案例-最受欢迎文章"><a class="markdownIt-Anchor" href="#案例-最受欢迎文章"></a> 案例-最受欢迎文章</h3>
<p>选出最受欢迎文章，需要支持对文章进行评分。</p>
<h4 id="对文章进行投票"><a class="markdownIt-Anchor" href="#对文章进行投票"></a> 对文章进行投票</h4>
<p>（1）使用 HASH 存储文章</p>
<p>使用 <code>HASH</code> 类型存储文章信息。其中：key 是文章 ID；field 是文章的属性 key；value 是属性对应值。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200225143038.jpg" alt="img" /></p>
<p>操作：</p>
<ul>
<li>存储文章信息 - 使用 <code>HSET</code> 或 <code>HMGET</code> 命令</li>
<li>查询文章信息 - 使用 <code>HGETALL</code> 命令</li>
<li>添加投票 - 使用 <code>HINCRBY</code> 命令</li>
</ul>
<p>（2）使用 <code>ZSET</code> 针对不同维度集合排序</p>
<p>使用 <code>ZSET</code> 类型分别存储按照时间排序和按照评分排序的文章 ID 集合。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200225145742.jpg" alt="img" /></p>
<p>操作：</p>
<ul>
<li>添加记录 - 使用 <code>ZADD</code> 命令</li>
<li>添加分数 - 使用 <code>ZINCRBY</code> 命令</li>
<li>取出多篇文章 - 使用 <code>ZREVRANGE</code> 命令</li>
</ul>
<p>（3）为了防止重复投票，使用 <code>SET</code> 类型记录每篇文章 ID 对应的投票集合。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200225150105.jpg" alt="img" /></p>
<p>操作：</p>
<ul>
<li>添加投票者 - 使用 <code>SADD</code> 命令</li>
<li>设置有效期 - 使用 <code>EXPIRE</code> 命令</li>
</ul>
<p>（4）假设 user:115423 给 article:100408 投票，分别需要高更新评分排序集合以及投票集合。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200225150138.jpg" alt="img" /></p>
<p>当需要对一篇文章投票时，程序需要用 ZSCORE 命令检查记录文章发布时间的有序集合，判断文章的发布时间是否超过投票有效期（比如：一星期）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">articleVote</span><span class="params">(Jedis conn, String user, String article)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算文章的投票截止时间。</span></span><br><span class="line">    <span class="keyword">long</span> cutoff = (System.currentTimeMillis() / <span class="number">1000</span>) - ONE_WEEK_IN_SECONDS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否还可以对文章进行投票</span></span><br><span class="line">    <span class="comment">// （虽然使用散列也可以获取文章的发布时间，</span></span><br><span class="line">    <span class="comment">// 但有序集合返回的文章发布时间为浮点数，</span></span><br><span class="line">    <span class="comment">// 可以不进行转换直接使用）。</span></span><br><span class="line">    <span class="keyword">if</span> (conn.zscore(<span class="string">"time:"</span>, article) &lt; cutoff) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从article:id标识符（identifier）里面取出文章的ID。</span></span><br><span class="line">    String articleId = article.substring(article.indexOf(<span class="string">':'</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果用户是第一次为这篇文章投票，那么增加这篇文章的投票数量和评分。</span></span><br><span class="line">    <span class="keyword">if</span> (conn.sadd(<span class="string">"voted:"</span> + articleId, user) == <span class="number">1</span>) &#123;</span><br><span class="line">        conn.zincrby(<span class="string">"score:"</span>, VOTE_SCORE, article);</span><br><span class="line">        conn.hincrBy(article, <span class="string">"votes"</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="发布并获取文章"><a class="markdownIt-Anchor" href="#发布并获取文章"></a> 发布并获取文章</h4>
<p>发布文章：</p>
<ul>
<li>添加文章 - 使用 <code>INCR</code> 命令计算新的文章 ID，填充文章信息，然后用 <code>HSET</code> 命令或 <code>HMSET</code> 命令写入到 <code>HASH</code> 结构中。</li>
<li>将文章作者 ID 添加到投票名单 - 使用 <code>SADD</code> 命令添加到代表投票名单的 <code>SET</code> 结构中。</li>
<li>设置投票有效期 - 使用 <code>EXPIRE</code> 命令设置投票有效期。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">postArticle</span><span class="params">(Jedis conn, String user, String title, String link)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 生成一个新的文章ID。</span></span><br><span class="line">    String articleId = String.valueOf(conn.incr(<span class="string">"article:"</span>));</span><br><span class="line"></span><br><span class="line">    String voted = <span class="string">"voted:"</span> + articleId;</span><br><span class="line">    <span class="comment">// 将发布文章的用户添加到文章的已投票用户名单里面，</span></span><br><span class="line">    conn.sadd(voted, user);</span><br><span class="line">    <span class="comment">// 然后将这个名单的过期时间设置为一周（第3章将对过期时间作更详细的介绍）。</span></span><br><span class="line">    conn.expire(voted, ONE_WEEK_IN_SECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> now = System.currentTimeMillis() / <span class="number">1000</span>;</span><br><span class="line">    String article = <span class="string">"article:"</span> + articleId;</span><br><span class="line">    <span class="comment">// 将文章信息存储到一个散列里面。</span></span><br><span class="line">    HashMap&lt;String, String&gt; articleData = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    articleData.put(<span class="string">"title"</span>, title);</span><br><span class="line">    articleData.put(<span class="string">"link"</span>, link);</span><br><span class="line">    articleData.put(<span class="string">"user"</span>, user);</span><br><span class="line">    articleData.put(<span class="string">"now"</span>, String.valueOf(now));</span><br><span class="line">    articleData.put(<span class="string">"votes"</span>, <span class="string">"1"</span>);</span><br><span class="line">    conn.hmset(article, articleData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将文章添加到根据发布时间排序的有序集合和根据评分排序的有序集合里面。</span></span><br><span class="line">    conn.zadd(<span class="string">"score:"</span>, now + VOTE_SCORE, article);</span><br><span class="line">    conn.zadd(<span class="string">"time:"</span>, now, article);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> articleId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分页查询最受欢迎文章：</p>
<p>使用 <code>ZINTERSTORE</code> 命令根据页码、每页记录数、排序号，根据评分值从大到小分页查出文章 ID 列表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Map&lt;String, String&gt;&gt; getArticles(Jedis conn, <span class="keyword">int</span> page, String order) &#123;</span><br><span class="line">    <span class="comment">// 设置获取文章的起始索引和结束索引。</span></span><br><span class="line">    <span class="keyword">int</span> start = (page - <span class="number">1</span>) * ARTICLES_PER_PAGE;</span><br><span class="line">    <span class="keyword">int</span> end = start + ARTICLES_PER_PAGE - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取多个文章ID。</span></span><br><span class="line">    Set&lt;String&gt; ids = conn.zrevrange(order, start, end);</span><br><span class="line">    List&lt;Map&lt;String, String&gt;&gt; articles = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 根据文章ID获取文章的详细信息。</span></span><br><span class="line">    <span class="keyword">for</span> (String id : ids) &#123;</span><br><span class="line">        Map&lt;String, String&gt; articleData = conn.hgetAll(id);</span><br><span class="line">        articleData.put(<span class="string">"id"</span>, id);</span><br><span class="line">        articles.add(articleData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> articles;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="对文章进行分组"><a class="markdownIt-Anchor" href="#对文章进行分组"></a> 对文章进行分组</h4>
<p>如果文章需要分组，功能需要分为两块：</p>
<ul>
<li>记录文章属于哪个群组</li>
<li>负责取出群组里的文章</li>
</ul>
<p>将文章添加、删除群组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addRemoveGroups</span><span class="params">(Jedis conn, String articleId, String[] toAdd, String[] toRemove)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构建存储文章信息的键名。</span></span><br><span class="line">    String article = <span class="string">"article:"</span> + articleId;</span><br><span class="line">    <span class="comment">// 将文章添加到它所属的群组里面。</span></span><br><span class="line">    <span class="keyword">for</span> (String group : toAdd) &#123;</span><br><span class="line">        conn.sadd(<span class="string">"group:"</span> + group, article);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从群组里面移除文章。</span></span><br><span class="line">    <span class="keyword">for</span> (String group : toRemove) &#123;</span><br><span class="line">        conn.srem(<span class="string">"group:"</span> + group, article);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>取出群组里的文章：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200225214210.jpg" alt="img" /></p>
<ul>
<li>通过对存储群组文章的集合和存储文章评分的有序集合执行 <code>ZINTERSTORE</code> 命令，可以得到按照文章评分排序的群组文章。</li>
<li>通过对存储群组文章的集合和存储文章发布时间的有序集合执行 <code>ZINTERSTORE</code> 命令，可以得到按照文章发布时间排序的群组文章。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Map&lt;String, String&gt;&gt; getGroupArticles(Jedis conn, String group, <span class="keyword">int</span> page, String order) &#123;</span><br><span class="line">    <span class="comment">// 为每个群组的每种排列顺序都创建一个键。</span></span><br><span class="line">    String key = order + group;</span><br><span class="line">    <span class="comment">// 检查是否有已缓存的排序结果，如果没有的话就现在进行排序。</span></span><br><span class="line">    <span class="keyword">if</span> (!conn.exists(key)) &#123;</span><br><span class="line">        <span class="comment">// 根据评分或者发布时间，对群组文章进行排序。</span></span><br><span class="line">        ZParams params = <span class="keyword">new</span> ZParams().aggregate(ZParams.Aggregate.MAX);</span><br><span class="line">        conn.zinterstore(key, params, <span class="string">"group:"</span> + group, order);</span><br><span class="line">        <span class="comment">// 让Redis在60秒钟之后自动删除这个有序集合。</span></span><br><span class="line">        conn.expire(key, <span class="number">60</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用之前定义的getArticles函数来进行分页并获取文章数据。</span></span><br><span class="line">    <span class="keyword">return</span> getArticles(conn, page, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="案例-管理令牌"><a class="markdownIt-Anchor" href="#案例-管理令牌"></a> 案例-管理令牌</h3>
<p>网站一般会以 Cookie、Session、令牌这类信息存储用户身份信息。</p>
<p>可以将 Cookie/Session/令牌 和用户的映射关系存储在 <code>HASH</code> 结构。</p>
<p>下面以令牌来举例。</p>
<h4 id="查询令牌"><a class="markdownIt-Anchor" href="#查询令牌"></a> 查询令牌</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">checkToken</span><span class="params">(Jedis conn, String token)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试获取并返回令牌对应的用户。</span></span><br><span class="line">    <span class="keyword">return</span> conn.hget(<span class="string">"login:"</span>, token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="更新令牌"><a class="markdownIt-Anchor" href="#更新令牌"></a> 更新令牌</h4>
<ul>
<li>用户每次访问页面，可以记录下令牌和当前时间戳的映射关系，存入一个 <code>ZSET</code> 结构中，以便分析用户是否活跃，继而可以周期性清理最老的令牌，统计当前在线用户数等行为。</li>
<li>用户如果正在浏览商品，可以记录到用户最近浏览过的商品有序集合中（集合可以限定数量，超过数量进行裁剪），存入到一个 <code>ZSET</code> 结构中，以便分析用户最近可能感兴趣的商品，以便推荐商品。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateToken</span><span class="params">(Jedis conn, String token, String user, String item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前时间戳。</span></span><br><span class="line">    <span class="keyword">long</span> timestamp = System.currentTimeMillis() / <span class="number">1000</span>;</span><br><span class="line">    <span class="comment">// 维持令牌与已登录用户之间的映射。</span></span><br><span class="line">    conn.hset(<span class="string">"login:"</span>, token, user);</span><br><span class="line">    <span class="comment">// 记录令牌最后一次出现的时间。</span></span><br><span class="line">    conn.zadd(<span class="string">"recent:"</span>, timestamp, token);</span><br><span class="line">    <span class="keyword">if</span> (item != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 记录用户浏览过的商品。</span></span><br><span class="line">        conn.zadd(<span class="string">"viewed:"</span> + token, timestamp, item);</span><br><span class="line">        <span class="comment">// 移除旧的记录，只保留用户最近浏览过的25个商品。</span></span><br><span class="line">        conn.zremrangeByRank(<span class="string">"viewed:"</span> + token, <span class="number">0</span>, -<span class="number">26</span>);</span><br><span class="line">        conn.zincrby(<span class="string">"viewed:"</span>, -<span class="number">1</span>, item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="清理令牌"><a class="markdownIt-Anchor" href="#清理令牌"></a> 清理令牌</h4>
<p>上一节提到，更新令牌时，将令牌和当前时间戳的映射关系，存入一个 <code>ZSET</code> 结构中。所以可以通过排序得知哪些令牌最老。如果没有清理操作，更新令牌占用的内存会不断膨胀，直到导致机器宕机。</p>
<p>比如：最多允许存储 1000 万条令牌信息，周期性检查，一旦发现记录数超出 1000 万条，将 ZSET 从新到老排序，将超出 1000 万条的记录清除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CleanSessionsThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Jedis conn;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> limit;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> quit;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CleanSessionsThread</span><span class="params">(<span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.conn = <span class="keyword">new</span> Jedis(<span class="string">"localhost"</span>);</span><br><span class="line">        <span class="keyword">this</span>.conn.select(<span class="number">15</span>);</span><br><span class="line">        <span class="keyword">this</span>.limit = limit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        quit = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!quit) &#123;</span><br><span class="line">            <span class="comment">// 找出目前已有令牌的数量。</span></span><br><span class="line">            <span class="keyword">long</span> size = conn.zcard(<span class="string">"recent:"</span>);</span><br><span class="line">            <span class="comment">// 令牌数量未超过限制，休眠并在之后重新检查。</span></span><br><span class="line">            <span class="keyword">if</span> (size &lt;= limit) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取需要移除的令牌ID。</span></span><br><span class="line">            <span class="keyword">long</span> endIndex = Math.min(size - limit, <span class="number">100</span>);</span><br><span class="line">            Set&lt;String&gt; tokenSet = conn.zrange(<span class="string">"recent:"</span>, <span class="number">0</span>, endIndex - <span class="number">1</span>);</span><br><span class="line">            String[] tokens = tokenSet.toArray(<span class="keyword">new</span> String[tokenSet.size()]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 为那些将要被删除的令牌构建键名。</span></span><br><span class="line">            ArrayList&lt;String&gt; sessionKeys = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">            <span class="keyword">for</span> (String token : tokens) &#123;</span><br><span class="line">                sessionKeys.add(<span class="string">"viewed:"</span> + token);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 移除最旧的那些令牌。</span></span><br><span class="line">            conn.del(sessionKeys.toArray(<span class="keyword">new</span> String[sessionKeys.size()]));</span><br><span class="line">            conn.hdel(<span class="string">"login:"</span>, tokens);</span><br><span class="line">            conn.zrem(<span class="string">"recent:"</span>, tokens);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="案例-购物车"><a class="markdownIt-Anchor" href="#案例-购物车"></a> 案例-购物车</h3>
<p>可以使用 HASH 结构来实现购物车功能。</p>
<p>每个用户的购物车，存储了商品 ID 和商品数量的映射。</p>
<h4 id="在购物车中添加-删除商品"><a class="markdownIt-Anchor" href="#在购物车中添加-删除商品"></a> 在购物车中添加、删除商品</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addToCart</span><span class="params">(Jedis conn, String session, String item, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 从购物车里面移除指定的商品。</span></span><br><span class="line">        conn.hdel(<span class="string">"cart:"</span> + session, item);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 将指定的商品添加到购物车。</span></span><br><span class="line">        conn.hset(<span class="string">"cart:"</span> + session, item, String.valueOf(count));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="清空购物车"><a class="markdownIt-Anchor" href="#清空购物车"></a> 清空购物车</h4>
<p>在 <a href="#%E6%B8%85%E7%90%86%E4%BB%A4%E7%89%8C">清理令牌</a> 的基础上，清空会话时，顺便将购物车缓存一并清理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (!quit) &#123;</span><br><span class="line">     <span class="keyword">long</span> size = conn.zcard(<span class="string">"recent:"</span>);</span><br><span class="line">     <span class="keyword">if</span> (size &lt;= limit) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             sleep(<span class="number">1000</span>);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">             Thread.currentThread().interrupt();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">continue</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">long</span> endIndex = Math.min(size - limit, <span class="number">100</span>);</span><br><span class="line">     Set&lt;String&gt; sessionSet = conn.zrange(<span class="string">"recent:"</span>, <span class="number">0</span>, endIndex - <span class="number">1</span>);</span><br><span class="line">     String[] sessions = sessionSet.toArray(<span class="keyword">new</span> String[sessionSet.size()]);</span><br><span class="line"></span><br><span class="line">     ArrayList&lt;String&gt; sessionKeys = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">     <span class="keyword">for</span> (String sess : sessions) &#123;</span><br><span class="line">         sessionKeys.add(<span class="string">"viewed:"</span> + sess);</span><br><span class="line">         <span class="comment">// 新增加的这行代码用于删除旧会话对应用户的购物车。</span></span><br><span class="line">         sessionKeys.add(<span class="string">"cart:"</span> + sess);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     conn.del(sessionKeys.toArray(<span class="keyword">new</span> String[sessionKeys.size()]));</span><br><span class="line">     conn.hdel(<span class="string">"login:"</span>, sessions);</span><br><span class="line">     conn.zrem(<span class="string">"recent:"</span>, sessions);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="案例-页面缓存"><a class="markdownIt-Anchor" href="#案例-页面缓存"></a> 案例-页面缓存</h3>
<p>大部分网页内容并不会经常改变，但是访问时，后台需要动态计算，这可能耗时较多，此时可以使用 <code>STRING</code> 结构存储页面缓存，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">cacheRequest</span><span class="params">(Jedis conn, String request, Callback callback)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对于不能被缓存的请求，直接调用回调函数。</span></span><br><span class="line">    <span class="keyword">if</span> (!canCache(conn, request)) &#123;</span><br><span class="line">        <span class="keyword">return</span> callback != <span class="keyword">null</span> ? callback.call(request) : <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将请求转换成一个简单的字符串键，方便之后进行查找。</span></span><br><span class="line">    String pageKey = <span class="string">"cache:"</span> + hashRequest(request);</span><br><span class="line">    <span class="comment">// 尝试查找被缓存的页面。</span></span><br><span class="line">    String content = conn.get(pageKey);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (content == <span class="keyword">null</span> &amp;&amp; callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果页面还没有被缓存，那么生成页面。</span></span><br><span class="line">        content = callback.call(request);</span><br><span class="line">        <span class="comment">// 将新生成的页面放到缓存里面。</span></span><br><span class="line">        conn.setex(pageKey, <span class="number">300</span>, content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回页面。</span></span><br><span class="line">    <span class="keyword">return</span> content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="案例-数据行缓存"><a class="markdownIt-Anchor" href="#案例-数据行缓存"></a> 案例-数据行缓存</h3>
<p>电商网站可能会有促销、特卖、抽奖等活动，这些活动页面只需要从数据库中加载几行数据，如：用户信息、商品信息。</p>
<p>可以使用 <code>STRING</code> 结构来缓存这些数据，使用 JSON 存储结构化的信息。</p>
<p>此外，需要有两个 <code>ZSET</code> 结构来记录更新缓存的时机：</p>
<ul>
<li>第一个为调度有序集合；</li>
<li>第二个为延时有序集合。</li>
</ul>
<p>记录缓存时机：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleRowCache</span><span class="params">(Jedis conn, String rowId, <span class="keyword">int</span> delay)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先设置数据行的延迟值。</span></span><br><span class="line">    conn.zadd(<span class="string">"delay:"</span>, delay, rowId);</span><br><span class="line">    <span class="comment">// 立即缓存数据行。</span></span><br><span class="line">    conn.zadd(<span class="string">"schedule:"</span>, System.currentTimeMillis() / <span class="number">1000</span>, rowId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定时更新数据行缓存：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheRowsThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Jedis conn;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> quit;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CacheRowsThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.conn = <span class="keyword">new</span> Jedis(<span class="string">"localhost"</span>);</span><br><span class="line">        <span class="keyword">this</span>.conn.select(<span class="number">15</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        quit = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">        <span class="keyword">while</span> (!quit) &#123;</span><br><span class="line">            <span class="comment">// 尝试获取下一个需要被缓存的数据行以及该行的调度时间戳，</span></span><br><span class="line">            <span class="comment">// 命令会返回一个包含零个或一个元组（tuple）的列表。</span></span><br><span class="line">            Set&lt;Tuple&gt; range = conn.zrangeWithScores(<span class="string">"schedule:"</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            Tuple next = range.size() &gt; <span class="number">0</span> ? range.iterator().next() : <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">long</span> now = System.currentTimeMillis() / <span class="number">1000</span>;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span> || next.getScore() &gt; now) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 暂时没有行需要被缓存，休眠50毫秒后重试。</span></span><br><span class="line">                    sleep(<span class="number">50</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String rowId = next.getElement();</span><br><span class="line">            <span class="comment">// 获取下一次调度前的延迟时间。</span></span><br><span class="line">            <span class="keyword">double</span> delay = conn.zscore(<span class="string">"delay:"</span>, rowId);</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 不必再缓存这个行，将它从缓存中移除。</span></span><br><span class="line">                conn.zrem(<span class="string">"delay:"</span>, rowId);</span><br><span class="line">                conn.zrem(<span class="string">"schedule:"</span>, rowId);</span><br><span class="line">                conn.del(<span class="string">"inv:"</span> + rowId);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 读取数据行。</span></span><br><span class="line">            Inventory row = Inventory.get(rowId);</span><br><span class="line">            <span class="comment">// 更新调度时间并设置缓存值。</span></span><br><span class="line">            conn.zadd(<span class="string">"schedule:"</span>, now + delay, rowId);</span><br><span class="line">            conn.set(<span class="string">"inv:"</span> + rowId, gson.toJson(row));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="案例-网页分析"><a class="markdownIt-Anchor" href="#案例-网页分析"></a> 案例-网页分析</h3>
<p>网站可以采集用户的访问、交互、购买行为，再分析用户习惯、喜好，从而判断市场行情和潜在商机等。</p>
<p>那么，简单的，如何记录用户在一定时间内访问的商品页面呢？</p>
<p>参考 <a href="#%E6%9B%B4%E6%96%B0%E4%BB%A4%E7%89%8C">更新令牌</a> 代码示例，记录用户访问不同商品的浏览次数，并排序。</p>
<p>判断页面是否需要缓存，根据评分判断商品页面是否热门：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canCache</span><span class="params">(Jedis conn, String request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        URL url = <span class="keyword">new</span> URL(request);</span><br><span class="line">        HashMap&lt;String, String&gt; params = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (url.getQuery() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String param : url.getQuery().split(<span class="string">"&amp;"</span>)) &#123;</span><br><span class="line">                String[] pair = param.split(<span class="string">"="</span>, <span class="number">2</span>);</span><br><span class="line">                params.put(pair[<span class="number">0</span>], pair.length == <span class="number">2</span> ? pair[<span class="number">1</span>] : <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试从页面里面取出商品ID。</span></span><br><span class="line">        String itemId = extractItemId(params);</span><br><span class="line">        <span class="comment">// 检查这个页面能否被缓存以及这个页面是否为商品页面。</span></span><br><span class="line">        <span class="keyword">if</span> (itemId == <span class="keyword">null</span> || isDynamic(params)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取得商品的浏览次数排名。</span></span><br><span class="line">        Long rank = conn.zrank(<span class="string">"viewed:"</span>, itemId);</span><br><span class="line">        <span class="comment">// 根据商品的浏览次数排名来判断是否需要缓存这个页面。</span></span><br><span class="line">        <span class="keyword">return</span> rank != <span class="keyword">null</span> &amp;&amp; rank &lt; <span class="number">10000</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MalformedURLException mue) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="案例-记录日志"><a class="markdownIt-Anchor" href="#案例-记录日志"></a> 案例-记录日志</h3>
<p>可用使用 <code>LIST</code> 结构存储日志数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logRecent</span><span class="params">(Jedis conn, String name, String message, String severity)</span> </span>&#123;</span><br><span class="line">    String destination = <span class="string">"recent:"</span> + name + <span class="string">':'</span> + severity;</span><br><span class="line">    Pipeline pipe = conn.pipelined();</span><br><span class="line">    pipe.lpush(destination, TIMESTAMP.format(<span class="keyword">new</span> Date()) + <span class="string">' '</span> + message);</span><br><span class="line">    pipe.ltrim(destination, <span class="number">0</span>, <span class="number">99</span>);</span><br><span class="line">    pipe.sync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="案例-统计数据"><a class="markdownIt-Anchor" href="#案例-统计数据"></a> 案例-统计数据</h3>
<p>更新计数器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] PRECISION = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">1</span>, <span class="number">5</span>, <span class="number">60</span>, <span class="number">300</span>, <span class="number">3600</span>, <span class="number">18000</span>, <span class="number">86400</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateCounter</span><span class="params">(Jedis conn, String name, <span class="keyword">int</span> count, <span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    Transaction trans = conn.multi();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> prec : PRECISION) &#123;</span><br><span class="line">        <span class="keyword">long</span> pnow = (now / prec) * prec;</span><br><span class="line">        String hash = String.valueOf(prec) + <span class="string">':'</span> + name;</span><br><span class="line">        trans.zadd(<span class="string">"known:"</span>, <span class="number">0</span>, hash);</span><br><span class="line">        trans.hincrBy(<span class="string">"count:"</span> + hash, String.valueOf(pnow), count);</span><br><span class="line">    &#125;</span><br><span class="line">    trans.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看计数器数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Pair&lt;Integer&gt;&gt; getCounter(</span><br><span class="line">    Jedis conn, String name, <span class="keyword">int</span> precision) &#123;</span><br><span class="line">    String hash = String.valueOf(precision) + <span class="string">':'</span> + name;</span><br><span class="line">    Map&lt;String, String&gt; data = conn.hgetAll(<span class="string">"count:"</span> + hash);</span><br><span class="line">    List&lt;Pair&lt;Integer&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : data.entrySet()) &#123;</span><br><span class="line">        results.add(<span class="keyword">new</span> Pair&lt;&gt;(</span><br><span class="line">            entry.getKey(),</span><br><span class="line">            Integer.parseInt(entry.getValue())));</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.sort(results);</span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="案例-查找-ip-所属地"><a class="markdownIt-Anchor" href="#案例-查找-ip-所属地"></a> 案例-查找 IP 所属地</h3>
<p>Redis 实现的 IP 所属地查找比关系型数据实现方式更快。</p>
<h4 id="载入-ip-数据"><a class="markdownIt-Anchor" href="#载入-ip-数据"></a> 载入 IP 数据</h4>
<p>IP 地址转为整数值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ipToScore</span><span class="params">(String ipAddress)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> score = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (String v : ipAddress.split(<span class="string">"\\."</span>)) &#123;</span><br><span class="line">        score = score * <span class="number">256</span> + Integer.parseInt(v, <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建 IP 地址与城市 ID 之间的映射：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">importIpsToRedis</span><span class="params">(Jedis conn, File file)</span> </span>&#123;</span><br><span class="line">    FileReader reader = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 载入 csv 文件数据</span></span><br><span class="line">        reader = <span class="keyword">new</span> FileReader(file);</span><br><span class="line">        CSVFormat csvFormat = CSVFormat.DEFAULT.withRecordSeparator(<span class="string">"\n"</span>);</span><br><span class="line">        CSVParser csvParser = csvFormat.parse(reader);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        List&lt;CSVRecord&gt; records = csvParser.getRecords();</span><br><span class="line">        <span class="keyword">for</span> (CSVRecord line : records) &#123;</span><br><span class="line">            String startIp = line.get(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (startIp.toLowerCase().indexOf(<span class="string">'i'</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将 IP 地址转为整数值</span></span><br><span class="line">            <span class="keyword">int</span> score = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (startIp.indexOf(<span class="string">'.'</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">                score = ipToScore(startIp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    score = Integer.parseInt(startIp, <span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NumberFormatException nfe) &#123;</span><br><span class="line">                    <span class="comment">// 略过文件的第一行以及格式不正确的条目</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 构建唯一的城市 ID</span></span><br><span class="line">            String cityId = line.get(<span class="number">2</span>) + <span class="string">'_'</span> + count;</span><br><span class="line">            <span class="comment">// 将城市 ID 及其对应的 IP 地址整数值添加到 ZSET</span></span><br><span class="line">            conn.zadd(<span class="string">"ip2cityid:"</span>, score, cityId);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            reader.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// ignore</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>存储城市信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">importCitiesToRedis</span><span class="params">(Jedis conn, File file)</span> </span>&#123;</span><br><span class="line">    Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">    FileReader reader = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 加载 csv 信息</span></span><br><span class="line">        reader = <span class="keyword">new</span> FileReader(file);</span><br><span class="line">        CSVFormat csvFormat = CSVFormat.DEFAULT.withRecordSeparator(<span class="string">"\n"</span>);</span><br><span class="line">        CSVParser parser = <span class="keyword">new</span> CSVParser(reader, csvFormat);</span><br><span class="line">        <span class="comment">// String[] line;</span></span><br><span class="line">        List&lt;CSVRecord&gt; records = parser.getRecords();</span><br><span class="line">        <span class="keyword">for</span> (CSVRecord record : records) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (record.size() &lt; <span class="number">4</span> || !Character.isDigit(record.get(<span class="number">0</span>).charAt(<span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将城市地理信息转为 json 结构，存入 HASH 结构中</span></span><br><span class="line">            String cityId = record.get(<span class="number">0</span>);</span><br><span class="line">            String country = record.get(<span class="number">1</span>);</span><br><span class="line">            String region = record.get(<span class="number">2</span>);</span><br><span class="line">            String city = record.get(<span class="number">3</span>);</span><br><span class="line">            String json = gson.toJson(<span class="keyword">new</span> String[] &#123; city, region, country &#125;);</span><br><span class="line">            conn.hset(<span class="string">"cityid2city:"</span>, cityId, json);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            reader.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// ignore</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="查找-ip-所属城市"><a class="markdownIt-Anchor" href="#查找-ip-所属城市"></a> 查找 IP 所属城市</h4>
<p>操作步骤：</p>
<ol>
<li>将要查找的 IP 地址转为整数值；</li>
<li>查找所有分值小于等于要查找的 IP 地址的地址，取出其中最大分值的那个记录；</li>
<li>用找到的记录所对应的城市 ID 去检索城市信息。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] findCityByIp(Jedis conn, String ipAddress) &#123;</span><br><span class="line">    <span class="keyword">int</span> score = ipToScore(ipAddress);</span><br><span class="line">    Set&lt;String&gt; results = conn.zrevrangeByScore(<span class="string">"ip2cityid:"</span>, score, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (results.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String cityId = results.iterator().next();</span><br><span class="line">    cityId = cityId.substring(<span class="number">0</span>, cityId.indexOf(<span class="string">'_'</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Gson().fromJson(conn.hget(<span class="string">"cityid2city:"</span>, cityId), String[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="案例-服务的发现与配置"><a class="markdownIt-Anchor" href="#案例-服务的发现与配置"></a> 案例-服务的发现与配置</h3>
<h3 id="案例-自动补全"><a class="markdownIt-Anchor" href="#案例-自动补全"></a> 案例-自动补全</h3>
<p>需求：根据用户输入，自动补全信息，如：联系人、商品名等。</p>
<ul>
<li>典型场景一：社交网站后台记录用户最近联系过的 100 个好友，当用户查找好友时，根据输入的关键字自动补全姓名。</li>
<li>典型场景二：电商网站后台记录用户最近浏览过的 10 件商品，当用户查找商品是，根据输入的关键字自动补全商品名称。</li>
</ul>
<p>数据模型：使用 Redis 的 LIST 类型存储最近联系人列表。</p>
<p>构建自动补全列表通常有以下操作：</p>
<ul>
<li>如果指定联系人已经存在于最近联系人列表里，那么从列表里移除他。对应 <code>LREM</code> 命令。</li>
<li>将指定联系人添加到最近联系人列表的最前面。对应 <code>LPUSH</code> 命令。</li>
<li>添加操作完成后，如果联系人列表中的数量超过 100 个，进行裁剪操作。对应 <code>LTRIM</code> 命令。</li>
</ul>
<h3 id="案例-广告定向"><a class="markdownIt-Anchor" href="#案例-广告定向"></a> 案例-广告定向</h3>
<h3 id="案例-职位搜索"><a class="markdownIt-Anchor" href="#案例-职位搜索"></a> 案例-职位搜索</h3>
<p>需求：在一个招聘网站上，求职者有自己的技能清单；用人公司的职位有必要的技能清单。用人公司需要查询满足自己职位要求的求职者；求职者需要查询自己可以投递简历的职位。</p>
<p>关键数据模型：使用 <code>SET</code> 类型存储求职者的技能列表，使用 <code>SET</code> 类型存储职位的技能列表。</p>
<p>关键操作：使用 <code>SDIFF</code> 命令对比两个 <code>SET</code> 的差异，返回 <code>empty</code> 表示匹配要求。</p>
<p>redis cli 示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -----------------------------------------------------------</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Redis 职位搜索数据模型示例</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -----------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> （1）职位技能表：使用 <span class="built_in">set</span> 存储</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> job:001 职位添加 4 种技能</span></span><br><span class="line">SADD job:001 skill:001</span><br><span class="line">SADD job:001 skill:002</span><br><span class="line">SADD job:001 skill:003</span><br><span class="line">SADD job:001 skill:004</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> job:002 职位添加 3 种技能</span></span><br><span class="line">SADD job:002 skill:001</span><br><span class="line">SADD job:002 skill:002</span><br><span class="line">SADD job:002 skill:003</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> job:003 职位添加 2 种技能</span></span><br><span class="line">SADD job:003 skill:001</span><br><span class="line">SADD job:003 skill:003</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看</span></span><br><span class="line">SMEMBERS job:001</span><br><span class="line">SMEMBERS job:002</span><br><span class="line">SMEMBERS job:003</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> （2）求职者技能表：使用 <span class="built_in">set</span> 存储</span></span><br><span class="line">SADD interviewee:001 skill:001</span><br><span class="line">SADD interviewee:001 skill:003</span><br><span class="line"></span><br><span class="line">SADD interviewee:002 skill:001</span><br><span class="line">SADD interviewee:002 skill:002</span><br><span class="line">SADD interviewee:002 skill:003</span><br><span class="line">SADD interviewee:002 skill:004</span><br><span class="line">SADD interviewee:002 skill:005</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看</span></span><br><span class="line">SMEMBERS interviewee:001</span><br><span class="line">SMEMBERS interviewee:002</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> （3）求职者遍历查找自己符合要求的职位（返回结果为 empty 表示要求的技能全部命中）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 比较职位技能清单和求职者技能清单的差异</span></span><br><span class="line">SDIFF job:001 interviewee:001</span><br><span class="line">SDIFF job:002 interviewee:001</span><br><span class="line">SDIFF job:003 interviewee:001</span><br><span class="line"></span><br><span class="line">SDIFF job:001 interviewee:002</span><br><span class="line">SDIFF job:002 interviewee:002</span><br><span class="line">SDIFF job:003 interviewee:002</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> （4）用人公司根据遍历查找符合自己职位要求的求职者（返回结果为 empty 表示要求的技能全部命中）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 比较职位技能清单和求职者技能清单的差异</span></span><br><span class="line">SDIFF interviewee:001 job:001</span><br><span class="line">SDIFF interviewee:002 job:001</span><br><span class="line"></span><br><span class="line">SDIFF interviewee:001 job:002</span><br><span class="line">SDIFF interviewee:002 job:002</span><br><span class="line"></span><br><span class="line">SDIFF interviewee:001 job:003</span><br><span class="line">SDIFF interviewee:002 job:003</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><strong>官网</strong>
<ul>
<li><a href="https://redis.io/" target="_blank" rel="noopener">Redis 官网</a></li>
<li><a href="https://github.com/antirez/redis" target="_blank" rel="noopener">Redis github</a></li>
<li><a href="http://redis.cn/" target="_blank" rel="noopener">Redis 官方文档中文版</a></li>
</ul>
</li>
<li><strong>书籍</strong>
<ul>
<li><a href="https://item.jd.com/11791607.html" target="_blank" rel="noopener">《Redis 实战》</a></li>
<li><a href="https://item.jd.com/11486101.html" target="_blank" rel="noopener">《Redis 设计与实现》</a></li>
</ul>
</li>
<li><strong>教程</strong>
<ul>
<li><a href="http://redisdoc.com/" target="_blank" rel="noopener">Redis 命令参考</a></li>
</ul>
</li>
<li><strong>文章</strong>
<ul>
<li><a href="https://blog.csdn.net/u011957758/article/details/74783347" target="_blank" rel="noopener">一看就懂系列之 详解 redis 的 bitmap 在亿级项目中的应用</a></li>
<li><a href="http://blog.getspool.com/2011/11/29/fast-easy-realtime-metrics-using-redis-bitmaps/" target="_blank" rel="noopener">Fast, easy, realtime metrics using Redis bitmaps</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/2020/06/24/redis-%E6%8C%81%E4%B9%85%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2020/06/24/redis-%E6%8C%81%E4%B9%85%E5%8C%96/" class="post-title-link" itemprop="url">Redis 持久化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-24 10:45:38" itemprop="dateCreated datePublished" datetime="2020-06-24T10:45:38+08:00">2020-06-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-14 16:45:53" itemprop="dateModified" datetime="2022-04-14T16:45:53+08:00">2022-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">KV数据库</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2020/06/24/redis-%E6%8C%81%E4%B9%85%E5%8C%96/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/06/24/redis-持久化/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="redis-持久化"><a class="markdownIt-Anchor" href="#redis-持久化"></a> Redis 持久化</h1>
<blockquote>
<p>Redis 支持持久化，即把数据存储到硬盘中。</p>
<p>Redis 提供了两种持久化方式：</p>
<ul>
<li><strong><code>RDB 快照（snapshot）</code></strong> - 将存在于某一时刻的所有数据都写入到硬盘中。</li>
<li><strong><code>只追加文件（append-only file，AOF）</code></strong> - 它会在执行写命令时，将被执行的写命令复制到硬盘中。</li>
</ul>
<p>这两种持久化方式既可以同时使用，也可以单独使用。</p>
<p>将内存中的数据存储到硬盘的一个主要原因是为了在之后重用数据，或者是为了防止系统故障而将数据备份到一个远程位置。另外，存储在 Redis 里面的数据有可能是经过长时间计算得出的，或者有程序正在使用 Redis 存储的数据进行计算，所以用户会希望自己可以将这些数据存储起来以便之后使用，这样就不必重新计算了。</p>
<p>Redis 提供了两种持久方式：RDB 和 AOF。你可以同时开启两种持久化方式。在这种情况下, 当 redis 重启的时候会优先载入 AOF 文件来恢复原始的数据，因为在通常情况下 AOF 文件保存的数据集要比 RDB 文件保存的数据集要完整。</p>
</blockquote>
<h2 id="一-rdb"><a class="markdownIt-Anchor" href="#一-rdb"></a> 一、RDB</h2>
<h3 id="rdb-简介"><a class="markdownIt-Anchor" href="#rdb-简介"></a> RDB 简介</h3>
<p><strong>RDB 即快照方式，它将某个时间点的所有 Redis 数据保存到一个经过压缩的二进制文件（RDB 文件）中</strong>。</p>
<p>创建 RDB 后，用户可以对 RDB 进行<strong>备份</strong>，可以将 RDB <strong>复制</strong>到其他服务器从而创建具有相同数据的服务器副本，还可以在<strong>重启</strong>服务器时使用。一句话来说：RDB 适合作为 <strong>冷备</strong>。</p>
<p>RDB 既可以手动执行，也可以根据服务器配置选项定期执行。该功能可以将某个时间点的数据库状态保存到一个 RDB 文件中。</p>
<h4 id="rdb-的优点"><a class="markdownIt-Anchor" href="#rdb-的优点"></a> RDB 的优点</h4>
<ul>
<li>RDB 文件非常紧凑，<strong>适合作为冷备</strong>。比如你可以在每个小时报保存一下过去 24 小时内的数据，同时每天保存过去 30 天的数据，这样即使出了问题你也可以根据需求恢复到不同版本的数据集。</li>
<li>快照在保存 RDB 文件时父进程唯一需要做的就是 fork 出一个子进程，接下来的工作全部由子进程来做，父进程不需要再做其他 IO 操作，所以快照持久化方式可以最大化 Redis 的性能。</li>
<li><strong>恢复大数据集时，RDB 比 AOF 更快</strong>。</li>
</ul>
<h4 id="rdb-的缺点"><a class="markdownIt-Anchor" href="#rdb-的缺点"></a> RDB 的缺点</h4>
<ul>
<li><strong>如果系统发生故障，将会丢失最后一次创建快照之后的数据</strong>。如果你希望在 Redis 意外停止工作（例如电源中断）的情况下丢失的数据最少的话，那么 快照不适合你。虽然你可以配置不同的 save 时间点(例如每隔 5 分钟并且对数据集有 100 个写的操作)，是 Redis 要完整的保存整个数据集是一个比较繁重的工作，你通常会每隔 5 分钟或者更久做一次完整的保存，万一在 Redis 意外宕机，你可能会丢失几分钟的数据。</li>
<li><strong>如果数据量很大，保存快照的时间会很长</strong>。快照需要经常 fork 子进程来保存数据集到硬盘上。当数据集比较大的时候，fork 的过程是非常耗时的，可能会导致 Redis 在一些毫秒级内不能响应客户端的请求。如果数据集巨大并且 CPU 性能不是很好的情况下，这种情况会持续 1 秒。AOF 也需要 fork，但是你可以调节重写日志文件的频率来提高数据集的耐久度。</li>
</ul>
<h3 id="rdb-的创建"><a class="markdownIt-Anchor" href="#rdb-的创建"></a> RDB 的创建</h3>
<p>有两个 Redis 命令可以用于生成 RDB 文件：<code>SAVE</code> 和 <code>BGSAVE</code>。</p>
<ul>
<li><a href="https://redis.io/commands/save" target="_blank" rel="noopener"><strong><code>SAVE</code></strong></a> 命令会阻塞 Redis 服务器进程，直到 RDB 创建完成为止，在阻塞期间，服务器不能响应任何命令请求。</li>
<li><a href="https://redis.io/commands/bgsave" target="_blank" rel="noopener"><strong><code>BGSAVE</code></strong></a> 命令会派生出（fork）一个子进程，然后由子进程负责创建 RDB 文件，服务器进程（父进程）继续处理命令请求。</li>
</ul>
<blockquote>
<p>🔔 注意：<code>BGSAVE</code> 命令执行期间，<code>SAVE</code>、<code>BGSAVE</code>、<code>BGREWRITEAOF</code> 三个命令会被拒绝，以免与当前的 <code>BGSAVE</code> 操作产生竞态条件，降低性能。</p>
</blockquote>
<h4 id="自动间隔保存"><a class="markdownIt-Anchor" href="#自动间隔保存"></a> 自动间隔保存</h4>
<p>Redis 允许用户通过设置服务器配置的 <code>save</code> 选项，让服务器每隔一段时间自动执行一次 <code>BGSAVE</code> 命令。</p>
<p>用户可以通过 <code>save</code> 选项设置多个保存条件，但只要其中任意一个条件被满足，服务器就会执行 <code>BGSAVE</code> 命令。</p>
<p>举例来说，<code>redis.conf</code> 中设置了如下配置：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">save <span class="number">900</span> <span class="number">1</span>       -- <span class="number">900</span> 秒内，至少对数据库进行了 <span class="number">1</span> 次修改</span><br><span class="line">save <span class="number">300</span> <span class="number">10</span>      -- <span class="number">300</span> 秒内，至少对数据库进行了 <span class="number">10</span> 次修改</span><br><span class="line">save <span class="number">60</span> <span class="number">10000</span>    -- <span class="number">60</span> 秒内，至少对数据库进行了 <span class="number">10000</span> 次修改</span><br></pre></td></tr></table></figure>
<p>只要满足以上任意条件，Redis 服务就会执行 BGSAVE 命令。</p>
<h3 id="rdb-的载入"><a class="markdownIt-Anchor" href="#rdb-的载入"></a> RDB 的载入</h3>
<p><strong>RDB 文件的载入工作是在服务器启动时自动执行的</strong>，Redis 并没有专门用于载入 RDB 文件的命令。</p>
<p>服务器载入 RDB 文件期间，会一直处于阻塞状态，直到载入完成为止。</p>
<blockquote>
<p>🔔 注意：因为 AOF 通常更新频率比 RDB 高，所以丢失数据相对更少。基于这个原因，Redis 有以下默认行为：</p>
<ul>
<li>只有在关闭 AOF 功能的情况下，才会使用 RDB 还原数据，否则优先使用 AOF 文件来还原数据。</li>
</ul>
</blockquote>
<h3 id="rdb-的文件结构"><a class="markdownIt-Anchor" href="#rdb-的文件结构"></a> RDB 的文件结构</h3>
<p>RDB 文件是一个经过压缩的二进制文件，由多个部分组成。</p>
<p>对于不同类型（STRING、HASH、LIST、SET、SORTED SET）的键值对，RDB 文件会使用不同的方式来保存它们。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/database/redis/redis-rdb-structure.png" alt="img" /></p>
<p>Redis 本身提供了一个 RDB 文件检查工具 redis-check-dump。</p>
<h3 id="rdb-的配置"><a class="markdownIt-Anchor" href="#rdb-的配置"></a> RDB 的配置</h3>
<p>Redis RDB 默认配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">save</span> <span class="number">900</span> <span class="number">1</span></span><br><span class="line"><span class="string">save</span> <span class="number">300</span> <span class="number">10</span></span><br><span class="line"><span class="string">save</span> <span class="number">60</span> <span class="number">10000</span></span><br><span class="line"><span class="string">stop-writes-on-bgsave-error</span> <span class="literal">yes</span></span><br><span class="line"><span class="string">rdbcompression</span> <span class="literal">yes</span></span><br><span class="line"><span class="string">rdbchecksum</span> <span class="literal">yes</span></span><br><span class="line"><span class="string">dbfilename</span> <span class="string">dump.rdb</span></span><br><span class="line"><span class="string">dir</span> <span class="string">./</span></span><br></pre></td></tr></table></figure>
<p>Redis 的配置文件 <code>redis.conf</code> 中与 RDB 有关的选项：</p>
<ul>
<li>
<p><code>save</code> - Redis 会根据 <code>save</code> 选项，让服务器每隔一段时间自动执行一次 <code>BGSAVE</code> 命令。</p>
</li>
<li>
<p><code>stop-writes-on-bgsave-error</code> - 当 BGSAVE 命令出现错误时停止写 RDB 文件</p>
</li>
<li>
<p><code>rdbcompression</code> - RDB 文件开启压缩功能。</p>
</li>
<li>
<p><code>rdbchecksum</code> - 对 RDB 文件进行校验。</p>
</li>
<li>
<p><code>dbfilename</code> - RDB 文件名。</p>
</li>
<li>
<p><code>dir</code> - RDB 文件和 AOF 文件的存储路径。</p>
</li>
</ul>
<h2 id="二-aof"><a class="markdownIt-Anchor" href="#二-aof"></a> 二、AOF</h2>
<h3 id="aof-简介"><a class="markdownIt-Anchor" href="#aof-简介"></a> AOF 简介</h3>
<p><code>AOF(Append Only File)</code> 是以 <strong>文本日志形式</strong> 将 <strong>所有写命令以 Redis 命令请求协议格式追加到 AOF 文件的末尾</strong>，以此来记录数据的变化。<strong>当服务器重启时，会重新载入和执行 AOF 文件中的命令，就可以恢复原始的数据</strong>。AOF 适合作为 <strong>热备</strong>。</p>
<p>AOF 可以通过 <code>appendonly yes</code> 配置选项来开启。</p>
<p>命令请求会先保存到 AOF 缓冲区中，之后再定期写入并同步到 AOF 文件。</p>
<h4 id="aof-的优点"><a class="markdownIt-Anchor" href="#aof-的优点"></a> AOF 的优点</h4>
<ul>
<li><strong>如果系统发生故障，AOF 丢失数据比 RDB 少</strong>。你可以使用不同的 fsync 策略：无 fsync；每秒 fsync；每次写的时候 fsync。使用默认的每秒 fsync 策略，Redis 的性能依然很好(fsync 是由后台线程进行处理的,主线程会尽力处理客户端请求)，一旦出现故障，你最多丢失 1 秒的数据。</li>
<li><strong>AOF 文件可修复</strong> - AOF 文件是一个只进行追加的日志文件，所以不需要写入 seek，即使由于某些原因(磁盘空间已满，写的过程中宕机等等)未执行完整的写入命令，你也也可使用 redis-check-aof 工具修复这些问题。</li>
<li><strong>AOF 文件可压缩</strong>。Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写：重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。整个重写操作是绝对安全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。</li>
<li><strong>AOF 文件可读</strong> - AOF 文件有序地保存了对数据库执行的所有写入操作，这些写入操作以 Redis 命令的格式保存。因此 AOF 文件的内容非常容易被人读懂，对文件进行分析（parse）也很轻松。 导出（export） AOF 文件也非常简单。举个例子，如果你不小心执行了 FLUSHALL 命令，但只要 AOF 文件未被重写，那么只要停止服务器，移除 AOF 文件末尾的 FLUSHALL 命令，并重启 Redis ，就可以将数据集恢复到 FLUSHALL 执行之前的状态。</li>
</ul>
<h4 id="aof-的缺点"><a class="markdownIt-Anchor" href="#aof-的缺点"></a> AOF 的缺点</h4>
<ul>
<li><strong>AOF 文件体积一般比 RDB 大</strong> - 对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。</li>
<li><strong>恢复大数据集时，AOF 比 RDB 慢。</strong> - 根据所使用的 fsync 策略，AOF 的速度可能会慢于快照。在一般情况下，每秒 fsync 的性能依然非常高，而关闭 fsync 可以让 AOF 的速度和快照一样快，即使在高负荷之下也是如此。不过在处理巨大的写入载入时，快照可以提供更有保证的最大延迟时间（latency）。</li>
</ul>
<h3 id="aof-的创建"><a class="markdownIt-Anchor" href="#aof-的创建"></a> AOF 的创建</h3>
<p><strong>Redis 命令请求会先保存到 AOF 缓冲区，再定期写入并同步到 AOF 文件</strong>。</p>
<p>AOF 的实现可以分为命令追加（append）、文件写入、文件同步（sync）三个步骤。</p>
<ul>
<li><strong>命令追加</strong> - 当 Redis 服务器开启 AOF 功能时，服务器在执行完一个写命令后，会以 Redis 命令协议格式将被执行的写命令追加到 AOF 缓冲区的末尾。</li>
<li><strong>文件写入</strong>和<strong>文件同步</strong> - Redis 的服务器进程就是一个事件循环，这个循环中的文件事件负责接收客户端的命令请求，以及向客户端发送命令回复。而时间事件则负责执行定时运行的函数。因为服务器在处理文件事件时可能会执行写命令，这些写命令会被追加到 AOF 缓冲区，服务器每次结束事件循环前，都会根据 <code>appendfsync</code> 选项来判断 AOF 缓冲区内容是否需要写入和同步到 AOF 文件中。</li>
</ul>
<p><code>appendfsync</code> 不同选项决定了不同的持久化行为：</p>
<ul>
<li><strong><code>always</code></strong> - 将缓冲区所有内容写入并同步到 AOF 文件。</li>
<li><strong><code>everysec</code></strong> - 将缓冲区所有内容写入到 AOF 文件，如果上次同步 AOF 文件的时间距离现在超过一秒钟，那么再次对 AOF 文件进行同步，这个同步操作是有一个线程专门负责执行的。</li>
<li><strong><code>no</code></strong> - 将缓冲区所有内容写入到 AOF 文件，但并不对 AOF 文件进行同步，何时同步由操作系统决定。</li>
</ul>
<h3 id="aof-的载入"><a class="markdownIt-Anchor" href="#aof-的载入"></a> AOF 的载入</h3>
<p>因为 AOF 文件中包含了重建数据库所需的所有写命令，所以服务器只要载入并执行一遍 AOF 文件中保存的写命令，就可以还原服务器关闭前的数据库状态。</p>
<p>AOF 载入过程如下：</p>
<ol>
<li>服务器启动载入程序。</li>
<li>创建一个伪客户端。因为 Redis 命令只能在客户端上下文中执行，所以需要创建一个伪客户端来载入、执行 AOF 文件中记录的命令。</li>
<li>从 AOF 文件中分析并读取一条写命令。</li>
<li>使用伪客户端执行写命令。</li>
<li>循环执行步骤 3、4，直到所有写命令都被处理完毕为止。</li>
<li>载入完毕。</li>
</ol>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/database/redis/redis-aof-flow.png" />
</div>
<h3 id="aof-的重写"><a class="markdownIt-Anchor" href="#aof-的重写"></a> AOF 的重写</h3>
<p>随着 Redis 不断运行，AOF 的体积也会不断增长，这将导致两个问题：</p>
<ul>
<li>AOF 耗尽磁盘可用空间。</li>
<li>Redis 重启后需要执行 AOF 文件记录的所有写命令来还原数据集，如果 AOF 过大，则还原操作执行的时间就会非常长。</li>
</ul>
<p>为了解决 AOF 体积膨胀问题，Redis 提供了 AOF 重写功能，来对 AOF 文件进行压缩。<strong>AOF 重写可以产生一个新的 AOF 文件，这个新的 AOF 文件和原来的 AOF 文件所保存的数据库状态一致，但体积更小</strong>。</p>
<p>AOF 重写并非读取和分析现有 AOF 文件的内容，而是直接从数据库中读取当前的数据库状态。即<strong>依次读取数据库中的每个键值对，然后用一条命令去记录该键值对</strong>，以此代替之前可能存在冗余的命令。</p>
<h4 id="aof-后台重写"><a class="markdownIt-Anchor" href="#aof-后台重写"></a> AOF 后台重写</h4>
<p>作为一种辅助性功能，显然 Redis 并不想在 AOF 重写时阻塞 Redis 服务接收其他命令。因此，Redis 决定通过 <code>BGREWRITEAOF</code> 命令创建一个子进程，然后由子进程负责对 AOF 文件进行重写，这与 <code>BGSAVE</code> 原理类似。</p>
<ul>
<li>在执行 <code>BGREWRITEAOF</code> 命令时，Redis 服务器会维护一个 AOF 重写缓冲区。当 AOF 重写子进程开始工作后，Redis 每执行完一个写命令，会同时将这个命令发送给 AOF 缓冲区和 AOF 重写缓冲区。</li>
<li>由于彼此不是在同一个进程中工作，AOF 重写不影响 AOF 写入和同步。当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新旧两个 AOF 文件所保存的数据库状态一致。</li>
<li>最后，服务器用新的 AOF 文件替换就的 AOF 文件，以此来完成 AOF 重写操作。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200130153716.png" alt="img" /></p>
<p>可以通过设置 <code>auto-aof-rewrite-percentage</code> 和 <code>auto-aof-rewrite-min-size</code>，使得 Redis 在满足条件时，自动执行 <code>BGREWRITEAOF</code>。</p>
<p>假设配置如下：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">auto</span>-aof-rewrite-percentage <span class="number">100</span></span><br><span class="line"><span class="built_in">auto</span>-aof-rewrite-min-size <span class="number">64</span>mb</span><br></pre></td></tr></table></figure>
<p>表明，当 AOF 大于 <code>64MB</code>，且 AOF 体积比上一次重写后的体积大了至少 <code>100%</code> 时，执行 <code>BGREWRITEAOF</code>。</p>
<h3 id="aof-的配置"><a class="markdownIt-Anchor" href="#aof-的配置"></a> AOF 的配置</h3>
<p>AOF 的默认配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">appendonly</span> <span class="literal">no</span></span><br><span class="line"><span class="string">appendfsync</span> <span class="string">everysec</span></span><br><span class="line"><span class="literal">no</span><span class="string">-appendfsync-on-rewrite</span> <span class="literal">no</span></span><br><span class="line"><span class="string">auto-aof-rewrite-percentage</span> <span class="number">100</span></span><br><span class="line"><span class="string">auto-aof-rewrite-min-size</span> <span class="string">64mb</span></span><br></pre></td></tr></table></figure>
<p>AOF 持久化通过在 <code>redis.conf</code> 中的 <code>appendonly yes</code> 配置选项来开启。</p>
<ul>
<li><strong><code>appendonly</code></strong> - 开启 AOF 功能。</li>
<li><strong><code>appendfilename</code></strong> - AOF 文件名。</li>
<li><strong><code>appendfsync</code></strong> - 用于设置同步频率，它有以下可选项：
<ul>
<li><strong><code>always</code></strong> - 每个 Redis 写命令都要同步写入硬盘。这样做会严重降低 Redis 的速度。</li>
<li><strong><code>everysec</code></strong> - 每秒执行一次同步，显示地将多个写命令同步到硬盘。为了兼顾数据安全和写入性能，推荐使用 <code>appendfsync everysec</code> 选项。Redis 每秒同步一次 AOF 文件时的性能和不使用任何持久化特性时的性能相差无几。</li>
<li><strong><code>no</code></strong> - 让操作系统来决定应该何时进行同步。</li>
</ul>
</li>
<li><code>no-appendfsync-on-rewrite</code> - AOF 重写时不支持追加命令。</li>
<li><code>auto-aof-rewrite-percentage</code> - AOF 重写百分比。</li>
<li><code>auto-aof-rewrite-min-size</code> - AOF 重写文件的最小大小。</li>
<li><code>dir</code> - RDB 文件和 AOF 文件的存储路径。</li>
</ul>
<h2 id="三-rdb-和-aof"><a class="markdownIt-Anchor" href="#三-rdb-和-aof"></a> 三、RDB 和 AOF</h2>
<blockquote>
<p>当 Redis 启动时， 如果 RDB 和 AOF 功能都开启了，那么程序会优先使用 AOF 文件来恢复数据集，因为 AOF 文件所保存的数据通常是最完整的。</p>
</blockquote>
<h3 id="如何选择持久化"><a class="markdownIt-Anchor" href="#如何选择持久化"></a> 如何选择持久化</h3>
<ul>
<li>如果不关心数据丢失，可以不持久化。</li>
<li>如果可以承受数分钟以内的数据丢失，可以只使用 RDB。</li>
<li>如果不能承受数分钟以内的数据丢失，可以同时使用 RDB 和 AOF。</li>
</ul>
<p>有很多用户都只使用 AOF 持久化， 但并不推荐这种方式： 因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份，并且快照恢复数据集的速度也要比 AOF 恢复的速度要快，除此之外，使用快照还可以避免之前提到的 AOF 程序的 bug 。</p>
<h3 id="rdb-切换为-aof"><a class="markdownIt-Anchor" href="#rdb-切换为-aof"></a> RDB 切换为 AOF</h3>
<p>在 Redis 2.2 或以上版本，可以在不重启的情况下，从 RDB 切换为 AOF ：</p>
<ul>
<li>为最新的 dump.rdb 文件创建一个备份。</li>
<li>将备份放到一个安全的地方。</li>
<li>执行以下两条命令:</li>
<li>redis-cli config set appendonly yes</li>
<li>redis-cli config set save</li>
<li>确保写命令会被正确地追加到 AOF 文件的末尾。</li>
<li>执行的第一条命令开启了 AOF 功能： Redis 会阻塞直到初始 AOF 文件创建完成为止， 之后 Redis 会继续处理命令请求， 并开始将写入命令追加到 AOF 文件末尾。</li>
</ul>
<p>执行的第二条命令用于关闭快照功能。 这一步是可选的， 如果你愿意的话， 也可以同时使用快照和 AOF 这两种持久化功能。</p>
<blockquote>
<p>🔔 重要：别忘了在 <code>redis.conf</code> 中打开 AOF 功能！否则的话，服务器重启之后，之前通过 CONFIG SET 设置的配置就会被遗忘，程序会按原来的配置来启动服务器。</p>
</blockquote>
<h3 id="aof-和-rdb-的相互作用"><a class="markdownIt-Anchor" href="#aof-和-rdb-的相互作用"></a> AOF 和 RDB 的相互作用</h3>
<p><code>BGSAVE</code> 和 <code>BGREWRITEAOF</code> 命令不可以同时执行。这是为了避免两个 Redis 后台进程同时对磁盘进行大量的 I/O 操作。</p>
<p>如果 <code>BGSAVE</code> 正在执行，并且用户显示地调用 <code>BGREWRITEAOF</code> 命令，那么服务器将向用户回复一个 OK 状态，并告知用户，<code>BGREWRITEAOF</code> 已经被预定执行。一旦 <code>BGSAVE</code> 执行完毕， <code>BGREWRITEAOF</code> 就会正式开始。</p>
<h2 id="四-redis-备份"><a class="markdownIt-Anchor" href="#四-redis-备份"></a> 四、Redis 备份</h2>
<p>应该确保 Redis 数据有完整的备份。</p>
<p>备份 Redis 数据建议采用 RDB。</p>
<h3 id="备份过程"><a class="markdownIt-Anchor" href="#备份过程"></a> 备份过程</h3>
<ol>
<li>创建一个定期任务（cron job），每小时将一个 RDB 文件备份到一个文件夹，并且每天将一个 RDB 文件备份到另一个文件夹。</li>
<li>确保快照的备份都带有相应的日期和时间信息，每次执行定期任务脚本时，使用 find 命令来删除过期的快照：比如说，你可以保留最近 48 小时内的每小时快照，还可以保留最近一两个月的每日快照。</li>
<li>至少每天一次，将 RDB 备份到你的数据中心之外，或者至少是备份到你运行 Redis 服务器的物理机器之外。</li>
</ol>
<h3 id="容灾备份"><a class="markdownIt-Anchor" href="#容灾备份"></a> 容灾备份</h3>
<p>Redis 的容灾备份基本上就是对数据进行备份，并将这些备份传送到多个不同的外部数据中心。</p>
<p>容灾备份可以在 Redis 运行并产生快照的主数据中心发生严重的问题时，仍然让数据处于安全状态。</p>
<h2 id="五-要点总结"><a class="markdownIt-Anchor" href="#五-要点总结"></a> 五、要点总结</h2>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200224214047.png" alt="img" /></p>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><strong>官网</strong>
<ul>
<li><a href="https://redis.io/" target="_blank" rel="noopener">Redis 官网</a></li>
<li><a href="https://github.com/antirez/redis" target="_blank" rel="noopener">Redis github</a></li>
<li><a href="http://redis.cn/" target="_blank" rel="noopener">Redis 官方文档中文版</a></li>
</ul>
</li>
<li><strong>书籍</strong>
<ul>
<li><a href="https://item.jd.com/11791607.html" target="_blank" rel="noopener">《Redis 实战》</a></li>
<li><a href="https://item.jd.com/11486101.html" target="_blank" rel="noopener">《Redis 设计与实现》</a></li>
</ul>
</li>
<li><strong>教程</strong>
<ul>
<li><a href="http://redisdoc.com/" target="_blank" rel="noopener">Redis 命令参考</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/2020/06/24/redis-%E5%A4%8D%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2020/06/24/redis-%E5%A4%8D%E5%88%B6/" class="post-title-link" itemprop="url">Redis 复制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-24 10:45:38" itemprop="dateCreated datePublished" datetime="2020-06-24T10:45:38+08:00">2020-06-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-14 16:45:53" itemprop="dateModified" datetime="2022-04-14T16:45:53+08:00">2022-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">KV数据库</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2020/06/24/redis-%E5%A4%8D%E5%88%B6/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/06/24/redis-复制/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="redis-复制"><a class="markdownIt-Anchor" href="#redis-复制"></a> Redis 复制</h1>
<blockquote>
<p>在 Redis 中，<strong>可以通过执行 <code>SLAVEOF</code> 命令或设置 <code>slaveof</code> 选项，让一个服务器去复制（replicate）另一个服务器</strong>，其中，后者叫主服务器（master），前者叫从服务器（slave）。</p>
<p>Redis 2.8 以前的复制不能高效处理断线后重复制的情况，而 Redis 2.8 新添的部分重同步可以解决这个问题。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200712182603.png" alt="img" /></p>
<h2 id="一-复制简介"><a class="markdownIt-Anchor" href="#一-复制简介"></a> 一、复制简介</h2>
<p>Redis 通过 <code>slaveof host port</code> 命令来让一个服务器成为另一个服务器的从服务器。</p>
<p><strong>一个主服务器可以有多个从服务器</strong>。不仅主服务器可以有从服务器，从服务器也可以有自己的从服务器， 多个从服务器之间可以构成一个主从链。</p>
<p><strong>一个从服务器只能有一个主服务器，并且不支持主主复制</strong>。</p>
<p>可以通过复制功能来让主服务器免于执行持久化操作： 只要关闭主服务器的持久化功能， 然后由从服务器去执行持久化操作即可。</p>
<p>在使用 Redis 复制功能时的设置中，强烈建议在 master 和在 slave 中启用持久化。当不启用时，例如由于非常慢的磁盘性能而导致的延迟问题，<strong>应该配置实例来避免重置后自动重启</strong>。</p>
<p>从 Redis 2.6 开始， 从服务器支持只读模式， 并且该模式为从服务器的默认模式。</p>
<ul>
<li>只读模式由 <code>redis.conf</code> 文件中的 <code>slave-read-only</code> 选项控制， 也可以通过 <a href="http://redisdoc.com/configure/config_set.html#config-set" target="_blank" rel="noopener">CONFIG SET parameter value</a> 命令来开启或关闭这个模式。</li>
<li>只读从服务器会拒绝执行任何写命令， 所以不会出现因为操作失误而将数据不小心写入到了从服务器的情况。</li>
</ul>
<h2 id="二-旧版复制"><a class="markdownIt-Anchor" href="#二-旧版复制"></a> 二、旧版复制</h2>
<blockquote>
<p>Redis 2.8 版本以前实现方式：<code>SYNC</code> 命令</p>
</blockquote>
<p>Redis 的复制功能分为同步（sync）和命令传播（command propagate）两个操作：</p>
<ul>
<li><strong><code>同步（sync）</code></strong> - 用于将从服务器的数据库状态更新至主服务器当前的数据库状态。</li>
<li><strong><code>命令传播（command propagate）</code></strong> - 当主服务器的数据库状态被修改，导致主从数据库状态不一致时，让主从服务器的数据库重新回到一致状态。</li>
</ul>
<h3 id="同步"><a class="markdownIt-Anchor" href="#同步"></a> 同步</h3>
<p><code>SYNC</code> 命令的执行步骤：</p>
<ol>
<li>从服务器向主服务器发送 <code>SYNC</code> 命令。</li>
<li>收到 <code>SYNC</code> 命令的主服务器执行 <code>BGSAVE</code> 命令，在后台生成一个 RDB 文件，并使用一个缓冲区记录从现在开始执行的所有写命令。</li>
<li>主服务器执行 <code>BGSAVE</code> 完毕后，主服务器会将生成的 RDB 文件发送给从服务器。从服务器接收并载入 RDB 文件，更新自己的数据库状态。</li>
<li>主服务器将记录在缓冲区中的所有写命令发送给从服务器，从服务器执行这些写命令，更新自己的数据库状态。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200224220353.png" alt="img" /></p>
<h3 id="命令传播"><a class="markdownIt-Anchor" href="#命令传播"></a> 命令传播</h3>
<p>同步操作完成后，主从数据库的数据库状态将达到一致。每当主服务器执行客户端发送的写命令时，主从数据库状态不再一致。需要将写命令发送给从服务器执行，使得二者的数据库状态重新达到一致。</p>
<h3 id="旧版复制的缺陷"><a class="markdownIt-Anchor" href="#旧版复制的缺陷"></a> 旧版复制的缺陷</h3>
<p>从服务器对主服务器的复制存在两种情况：</p>
<ul>
<li><strong>初次复制</strong> - 从服务器以前没有复制过将要复制的主服务器。</li>
<li><strong>断线后重复制</strong> - 处于命令传播阶段的主从服务器因为网络原因而中断了复制，当从服务器通过自动重连重新连上了主服务器后，继续复制主服务器。</li>
</ul>
<p>对于初次复制，旧版复制功能可用很好完成任务；但是<strong>对于断线后重复制，由于每次任然需要生成 RDB 并传输，效率很低</strong>。</p>
<blockquote>
<p>🔔 注意：<strong>SYNC 命令是一个非常耗费资源的操作。</strong></p>
<ul>
<li>主服务器执行 <code>BGSAVE</code> 命令生成 RDB 文件，这个操作会耗费主服务器大量的 CPU、内存和磁盘 I/O 资源。</li>
<li>主服务器传输 RDB 文件给从服务器，这个操作会耗费主从服务器大量的网络资源，并对主服务器响应时延产生影响。</li>
<li>从服务器载入 RDB 文件期间，会阻塞其他命令请求。</li>
</ul>
</blockquote>
<h2 id="三-新版复制"><a class="markdownIt-Anchor" href="#三-新版复制"></a> 三、新版复制</h2>
<blockquote>
<p>Redis 2.8 版本以后的新实现方式：使用 <code>PSYNC</code> 命令替代 <code>SYNC</code> 命令。</p>
</blockquote>
<p><code>PSYNC</code> 命令具有完整重同步和部分重同步两种模式：</p>
<ul>
<li><strong><code>完整重同步（full resychronization）</code></strong> - 用于初次复制。执行步骤与 <code>SYNC</code> 命令基本一致。</li>
<li><strong><code>部分重同步（partial resychronization）</code></strong> - 用于断线后重复制。<strong>如果条件允许，主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器</strong>，从服务器只需接收并执行这些写命令，即可将主从服务器的数据库状态保持一致。</li>
</ul>
<h3 id="部分重同步"><a class="markdownIt-Anchor" href="#部分重同步"></a> 部分重同步</h3>
<p>部分重同步功能实现由三个部分构成：</p>
<ul>
<li>主从服务器的<strong>复制偏移量（replication offset）</strong></li>
<li>主服务器的<strong>复制积压缓冲区（replication backlog）</strong></li>
<li><strong>服务器的运行 ID</strong></li>
</ul>
<h4 id="复制偏移量"><a class="markdownIt-Anchor" href="#复制偏移量"></a> 复制偏移量</h4>
<p>主服务器和从服务器会分别维护一个复制偏移量。</p>
<ul>
<li>如果主从服务器的复制偏移量相同，则说明二者的数据库状态一致；</li>
<li>反之，则说明二者的数据库状态不一致。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/database/redis/redis-replication-offset.png" alt="img" /></p>
<h4 id="复制积压缓冲区"><a class="markdownIt-Anchor" href="#复制积压缓冲区"></a> 复制积压缓冲区</h4>
<p><strong>复制积压缓冲区是主服务器维护的一个固定长度的先进先出（FIFO）队列</strong>，默认大小为 <code>1MB</code>。</p>
<p>复制积压缓冲区会保存一部分最近传播的写命令，并且复制积压缓冲区会为队列中的每个字节记录相应的复制偏移量。</p>
<p>当从服务器断线重连主服务时，从服务器会通过 <code>PSYNC</code> 命令将自己的复制偏移量 offset 发送给主服务器，主服务器会根据这个复制偏移量来决定对从服务器执行何种同步操作。</p>
<ul>
<li>如果 offset 之后的数据仍然在复制积压缓冲区，则主服务器对从服务器执行部分重同步操作。</li>
<li>反之，则主服务器对从服务器执行完整重同步操作。</li>
</ul>
<blockquote>
<p>🔔 注意：<strong>合理调整复制积压缓冲区的大小</strong></p>
<ul>
<li>
<p>Redis 复制积压缓冲区默认大小为 <code>1MB</code>。</p>
</li>
<li>
<p>复制积压缓冲区的最小大小可以根据公式 <code>second * write_size_per_second</code> 估算。</p>
</li>
</ul>
</blockquote>
<h4 id="服务器的运行-id"><a class="markdownIt-Anchor" href="#服务器的运行-id"></a> 服务器的运行 ID</h4>
<ul>
<li>每个 Redis 服务器，都有运行 ID，用于唯一识别身份。</li>
<li>运行 ID 在服务器启动时自动生成，由 40 个随机的十六进制字符组成。例如：132e358005e29741f8d7b0a42d666aace286edda</li>
</ul>
<p>从服务器对主服务器进行初次复制时，主服务器会将自己的运行 ID 传送给从服务器，从服务器会将这个运行 ID 保存下来。</p>
<p>当从服务器断线重连一个主服务器时，从服务器会发送之前保存的运行 ID：</p>
<ul>
<li>如果保存的运行 ID 和当前主服务器的运行 ID 一致，则说明从服务器断线之前连接的就是这个主服务器，主服务器可以继续尝试执行部分重同步操作；</li>
<li>反之，若运行 ID 不一致，则说明从服务器断线之前连接的不是这个主服务器，主服务器将对从服务器执行完整重同步操作。</li>
</ul>
<h3 id="psync-命令"><a class="markdownIt-Anchor" href="#psync-命令"></a> PSYNC 命令</h3>
<p>了解了部分重同步的实现，PSYNC 的实现就很容易理解了，它的基本工作原理大致如下：</p>
<p>当从服务接收到 <code>SLAVEOF</code> 命令时，先判断从服务器以前是否执行过复制操作。</p>
<ul>
<li>如果没有复制过任何主服务器，向要复制的主服务器<strong>发送 <code>PSYNC ? -1</code> 命令，主动请求进行完整重同步</strong>。</li>
<li>反之，向要复制的主服务器发送 <code>PSYNC &lt;runid&gt; &lt;offset&gt;</code> 命令。
<ul>
<li><code>runid</code> 是上一次复制的主服务器的运行 ID。</li>
<li><code>offset</code> 是复制偏移量。</li>
</ul>
</li>
</ul>
<p>接收到 <code>PSYNC &lt;runid&gt; &lt;offset&gt;</code> 命令的主服务会进行分析：</p>
<ul>
<li>假如主从服务器的 <strong>master run id 相同</strong>，并且<strong>指定的偏移量（offset）在内存缓冲区中还有效</strong>，复制就会从上次中断的点开始继续。</li>
<li>如果其中一个条件不满足，就会进行完全重新同步（在 2.8 版本之前就是直接进行完全重新同步）。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/database/redis/redis-psync-workflow.png" alt="img" /></p>
<h2 id="四-心跳检测"><a class="markdownIt-Anchor" href="#四-心跳检测"></a> 四、心跳检测</h2>
<p>在<strong>命令传播</strong>阶段，从服务器默认会以<strong>每秒一次</strong>的频率，向主服务器发送命令：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">REPLCONF ACK <span class="tag">&lt;<span class="name">replication_offset</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>replication_offset</code> 是从服务器当前的复制偏移量。</p>
<p>发送 <code>REPLCONF ACK</code> 命令对于主从服务器有三个作用：</p>
<ul>
<li>检测主从服务器的网络连接状态。</li>
<li>辅助实现 min-slaves 选项。</li>
<li>检测命令丢失。</li>
</ul>
<h3 id="检测主从连接状态"><a class="markdownIt-Anchor" href="#检测主从连接状态"></a> 检测主从连接状态</h3>
<p><strong>可以通过发送和接收 <code>REPLCONF ACK</code> 命令来检查主从服务器之间的网络连接</strong>是否正常：如果主服务器超过一秒没有收到从服务器发来的 <code>REPLCONF ACK</code> 命令，那么主服务器就知道主从服务器之间的连接出现问题了。</p>
<p>可以通过向主服务器发送 <code>INFO replication</code> 命令，在列出的从服务器列表的 lag 一栏中，可以看到从服务器向主服务器发送 <code>REPLCONF ACK</code> 命令已经过去多少秒。</p>
<h3 id="辅助实现-min-slaves-选项"><a class="markdownIt-Anchor" href="#辅助实现-min-slaves-选项"></a> 辅助实现 min-slaves 选项</h3>
<p>Redis 的 <strong><code>min-slaves-to-write</code> 和 <code>min-slaves-max-lag</code> 两个选项可以防止主服务器在不安全的情况下执行写命令</strong>。</p>
<p>【示例】min-slaves 配置项</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="built_in">min</span>-slaves-<span class="built_in">to</span>-<span class="built_in">write</span> <span class="number">3</span></span><br><span class="line"><span class="built_in">min</span>-slaves-<span class="built_in">max</span>-lag <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>以上配置表示：从服务器小于 3 个，或三个从服务器的延迟（lag）都大于等于 10 秒时，主服务器将拒绝执行写命令。</p>
<h3 id="检测命令丢失"><a class="markdownIt-Anchor" href="#检测命令丢失"></a> 检测命令丢失</h3>
<p>如果因为网络故障，主服务传播给从服务器的写命令丢失，那么从服务器定时向主服务器发送 <code>REPLCONF ACK</code> 命令时，主服务器将发觉从服务器的复制偏移量少于自己的。然后，主服务器就会根据从服务器提交的复制偏移量，在复制积压缓冲区中找到从服务器缺少的数据，并将这些数据重新发送给从服务器。</p>
<h2 id="五-复制的流程"><a class="markdownIt-Anchor" href="#五-复制的流程"></a> 五、复制的流程</h2>
<p>通过向从服务器发送如下 SLAVEOF 命令，可以让一个从服务器去复制一个主服务器。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">SLAVEOF <span class="tag">&lt;<span class="name">master_ip</span>&gt;</span> <span class="tag">&lt;<span class="name">master_port</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="步骤-1-设置主从服务器"><a class="markdownIt-Anchor" href="#步骤-1-设置主从服务器"></a> 步骤 1. 设置主从服务器</h3>
<p>配置一个从服务器非常简单， 只要在配置文件中增加以下的这一行就可以了：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">slaveof <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">6379</span></span><br></pre></td></tr></table></figure>
<p>当然， 你需要将代码中的 <code>127.0.0.1</code> 和 <code>6379</code> 替换成你的主服务器的 IP 和端口号。</p>
<p>另外一种方法是调用 <a href="http://redisdoc.com/replication/slaveof.html#slaveof" target="_blank" rel="noopener">SLAVEOF host port</a> 命令， 输入主服务器的 IP 和端口， 然后同步就会开始：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SLAVEOF <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">10086</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<h3 id="步骤-2-主从服务器建立-tcp-连接"><a class="markdownIt-Anchor" href="#步骤-2-主从服务器建立-tcp-连接"></a> 步骤 2. 主从服务器建立 TCP 连接。</h3>
<h3 id="步骤-3-发送-ping-检查通信状态"><a class="markdownIt-Anchor" href="#步骤-3-发送-ping-检查通信状态"></a> 步骤 3. 发送 PING 检查通信状态。</h3>
<h3 id="步骤-4-身份验证"><a class="markdownIt-Anchor" href="#步骤-4-身份验证"></a> 步骤 4. 身份验证。</h3>
<p>如果主服务器没有设置 <code>requirepass</code> ，从服务器没有设置 <code>masterauth</code>，则不进行身份验证；反之，则需要进行身份验证。如果身份验证失败，则放弃执行复制工作。</p>
<p>如果主服务器通过 <code>requirepass</code> 选项设置了密码， 那么为了让从服务器的同步操作可以顺利进行， 我们也必须为从服务器进行相应的身份验证设置。</p>
<p>对于一个正在运行的服务器， 可以使用客户端输入以下命令：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="built_in">config</span> <span class="built_in">set</span> masterauth &lt;password&gt;</span><br></pre></td></tr></table></figure>
<p>要永久地设置这个密码， 那么可以将它加入到配置文件中：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">masterauth <span class="tag">&lt;<span class="name">password</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>另外还有几个选项， 它们和主服务器执行部分重同步时所使用的复制流缓冲区有关， 详细的信息可以参考 Redis 源码中附带的 <code>redis.conf</code> 示例文件。</p>
<h3 id="步骤-5-发送端口信息"><a class="markdownIt-Anchor" href="#步骤-5-发送端口信息"></a> 步骤 5. 发送端口信息。</h3>
<p>从服务器执行 <code>REPLCONF listening-port &lt;port-number&gt;</code> ，向主服务器发送从服务器的监听端口号。</p>
<h3 id="步骤-6-同步"><a class="markdownIt-Anchor" href="#步骤-6-同步"></a> 步骤 6. 同步。</h3>
<p>前文已介绍，此处不赘述。</p>
<h3 id="步骤-7-命令传播"><a class="markdownIt-Anchor" href="#步骤-7-命令传播"></a> 步骤 7. 命令传播。</h3>
<p>在命令传播阶段，从服务器默认会以每秒一次的频率，向主服务发送命令：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">REPLCONF ACK <span class="tag">&lt;<span class="name">replication_coffset</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>命令的作用：</p>
<ul>
<li>检测主从服务器的网络连接状态。</li>
<li>辅助实现 min-slave 选项。</li>
<li>检测命令丢失。</li>
</ul>
<h2 id="六-复制的配置项"><a class="markdownIt-Anchor" href="#六-复制的配置项"></a> 六、复制的配置项</h2>
<p>从 Redis 2.8 开始， 为了保证数据的安全性， 可以通过配置， 让主服务器只在有至少 N 个当前已连接从服务器的情况下， 才执行写命令。</p>
<p>不过， 因为 Redis 使用异步复制， 所以主服务器发送的写数据并不一定会被从服务器接收到， 因此， 数据丢失的可能性仍然是存在的。</p>
<p>以下是这个特性的运作原理：</p>
<ul>
<li>从服务器以每秒一次的频率 PING 主服务器一次， 并报告复制流的处理情况。</li>
<li>主服务器会记录各个从服务器最后一次向它发送 PING 的时间。</li>
<li>用户可以通过配置， 指定网络延迟的最大值 <code>min-slaves-max-lag</code> ， 以及执行写操作所需的至少从服务器数量 <code>min-slaves-to-write</code> 。</li>
</ul>
<p>如果至少有 <code>min-slaves-to-write</code> 个从服务器， 并且这些服务器的延迟值都少于 <code>min-slaves-max-lag</code>秒， 那么主服务器就会执行客户端请求的写操作。</p>
<p>你可以将这个特性看作 CAP 理论中的 C 的条件放宽版本： 尽管不能保证写操作的持久性， 但起码丢失数据的窗口会被严格限制在指定的秒数中。</p>
<p>另一方面， 如果条件达不到 <code>min-slaves-to-write</code> 和 <code>min-slaves-max-lag</code> 所指定的条件， 那么写操作就不会被执行， 主服务器会向请求执行写操作的客户端返回一个错误。</p>
<p>以下是这个特性的两个选项和它们所需的参数：</p>
<ul>
<li><code>min-slaves-to-write &lt;number of slaves&gt;</code></li>
<li><code>min-slaves-max-lag &lt;number of seconds&gt;</code></li>
</ul>
<p>详细的信息可以参考 Redis 源码中附带的 <code>redis.conf</code> 示例文件。</p>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><strong>官网</strong>
<ul>
<li><a href="https://redis.io/" target="_blank" rel="noopener">Redis 官网</a></li>
<li><a href="https://github.com/antirez/redis" target="_blank" rel="noopener">Redis github</a></li>
<li><a href="http://redis.cn/" target="_blank" rel="noopener">Redis 官方文档中文版</a></li>
</ul>
</li>
<li><strong>书籍</strong>
<ul>
<li><a href="https://item.jd.com/11791607.html" target="_blank" rel="noopener">《Redis 实战》</a></li>
<li><a href="https://item.jd.com/11486101.html" target="_blank" rel="noopener">《Redis 设计与实现》</a></li>
</ul>
</li>
<li><strong>教程</strong>
<ul>
<li><a href="http://redisdoc.com/" target="_blank" rel="noopener">Redis 命令参考</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/2020/06/24/redis-%E5%93%A8%E5%85%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2020/06/24/redis-%E5%93%A8%E5%85%B5/" class="post-title-link" itemprop="url">Redis 哨兵</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-24 10:45:38" itemprop="dateCreated datePublished" datetime="2020-06-24T10:45:38+08:00">2020-06-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-14 16:45:53" itemprop="dateModified" datetime="2022-04-14T16:45:53+08:00">2022-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">KV数据库</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2020/06/24/redis-%E5%93%A8%E5%85%B5/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/06/24/redis-哨兵/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="redis-哨兵"><a class="markdownIt-Anchor" href="#redis-哨兵"></a> Redis 哨兵</h1>
<blockquote>
<p>Redis 哨兵（Sentinel）是 Redis 的<strong>高可用性</strong>（Hight Availability）解决方案。</p>
<p>Redis 哨兵是 <a href="https://github.com/dunwu/blog/blob/master/source/_posts/theory/raft.md" target="_blank" rel="noopener">Raft 算法</a> 的具体实现。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200713072747.png" alt="img" /></p>
<h2 id="一-哨兵简介"><a class="markdownIt-Anchor" href="#一-哨兵简介"></a> 一、哨兵简介</h2>
<p>Redis 哨兵（Sentinel）是 Redis 的<strong>高可用性</strong>（Hight Availability）解决方案：由一个或多个 Sentinel 实例组成的 Sentinel 系统可以监视任意多个主服务器，以及这些主服务器的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200131135847.png" alt="img" /></p>
<p>Sentinel 的主要功能如下：</p>
<ul>
<li><strong><code>监控（Monitoring）</code></strong> - Sentinel 不断检查主从服务器是否正常在工作。</li>
<li><strong><code>通知（Notification）</code></strong> - Sentinel 可以通过一个 api 来通知系统管理员或者另外的应用程序，被监控的 Redis 实例有一些问题。</li>
<li><strong><code>自动故障转移（Automatic Failover）</code></strong> - 如果一个主服务器下线，Sentinel 会开始自动故障转移：把一个从节点提升为主节点，并重新配置其他的从节点使用新的主节点，使用 Redis 服务的应用程序在连接的时候也被通知新的地址。</li>
<li><strong><code>配置提供者（Configuration provider）</code></strong> - Sentinel 给客户端的服务发现提供来源：对于一个给定的服务，客户端连接到 Sentinels 来寻找当前主节点的地址。当故障转移发生的时候，Sentinel 将报告新的地址。</li>
</ul>
<h2 id="二-启动哨兵"><a class="markdownIt-Anchor" href="#二-启动哨兵"></a> 二、启动哨兵</h2>
<p>启动一个 Sentinel 可以使用下面任意一条命令，两条命令效果完全相同。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-sentinel /path/to/sentinel.conf</span><br><span class="line">redis-server /path/to/sentinel.conf --sentinel</span><br></pre></td></tr></table></figure>
<p>当一个 Sentinel 启动时，它需要执行以下步骤：</p>
<ol>
<li>初始化服务器。</li>
<li>使用 Sentinel 专用代码。</li>
<li>初始化 Sentinel 状态。</li>
<li>初始化 Sentinel 的主服务器列表。</li>
<li>创建连向被监视的主服务器的网络连接。</li>
</ol>
<p><strong>Sentinel 本质上是一个运行在特殊状模式下的 Redis 服务器</strong>。</p>
<p>Sentinel 模式下 Redis 服务器只支持 <code>PING</code>、<code>SENTINEL</code>、<code>INFO</code>、<code>SUBSCRIBE</code>、<code>UNSUBSCRIBE</code>、<code>PSUBSCRIBE</code>、<code>PUNSUBSCRIBE</code> 七个命令。</p>
<p>创建连向被监视的主服务器的网络连接，Sentinel 将成为主服务器的客户端，它可以向主服务器发送命令，并从命令回复中获取相关的信息。对于每个被 Sentinel 监视的主服务器，Sentinel 会创建两个连向主服务器的异步网络：</p>
<ul>
<li>命令连接：专门用于向主服务器发送命令，并接受命令回复。</li>
<li>订阅连接：专门用于订阅主服务器的 <code>__sentinel__:hello</code> 频道。</li>
</ul>
<h2 id="三-监控"><a class="markdownIt-Anchor" href="#三-监控"></a> 三、监控</h2>
<h3 id="检测服务器状态"><a class="markdownIt-Anchor" href="#检测服务器状态"></a> 检测服务器状态</h3>
<blockquote>
<p><strong>Sentinel 向 Redis 服务器发送 <code>PING</code> 命令，检查其状态</strong>。</p>
</blockquote>
<p>默认情况下，<strong>每个</strong> <code>Sentinel</code> 节点会以 <strong>每秒一次</strong> 的频率对 <code>Redis</code> 节点和 <strong>其它</strong> 的 <code>Sentinel</code> 节点发送 <code>PING</code> 命令，并通过节点的 <strong>回复</strong> 来判断节点是否在线。</p>
<ul>
<li><strong>主观下线</strong>：<strong>主观下线</strong> 适用于所有 <strong>主节点</strong> 和 <strong>从节点</strong>。如果在 <code>down-after-milliseconds</code> 毫秒内，<code>Sentinel</code> 没有收到 <strong>目标节点</strong> 的有效回复，则会判定 <strong>该节点</strong> 为 <strong>主观下线</strong>。</li>
<li><strong>客观下线</strong>：<strong>客观下线</strong> 只适用于 <strong>主节点</strong>。当 <code>Sentinel</code> 将一个主服务器判断为主管下线后，为了确认这个主服务器是否真的下线，会向同样监视这一主服务器的其他 Sentinel 询问，看它们是否也认为主服务器已经下线。当足够数量的 Sentinel 认为主服务器已下线，就判定其为客观下线，并对其执行故障转移操作。
<ul>
<li><code>Sentinel</code> 节点通过 <code>sentinel is-master-down-by-addr</code> 命令，向其它 <code>Sentinel</code> 节点询问对该节点的 <strong>状态判断</strong>。</li>
</ul>
</li>
</ul>
<h3 id="获取服务器信息"><a class="markdownIt-Anchor" href="#获取服务器信息"></a> 获取服务器信息</h3>
<blockquote>
<p><strong>Sentinel 向主服务器发送 <code>INFO</code> 命令，获取主服务器及它的从服务器信息</strong>。</p>
</blockquote>
<ul>
<li><strong>获取主服务器信息</strong> - Sentinel <strong>默认</strong>会以<strong>每十秒一次</strong>的频率，通过命令连接<strong>向被监视的主服务器发送 <code>INFO</code> 命令，并通过分析 <code>INFO</code> 命令的回复来获取主服务器的当前信息</strong>。
<ul>
<li>主服务自身信息：包括 run_id 域记录的服务器运行 ID，以及 role 域记录的服务器角色</li>
<li>主服务的从服务器信息：包括 IP 地址和端口号</li>
</ul>
</li>
<li><strong>获取从服务器信息</strong> - 当 Sentinel 发现主服务器有新的从服务器出现时，Sentinel 除了会为这个新的从服务器创建相应的实例结构之外，Sentinel 还会创建连接到从服务器的命令连接和订阅连接。</li>
</ul>
<h2 id="四-通知"><a class="markdownIt-Anchor" href="#四-通知"></a> 四、通知</h2>
<p>对于每个与 Sentinel 连接的服务器，Sentinel 既会向服务器的 <code>__sentinel__:hello</code> 频道发送消息，也会订阅服务器的 <code>__sentinel__:hello</code> 频道的消息。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200131153842.png" alt="img" /></p>
<h3 id="向服务器发送消息"><a class="markdownIt-Anchor" href="#向服务器发送消息"></a> 向服务器发送消息</h3>
<p>在默认情况下，Sentinel 会以每两秒一次的频率，通过命令向所有被监视的主服务器和从服务器发送以下格式的命令。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">PUBLISH __sentinel__:hello "<span class="tag">&lt;<span class="name">s_ip</span>&gt;</span>,<span class="tag">&lt;<span class="name">s_port</span>&gt;</span>,<span class="tag">&lt;<span class="name">s_runid</span>&gt;</span>,<span class="tag">&lt;<span class="name">s_epoch</span>&gt;</span>,<span class="tag">&lt;<span class="name">m_name</span>&gt;</span>,<span class="tag">&lt;<span class="name">m_ip</span>&gt;</span>,<span class="tag">&lt;<span class="name">m_port</span>&gt;</span>,<span class="tag">&lt;<span class="name">m_epoch</span>&gt;</span>"</span><br></pre></td></tr></table></figure>
<p>这条命令向服务器的 <code>__sentinel__:hello</code> 频道发送一条消息。</p>
<h3 id="接收服务器的消息"><a class="markdownIt-Anchor" href="#接收服务器的消息"></a> 接收服务器的消息</h3>
<p>当 Sentinel 与一个主服务器或从服务器建立起订阅连接后，Sentinel 就会通过订阅连接，向服务器发送以下命令：<code>SUBSCRIBE __sentinel__:hello</code>。</p>
<p>Sentinel 对 <code>__sentinel__:hello</code> 频道的订阅会一直持续到 Sentinel 与服务器断开连接为止。</p>
<h2 id="五-选举-leader"><a class="markdownIt-Anchor" href="#五-选举-leader"></a> 五、选举 Leader</h2>
<blockquote>
<p>Redis Sentinel 系统选举 Leader 的算法是 <a href="https://ramcloud.atlassian.net/wiki/download/attachments/6586375/raft.pdf" target="_blank" rel="noopener">Raft</a> 的实现。</p>
<p>Raft 是一种共识性算法，想了解其原理，可以参考 <a href="https://github.com/dunwu/blog/blob/master/source/_posts/theory/raft.md" target="_blank" rel="noopener">深入剖析共识性算法 Raft</a>。</p>
</blockquote>
<p><strong>当一个主服务器被判断为客观下线时，监视这个下线主服务器的各个 Sentinel 会进行协商，选举出一个领头的 Sentinel，并由领头 Sentinel 对下线主服务器执行故障转移操作</strong>。</p>
<p>所有在线 Sentinel 都有资格被选为 Leader。</p>
<p>每个 <code>Sentinel</code> 节点都需要 <strong>定期执行</strong> 以下任务：</p>
<p>（1）每个 <code>Sentinel</code> 以 <strong>每秒钟</strong> 一次的频率，向它所知的 <strong>主服务器</strong>、<strong>从服务器</strong> 以及其他 <code>Sentinel</code> <strong>实例</strong> 发送一个 <code>PING</code> 命令。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/22/16560ce61df44c4d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" /></p>
<p>（2）如果一个 <strong>实例</strong>（<code>instance</code>）距离 <strong>最后一次</strong> 有效回复 <code>PING</code> 命令的时间超过 <code>down-after-milliseconds</code> 所指定的值，那么这个实例会被 <code>Sentinel</code> 标记为 <strong>主观下线</strong>。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/22/16560ce61dc739de?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" /></p>
<p>（3）如果一个 <strong>主服务器</strong> 被标记为 <strong>主观下线</strong>，那么正在 <strong>监视</strong> 这个 <strong>主服务器</strong> 的所有 <code>Sentinel</code> 节点，要以 <strong>每秒一次</strong> 的频率确认 <strong>主服务器</strong> 的确进入了 <strong>主观下线</strong> 状态。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/22/16560ce647a39535?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" /></p>
<p>（4）如果一个 <strong>主服务器</strong> 被标记为 <strong>主观下线</strong>，并且有 <strong>足够数量</strong> 的 <code>Sentinel</code>（至少要达到 <strong>配置文件</strong> 指定的数量）在指定的 <strong>时间范围</strong> 内同意这一判断，那么这个 <strong>主服务器</strong> 被标记为 <strong>客观下线</strong>。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/22/16560ce647c2583e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" /></p>
<p>（5）在一般情况下， 每个 <code>Sentinel</code> 会以每 <code>10</code> 秒一次的频率，向它已知的所有 <strong>主服务器</strong> 和 <strong>从服务器</strong> 发送 <code>INFO</code> 命令。当一个 <strong>主服务器</strong> 被 <code>Sentinel</code> 标记为 <strong>客观下线</strong> 时，<code>Sentinel</code> 向 <strong>下线主服务器</strong> 的所有 <strong>从服务器</strong> 发送 <code>INFO</code> 命令的频率，会从 <code>10</code> 秒一次改为 <strong>每秒一次</strong>。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/22/16560ce6738a30db?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" /></p>
<p>（6）<code>Sentinel</code> 和其他 <code>Sentinel</code> 协商 <strong>主节点</strong> 的状态，如果 <strong>主节点</strong> 处于 <code>SDOWN</code> 状态，则投票自动选出新的 <strong>主节点</strong>。将剩余的 <strong>从节点</strong> 指向 <strong>新的主节点</strong> 进行 <strong>数据复制</strong>。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/22/16560ce676a95a54?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" /></p>
<p>（7）当没有足够数量的 <code>Sentinel</code> 同意 <strong>主服务器</strong> 下线时， <strong>主服务器</strong> 的 <strong>客观下线状态</strong> 就会被移除。当 <strong>主服务器</strong> 重新向 <code>Sentinel</code> 的 <code>PING</code> 命令返回 <strong>有效回复</strong> 时，<strong>主服务器</strong> 的 <strong>主观下线状态</strong> 就会被移除。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/22/16560ce6759c1cb3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" /></p>
<blockquote>
<p>注意：一个有效的 <code>PING</code> 回复可以是：<code>+PONG</code>、<code>-LOADING</code> 或者 <code>-MASTERDOWN</code>。如果 <strong>服务器</strong> 返回除以上三种回复之外的其他回复，又或者在 <strong>指定时间</strong> 内没有回复 <code>PING</code> 命令， 那么 <code>Sentinel</code> 认为服务器返回的回复 <strong>无效</strong>（<code>non-valid</code>）。</p>
</blockquote>
<h2 id="六-故障转移"><a class="markdownIt-Anchor" href="#六-故障转移"></a> 六、故障转移</h2>
<p>在选举产生出 Sentinel Leader 后，Sentinel Leader 将对已下线的主服务器执行故障转移操作。操作含以下三个步骤：</p>
<p>（一）<strong>选出新的主服务器</strong></p>
<p>故障转移第一步，是 Sentinel Leader 在已下线主服务属下的所有从服务器中，挑选一个状态良好、数据完整的从服务器。然后，向这个从服务器发送 <code>SLAVEOF no one</code> 命令，将其转换为主服务器。</p>
<p>Sentinel Leader 如何选出新的主服务器：</p>
<ul>
<li>删除列表中所有处于下线或断线状态的从服务器。</li>
<li>删除列表中所有最近五秒没有回复过 Sentinel Leader 的 INFO 命令的从服务器。</li>
<li>删除所有与已下线主服务器连接断开超过 <code>down-after-milliseconds</code> * 10 毫秒的从服务器（<code>down-after-milliseconds</code> 指定了判断主服务器下线所需的时间）。</li>
<li>之后， Sentinel Leader 先选出优先级最高的从服务器；如果优先级一样高，再选择复制偏移量最大的从服务器；如果结果还不唯一，则选出运行 ID 最小的从服务器。</li>
</ul>
<p>（二）<strong>修改从服务器的复制目标</strong></p>
<p>选出新的主服务器后，Sentinel Leader 会向所有从服务器发送 <code>SLAVEOF</code> 命令，让它们去复制新的主服务器。</p>
<p>（三）<strong>将旧的主服务器变为从服务器</strong></p>
<p>Sentinel Leader 将旧的主服务器标记为从服务器。当旧的主服务器重新上线，Sentinel 会向它发送 SLAVEOF 命令，让其成为从服务器。</p>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><strong>官网</strong>
<ul>
<li><a href="https://redis.io/" target="_blank" rel="noopener">Redis 官网</a></li>
<li><a href="https://github.com/antirez/redis" target="_blank" rel="noopener">Redis github</a></li>
<li><a href="http://redis.cn/" target="_blank" rel="noopener">Redis 官方文档中文版</a></li>
</ul>
</li>
<li><strong>书籍</strong>
<ul>
<li><a href="https://item.jd.com/11791607.html" target="_blank" rel="noopener">《Redis 实战》</a></li>
<li><a href="https://item.jd.com/11486101.html" target="_blank" rel="noopener">《Redis 设计与实现》</a></li>
</ul>
</li>
<li><strong>教程</strong>
<ul>
<li><a href="http://redisdoc.com/" target="_blank" rel="noopener">Redis 命令参考</a></li>
</ul>
</li>
<li><strong>文章</strong>
<ul>
<li><a href="http://www.web-lovers.com/redis-source-sentinel.html" target="_blank" rel="noopener">渐进式解析 Redis 源码 - 哨兵 sentinel</a></li>
<li><a href="https://juejin.im/post/5b7d226a6fb9a01a1e01ff64" target="_blank" rel="noopener">深入剖析 Redis 系列(二) - Redis 哨兵模式与高可用集群</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/2020/06/24/redis-%E9%9B%86%E7%BE%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2020/06/24/redis-%E9%9B%86%E7%BE%A4/" class="post-title-link" itemprop="url">Redis 集群</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-24 10:45:38" itemprop="dateCreated datePublished" datetime="2020-06-24T10:45:38+08:00">2020-06-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-14 16:45:53" itemprop="dateModified" datetime="2022-04-14T16:45:53+08:00">2022-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">KV数据库</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2020/06/24/redis-%E9%9B%86%E7%BE%A4/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/06/24/redis-集群/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="redis-集群"><a class="markdownIt-Anchor" href="#redis-集群"></a> Redis 集群</h1>
<blockquote>
<p><strong><a href="https://redis.io/topics/cluster-tutorial" target="_blank" rel="noopener">Redis 集群（Redis Cluster）</a> 是 Redis 官方提供的分布式数据库方案</strong>。</p>
<p>既然是分布式，自然具备分布式系统的基本特性：可扩展、高可用、一致性。</p>
<ul>
<li>Redis 集群通过划分 hash 槽来分区，进行数据分享。</li>
<li>Redis 集群采用主从模型，提供复制和故障转移功能，来保证 Redis 集群的高可用。</li>
<li>根据 CAP 理论，Consistency、Availability、Partition tolerance 三者不可兼得，而 Redis 集群的选择是 AP。Redis 集群节点间采用异步通信方式，不保证强一致性，尽力达到最终一致性。</li>
</ul>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200713100613.png" alt="img" /></p>
<h2 id="1-redis-cluster-分区"><a class="markdownIt-Anchor" href="#1-redis-cluster-分区"></a> 1. Redis Cluster 分区</h2>
<h3 id="11-集群节点"><a class="markdownIt-Anchor" href="#11-集群节点"></a> 1.1. 集群节点</h3>
<p>Redis 集群由多个节点组成，节点刚启动时，彼此是相互独立的。<strong>节点通过握手（ <code>CLUSTER MEET</code> 命令）来将其他节点添加到自己所处的集群中</strong>。</p>
<p>向一个节点发送 <code>CLUSTER MEET</code> 命令，可以让当前节点与指定 IP、PORT 的节点进行握手，握手成功时，当前节点会将指定节点加入所在集群。</p>
<p><strong>集群节点保存键值对以及过期时间的方式与单机 Redis 服务完全相同</strong>。</p>
<p>Redis 集群节点分为主节点（master）和从节点（slave），其中主节点用于处理槽，而从节点则用于复制某个主节点，并在被复制的主节点下线时，代替下线主节点继续处理命令请求。</p>
<h3 id="12-分配-hash-槽"><a class="markdownIt-Anchor" href="#12-分配-hash-槽"></a> 1.2. 分配 Hash 槽</h3>
<p>分布式存储需要解决的首要问题是把 <strong>整个数据集</strong> 按照 <strong>分区规则</strong> 映射到 <strong>多个节点</strong> 的问题，即把 <strong>数据集</strong> 划分到 <strong>多个节点</strong> 上，每个节点负责 <strong>整体数据</strong> 的一个 <strong>子集</strong>。</p>
<p><strong>Redis 集群通过划分 hash 槽来将数据分区</strong>。Redis 集群通过分区的方式来保存数据库的键值对：<strong>集群的整个数据库被分为 16384 个哈希槽（slot）</strong>，数据库中的每个键都属于这 16384 个槽的其中一个，集群中的每个节点可以处理 0 个或最多 16384 个槽。<strong>如果数据库中有任何一个槽没有得到处理，那么集群处于下线状态</strong>。</p>
<p>通过向节点发送 <a href="https://redis.io/commands/cluster-addslots" target="_blank" rel="noopener"><code>CLUSTER ADDSLOTS</code></a> 命令，可以将一个或多个槽指派给节点负责。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt; CLUSTER ADDSLOTS <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<p>集群中的每个节点负责一部分哈希槽，比如集群中有３个节点，则：</p>
<ul>
<li>节点Ａ存储的哈希槽范围是：0 – 5500</li>
<li>节点Ｂ存储的哈希槽范围是：5501 – 11000</li>
<li>节点Ｃ存储的哈希槽范围是：11001 – 16384</li>
</ul>
<h3 id="13-寻址"><a class="markdownIt-Anchor" href="#13-寻址"></a> 1.3. 寻址</h3>
<p>当客户端向节点发送与数据库键有关的命令时，接受命令的节点会<strong>计算出命令要处理的数据库属于哪个槽</strong>，并<strong>检查这个槽是否指派给了自己</strong>：</p>
<ul>
<li>如果键所在的槽正好指派给了当前节点，那么当前节点直接执行命令。</li>
<li>如果键所在的槽没有指派给当前节点，那么节点会向客户端返回一个 MOVED 错误，指引客户端重定向至正确的节点。</li>
</ul>
<h4 id="131-计算键属于哪个槽"><a class="markdownIt-Anchor" href="#131-计算键属于哪个槽"></a> 1.3.1. 计算键属于哪个槽</h4>
<p>决定一个 key 应该分配到那个槽的算法是：<strong>计算该 key 的 CRC16 结果再模 16834</strong>。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">HASH_SLOT</span> = CRC16(KEY) mod <span class="number">16384</span></span><br></pre></td></tr></table></figure>
<p>当节点计算出 key 所属的槽为 i 之后，节点会根据以下条件判断槽是否由自己负责：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">clusterState.slots[i]</span> == clusterState.myself</span><br></pre></td></tr></table></figure>
<h4 id="132-moved-错误"><a class="markdownIt-Anchor" href="#132-moved-错误"></a> 1.3.2. MOVED 错误</h4>
<p>当节点发现键所在的槽并非自己负责处理的时候，节点就会向客户端返回一个 <code>MOVED</code> 错误，指引客户端转向正在负责槽的节点。</p>
<p><code>MOVED</code> 错误的格式为：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">MOVED <span class="tag">&lt;<span class="name">slot</span>&gt;</span> <span class="tag">&lt;<span class="name">ip</span>&gt;</span>:<span class="tag">&lt;<span class="name">port</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>个人理解：MOVED 这种操作有点类似 HTTP 协议中的重定向。</p>
</blockquote>
<h3 id="14-重新分区"><a class="markdownIt-Anchor" href="#14-重新分区"></a> 1.4. 重新分区</h3>
<p>Redis 集群的<strong>重新分区操作可以将任意数量的已经指派给某个节点（源节点）的槽改为指派给另一个节点（目标节点），并且相关槽所属的键值对也会从源节点被移动到目标节点</strong>。</p>
<p>重新分区操作<strong>可以在线进</strong>行，在重新分区的过程中，集群不需要下线，并且源节点和目标节点都可以继续处理命令请求。</p>
<p>Redis 集群的重新分区操作由 Redis 集群管理软件 <strong>redis-trib</strong> 负责执行的，redis-trib 通过向源节点和目标节点发送命令来进行重新分区操作。</p>
<p>重新分区的实现原理如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/database/redis/redis-cluster-trib.png" alt="img" /></p>
<h3 id="15-ask-错误"><a class="markdownIt-Anchor" href="#15-ask-错误"></a> 1.5. ASK 错误</h3>
<p><code>ASK</code> 错误与 <code>MOVED</code> 的区别在于：<strong>ASK 错误只是两个节点在迁移槽的过程中使用的一种临时措施</strong>，在客户端收到关于槽 X 的 ASK 错误之后，客户端只会在接下来的一次命令请求中将关于槽 X 的命令请求发送至 ASK 错误所指示的节点，但这种转向不会对客户端今后发送关于槽 X 的命令请求产生任何影响，客户端仍然会将关于槽 X 的命令请求发送至目前负责处理槽 X 的节点，除非 ASK 错误再次出现。</p>
<p>判断 ASK 错误的过程如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/database/redis/redis-ask.png" alt="img" /></p>
<h2 id="2-redis-cluster-故障转移"><a class="markdownIt-Anchor" href="#2-redis-cluster-故障转移"></a> 2. Redis Cluster 故障转移</h2>
<h3 id="21-复制"><a class="markdownIt-Anchor" href="#21-复制"></a> 2.1. 复制</h3>
<p>Redis 复制机制可以参考：<a href="docs/05.KV%E6%95%B0%E6%8D%AE%E5%BA%93/01.Redis/05.Redis%E5%A4%8D%E5%88%B6.md">Redis 复制</a></p>
<h3 id="22-故障检测"><a class="markdownIt-Anchor" href="#22-故障检测"></a> 2.2. 故障检测</h3>
<p><strong>集群中每个节点都会定期向集群中的其他节点发送 PING 消息，以此来检测对方是否在线</strong>。</p>
<p>节点的状态信息可以分为：</p>
<ul>
<li>
<p>在线状态；</p>
</li>
<li>
<p>下线状态（FAIL）;</p>
</li>
<li>
<p>疑似下线状态（PFAIL），即在规定的时间内，没有应答 PING 消息；</p>
</li>
</ul>
<h3 id="23-故障转移"><a class="markdownIt-Anchor" href="#23-故障转移"></a> 2.3. 故障转移</h3>
<ol>
<li>下线主节点的所有从节点中，会有一个从节点被选中。</li>
<li>被选中的从节点会执行 <code>SLAVEOF no one</code> 命令，成为新的主节点。</li>
<li>新的主节点会撤销所有对已下线主节点的槽指派，并将这些槽全部指派给自己。</li>
<li>新的主节点向集群广播一条 PONG 消息，告知其他节点这个从节点已变成主节点。</li>
</ol>
<h3 id="24-选举新的主节点"><a class="markdownIt-Anchor" href="#24-选举新的主节点"></a> 2.4. 选举新的主节点</h3>
<p>Redis 集群选举新的主节点流程基于<a href="https://www.jianshu.com/p/8e4bbe7e276c" target="_blank" rel="noopener">共识算法：Raft</a></p>
<h2 id="3-redis-cluster-通信"><a class="markdownIt-Anchor" href="#3-redis-cluster-通信"></a> 3. Redis Cluster 通信</h2>
<p>集群中的节点通过发送和接收消息来进行通信。</p>
<p>Redis 集群节点发送的消息主要有以下五种：</p>
<ul>
<li><code>MEET</code> - 请求接收方加入发送方所在的集群。</li>
<li><code>PING</code> - 集群中每个节点每隔一段时间（默认为一秒）从已知节点列表中随机选出五个节点，然后对这五个节点中最久没联系的节点发送 PING 消息，以此检测被选中的节点是否在线。</li>
<li><code>PONG</code> - 当接收方收到发送方发来的 MEET 消息或 PING 消息时，会返回一条 PONG 消息作为应答。</li>
<li><code>FAIL</code> - 当一个主节点 A 判断另一个主节点 B 已经进入 FAIL 状态时，节点 A 会向集群广播一条关于节点 B 的 FAIL 消息，所有收到这条消息的节点都会立即将节点 B 标记为已下线。</li>
<li><code>PUBLISH</code> - 当节点收到一个 PUBLISH 命令时，节点会执行这个命令，并向集群广播一条 PUBLISH 消息，所有接受到这条消息的节点都会执行相同的 PUBLISH 命令。</li>
</ul>
<h2 id="4-redis-cluster-应用"><a class="markdownIt-Anchor" href="#4-redis-cluster-应用"></a> 4. Redis Cluster 应用</h2>
<h3 id="41-集群功能限制"><a class="markdownIt-Anchor" href="#41-集群功能限制"></a> 4.1. 集群功能限制</h3>
<p>Redis 集群相对 <strong>单机</strong>，存在一些功能限制，需要 <strong>开发人员</strong> 提前了解，在使用时做好规避。</p>
<ul>
<li>
<p><code>key</code> <strong>批量操作</strong> 支持有限：类似 <code>mset</code>、<code>mget</code> 操作，目前只支持对具有相同 <code>slot</code> 值的 <code>key</code> 执行 <strong>批量操作</strong>。对于 <strong>映射为不同</strong> <code>slot</code> 值的 <code>key</code> 由于执行 <code>mget</code>、<code>mget</code> 等操作可能存在于多个节点上，因此不被支持。</p>
</li>
<li>
<p><code>key</code> <strong>事务操作</strong> 支持有限：只支持 <strong>多</strong> <code>key</code> 在 <strong>同一节点上</strong> 的 <strong>事务操作</strong>，当多个 <code>key</code> 分布在 <strong>不同</strong> 的节点上时 <strong>无法</strong> 使用事务功能。</p>
</li>
<li>
<p><code>key</code> 作为 <strong>数据分区</strong> 的最小粒度，不能将一个 <strong>大的键值</strong> 对象如 <code>hash</code>、<code>list</code> 等映射到 <strong>不同的节点</strong>。</p>
</li>
<li>
<p>不支持 <strong>多数据库空间</strong>：<strong>单机</strong> 下的 Redis 可以支持 <code>16</code> 个数据库（<code>db0 ~ db15</code>），<strong>集群模式</strong> 下只能使用 <strong>一个</strong> 数据库空间，即 <code>db0</code>。</p>
</li>
<li>
<p><strong>复制结构</strong> 只支持一层：<strong>从节点</strong> 只能复制 <strong>主节点</strong>，不支持 <strong>嵌套树状复制</strong> 结构。</p>
</li>
</ul>
<h3 id="42-集群规模限制"><a class="markdownIt-Anchor" href="#42-集群规模限制"></a> 4.2. 集群规模限制</h3>
<p>Redis Cluster 的优点是易于使用。分区、主从复制、弹性扩容这些功能都可以做到自动化，通过简单的部署就可以获得一个大容量、高可靠、高可用的 Redis 集群，并且对于应用来说，近乎于是透明的。</p>
<p>所以，<strong>Redis Cluster 非常适合构建中小规模 Redis 集群</strong>，这里的中小规模指的是，大概几个到几十个节点这样规模的 Redis 集群。</p>
<p>但是 Redis Cluster 不太适合构建超大规模集群，主要原因是，它采用了去中心化的设计。</p>
<p>Redis 的每个节点上，都保存了所有槽和节点的映射关系表，客户端可以访问任意一个节点，再通过重定向命令，找到数据所在的那个节点。那么，这个映射关系表是如何更新的呢？Redis Cluster 采用了一种去中心化的流言 (Gossip) 协议来传播集群配置的变化。</p>
<p>Gossip 协议的优点是去中心化；缺点是传播速度慢，并且是集群规模越大，传播的越慢。</p>
<h3 id="43-集群配置"><a class="markdownIt-Anchor" href="#43-集群配置"></a> 4.3. 集群配置</h3>
<p>我们后面会部署一个 Redis 集群作为例子，在那之前，先介绍一下集群在 redis.conf 中的参数。</p>
<ul>
<li><strong>cluster-enabled</strong> <code>&lt;yes/no&gt;</code> - 如果配置”yes”则开启集群功能，此 redis 实例作为集群的一个节点，否则，它是一个普通的单一的 redis 实例。</li>
<li><strong>cluster-config-file</strong> <code>&lt;filename&gt;</code> - 注意：虽然此配置的名字叫“集群配置文件”，但是此配置文件不能人工编辑，它是集群节点自动维护的文件，主要用于记录集群中有哪些节点、他们的状态以及一些持久化参数等，方便在重启时恢复这些状态。通常是在收到请求之后这个文件就会被更新。</li>
<li><strong>cluster-node-timeout</strong> <code>&lt;milliseconds&gt;</code> - 这是集群中的节点能够失联的最大时间，超过这个时间，该节点就会被认为故障。如果主节点超过这个时间还是不可达，则用它的从节点将启动故障迁移，升级成主节点。注意，任何一个节点在这个时间之内如果还是没有连上大部分的主节点，则此节点将停止接收任何请求。</li>
<li><strong>cluster-slave-validity-factor</strong> <code>&lt;factor&gt;</code> - 如果设置成０，则无论从节点与主节点失联多久，从节点都会尝试升级成主节点。如果设置成正数，则 cluster-node-timeout 乘以 cluster-slave-validity-factor 得到的时间，是从节点与主节点失联后，此从节点数据有效的最长时间，超过这个时间，从节点不会启动故障迁移。假设 cluster-node-timeout=5，cluster-slave-validity-factor=10，则如果从节点跟主节点失联超过 50 秒，此从节点不能成为主节点。注意，如果此参数配置为非 0，将可能出现由于某主节点失联却没有从节点能顶上的情况，从而导致集群不能正常工作，在这种情况下，只有等到原来的主节点重新回归到集群，集群才恢复运作。</li>
<li><strong>cluster-migration-barrier</strong> <code>&lt;count&gt;</code> - 主节点需要的最小从节点数，只有达到这个数，主节点失败时，它从节点才会进行迁移。更详细介绍可以看本教程后面关于副本迁移到部分。</li>
<li><strong>cluster-require-full-coverage</strong> <code>&lt;yes/no&gt;</code> - 在部分 key 所在的节点不可用时，如果此参数设置为”yes”(默认值), 则整个集群停止接受操作；如果此参数设置为”no”，则集群依然为可达节点上的 key 提供读操作。</li>
</ul>
<h2 id="5-其他-redis-集群方案"><a class="markdownIt-Anchor" href="#5-其他-redis-集群方案"></a> 5. 其他 Redis 集群方案</h2>
<p>Redis Cluster 不太适合用于大规模集群，所以，如果要构建超大 Redis 集群，需要选择替代方案。一般有三种方案类型：</p>
<ul>
<li>客户端分区方案</li>
<li>代理分区方案</li>
<li>查询路由方案</li>
</ul>
<h3 id="51-客户端分区方案"><a class="markdownIt-Anchor" href="#51-客户端分区方案"></a> 5.1. 客户端分区方案</h3>
<p><strong>客户端</strong> 就已经决定数据会被 <strong>存储</strong> 到哪个 Redis 节点或者从哪个 Redis 节点 <strong>读取数据</strong>。其主要思想是采用 <strong>哈希算法</strong> 将 Redis 数据的 <code>key</code> 进行散列，通过 <code>hash</code> 函数，特定的 <code>key</code>会 <strong>映射</strong> 到特定的 Redis 节点上。</p>
<p><strong>客户端分区方案</strong> 的代表为 Redis Sharding，Redis Sharding 是 Redis Cluster 出来之前，业界普遍使用的 Redis <strong>多实例集群</strong> 方法。Java 的 Redis 客户端驱动库 <a href="https://github.com/redis/jedis" target="_blank" rel="noopener"><strong>Jedis</strong></a>，支持 Redis Sharding 功能，即 ShardedJedis 以及 <strong>结合缓存池</strong> 的 ShardedJedisPool。</p>
<ul>
<li>
<p><strong>优点</strong>：不使用 <strong>第三方中间件</strong>，<strong>分区逻辑</strong> 可控，<strong>配置</strong> 简单，节点之间无关联，容易 <strong>线性扩展</strong>，灵活性强。</p>
</li>
<li>
<p><strong>缺点</strong>：<strong>客户端</strong> 无法 <strong>动态增删</strong> 服务节点，客户端需要自行维护 <strong>分发逻辑</strong>，客户端之间 <strong>无连接共享</strong>，会造成 <strong>连接浪费</strong>。</p>
</li>
</ul>
<h3 id="52-代理分区方案"><a class="markdownIt-Anchor" href="#52-代理分区方案"></a> 5.2. 代理分区方案</h3>
<p><strong>客户端</strong> 发送请求到一个 <strong>代理组件</strong>，<strong>代理</strong> 解析 <strong>客户端</strong> 的数据，并将请求转发至正确的节点，最后将结果回复给客户端。</p>
<ul>
<li><strong>优点</strong>：简化 <strong>客户端</strong> 的分布式逻辑，<strong>客户端</strong> 透明接入，切换成本低，代理的 <strong>转发</strong> 和 <strong>存储</strong> 分离。</li>
<li><strong>缺点</strong>：多了一层 <strong>代理层</strong>，加重了 <strong>架构部署复杂度</strong> 和 <strong>性能损耗</strong>。</li>
</ul>
<p><strong>代理分区</strong> 主流实现的有方案有 <strong><a href="https://github.com/twitter/twemproxy" target="_blank" rel="noopener">Twemproxy</a></strong> 和 <a href="https://github.com/CodisLabs/codis" target="_blank" rel="noopener"><strong>Codis</strong></a>。</p>
<h4 id="521-twemproxy"><a class="markdownIt-Anchor" href="#521-twemproxy"></a> 5.2.1. Twemproxy</h4>
<p><strong><a href="https://github.com/twitter/twemproxy" target="_blank" rel="noopener">Twemproxy</a></strong> 也叫 <code>nutcraker</code>，是 Twitter 开源的一个 Redis 和 Memcache 的 <strong>中间代理服务器</strong> 程序。</p>
<p><strong><a href="https://github.com/twitter/twemproxy" target="_blank" rel="noopener">Twemproxy</a></strong> 作为 <strong>代理</strong>，可接受来自多个程序的访问，按照 <strong>路由规则</strong>，转发给后台的各个 Redis 服务器，再原路返回。<strong><a href="https://github.com/twitter/twemproxy" target="_blank" rel="noopener">Twemproxy</a></strong> 存在 <strong>单点故障</strong> 问题，需要结合 Lvs 和 Keepalived 做 <strong>高可用方案</strong>。</p>
<ul>
<li><strong>优点</strong>：应用范围广，稳定性较高，中间代理层 <strong>高可用</strong>。</li>
<li><strong>缺点</strong>：无法平滑地 <strong>水平扩容/缩容</strong>，无 <strong>可视化管理界面</strong>，运维不友好，出现故障，不能 <strong>自动转移</strong>。</li>
</ul>
<h4 id="522-codis"><a class="markdownIt-Anchor" href="#522-codis"></a> 5.2.2. Codis</h4>
<p><a href="https://github.com/CodisLabs/codis" target="_blank" rel="noopener"><strong>Codis</strong></a> 是一个 <strong>分布式</strong> Redis 解决方案，对于上层应用来说，连接 Codis-Proxy 和直接连接 <strong>原生的</strong> Redis-Server 没有的区别。<a href="https://github.com/CodisLabs/codis" target="_blank" rel="noopener"><strong>Codis</strong></a> 底层会 <strong>处理请求的转发</strong>，不停机的进行 <strong>数据迁移</strong> 等工作。<a href="https://github.com/CodisLabs/codis" target="_blank" rel="noopener"><strong>Codis</strong></a> 采用了无状态的 <strong>代理层</strong>，对于 <strong>客户端</strong> 来说，一切都是透明的。</p>
<ul>
<li>
<p><strong>优点</strong>：实现了上层 Proxy 和底层 Redis 的 <strong>高可用</strong>，<strong>数据分区</strong> 和 <strong>自动平衡</strong>，提供 <strong>命令行接口</strong> 和 RESTful API，提供 <strong>监控</strong> 和 <strong>管理</strong> 界面，可以动态 <strong>添加</strong> 和 <strong>删除</strong> Redis 节点。</p>
</li>
<li>
<p><strong>缺点</strong>：<strong>部署架构</strong> 和 <strong>配置</strong> 复杂，不支持 <strong>跨机房</strong> 和 <strong>多租户</strong>，不支持 <strong>鉴权管理</strong>。</p>
</li>
</ul>
<h3 id="53-查询路由方案"><a class="markdownIt-Anchor" href="#53-查询路由方案"></a> 5.3. 查询路由方案</h3>
<p><strong>客户端随机地</strong> 请求任意一个 Redis 实例，然后由 Redis 将请求 <strong>转发</strong> 给 <strong>正确</strong> 的 Redis 节点。Redis Cluster 实现了一种 <strong>混合形式</strong> 的 <strong>查询路由</strong>，但并不是 <strong>直接</strong> 将请求从一个 Redis 节点 <strong>转发</strong> 到另一个 Redis 节点，而是在 <strong>客户端</strong> 的帮助下直接 <strong>重定向</strong>（ <code>redirected</code>）到正确的 Redis 节点。</p>
<ul>
<li>
<p><strong>优点</strong>：<strong>去中心化</strong>，数据按照 <strong>槽</strong> 存储分布在多个 Redis 实例上，可以平滑的进行节点 <strong>扩容/缩容</strong>，支持 <strong>高可用</strong> 和 <strong>自动故障转移</strong>，运维成本低。</p>
</li>
<li>
<p><strong>缺点</strong>：重度依赖 Redis-trib 工具，缺乏 <strong>监控管理</strong>，需要依赖 Smart Client (<strong>维护连接</strong>，<strong>缓存路由表</strong>，<code>MultiOp</code> 和 <code>Pipeline</code> 支持)。Failover 节点的 <strong>检测过慢</strong>，不如有 <strong>中心节点</strong> 的集群及时（如 ZooKeeper）。Gossip 消息采用广播方式，集群规模越大，开销越大。无法根据统计区分 <strong>冷热数据</strong>。</p>
</li>
</ul>
<h2 id="6-参考资料"><a class="markdownIt-Anchor" href="#6-参考资料"></a> 6. 参考资料</h2>
<ul>
<li><strong>官网</strong>
<ul>
<li><a href="https://redis.io/" target="_blank" rel="noopener">Redis 官网</a></li>
<li><a href="https://github.com/antirez/redis" target="_blank" rel="noopener">Redis github</a></li>
<li><a href="http://redis.cn/" target="_blank" rel="noopener">Redis 官方文档中文版</a></li>
</ul>
</li>
<li><strong>中间件</strong>
<ul>
<li><a href="https://github.com/twitter/twemproxy" target="_blank" rel="noopener">Twemproxy</a></li>
<li><a href="https://github.com/CodisLabs/codis" target="_blank" rel="noopener">Codis</a></li>
</ul>
</li>
<li><strong>书籍</strong>
<ul>
<li><a href="https://item.jd.com/11791607.html" target="_blank" rel="noopener">《Redis 实战》</a></li>
<li><a href="https://item.jd.com/11486101.html" target="_blank" rel="noopener">《Redis 设计与实现》</a></li>
</ul>
</li>
<li><strong>教程</strong>
<ul>
<li><a href="https://time.geekbang.org/column/intro/100046801" target="_blank" rel="noopener">后端存储实战课</a></li>
</ul>
</li>
<li><strong>文章</strong>
<ul>
<li><a href="http://ifeve.com/redis-cluster-tutorial/" target="_blank" rel="noopener">Redis 集群教程</a></li>
<li><a href="https://www.jianshu.com/p/c869feb5581d" target="_blank" rel="noopener">Redis 集群的原理和搭建</a></li>
<li><a href="https://juejin.im/post/5b8fc5536fb9a05d2d01fb11" target="_blank" rel="noopener">深入剖析 Redis 系列(三) - Redis 集群模式搭建与原理详解</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/2020/06/24/redis-%E5%AE%9E%E6%88%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2020/06/24/redis-%E5%AE%9E%E6%88%98/" class="post-title-link" itemprop="url">Redis 实战</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-24 10:45:38" itemprop="dateCreated datePublished" datetime="2020-06-24T10:45:38+08:00">2020-06-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-14 16:45:53" itemprop="dateModified" datetime="2022-04-14T16:45:53+08:00">2022-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">KV数据库</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2020/06/24/redis-%E5%AE%9E%E6%88%98/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/06/24/redis-实战/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>952</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="redis-实战"><a class="markdownIt-Anchor" href="#redis-实战"></a> Redis 实战</h1>
<h2 id="一-应用场景"><a class="markdownIt-Anchor" href="#一-应用场景"></a> 一、应用场景</h2>
<p>Redis 可以应用于很多场景，这里列举几个经典的应用场景。</p>
<h3 id="缓存"><a class="markdownIt-Anchor" href="#缓存"></a> 缓存</h3>
<p>缓存是 Redis 最常见的应用场景。</p>
<p>Redis 有多种数据类型，以及丰富的操作命令，并且有着高性能、高可用的特性，非常适合用于分布式缓存。</p>
<blockquote>
<p>缓存应用的基本原理，请参考 <a href="https://dunwu.github.io/design/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98.html"><strong>缓存基本原理</strong></a> 第四 ~ 第六节内容。</p>
</blockquote>
<h3 id="bitmap-和-bloomfilter"><a class="markdownIt-Anchor" href="#bitmap-和-bloomfilter"></a> BitMap 和 BloomFilter</h3>
<p>Redis 除了 5 种基本数据类型外，还支持 BitMap 和 BloomFilter（即布隆过滤器，可以通过 Redis Module 支持）。</p>
<p>BitMap 和 BloomFilter 都可以用于解决缓存穿透问题。要点在于：过滤一些不可能存在的数据。</p>
<blockquote>
<p>什么是缓存穿透，可以参考：<a href="https://dunwu.github.io/design/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98.html"><strong>缓存基本原理</strong></a></p>
</blockquote>
<p>小数据量可以用 BitMap，大数据量可以用布隆过滤器。</p>
<h3 id="分布式锁"><a class="markdownIt-Anchor" href="#分布式锁"></a> 分布式锁</h3>
<p>使用 Redis 作为分布式锁，基本要点如下：</p>
<ul>
<li><strong>互斥性</strong> - 使用 <code>setnx</code> 抢占锁。</li>
<li><strong>避免永远不释放锁</strong> - 使用 <code>expire</code> 加一个过期时间，避免一直不释放锁，导致阻塞。</li>
<li><strong>原子性</strong> - setnx 和 expire 必须合并为一个原子指令，避免 setnx 后，机器崩溃，没来得及设置 expire，从而导致锁永不释放。</li>
</ul>
<blockquote>
<p>更多分布式锁的实现方式及细节，请参考：<a href="https://github.com/dunwu/blog/blob/master/source/_posts/theory/distributed-lock.md" target="_blank" rel="noopener">分布式锁基本原理</a></p>
</blockquote>
<h2 id="二-技巧"><a class="markdownIt-Anchor" href="#二-技巧"></a> 二、技巧</h2>
<p>根据 Redis 的特性，在实际应用中，存在一些应用小技巧。</p>
<h3 id="keys-和-scan"><a class="markdownIt-Anchor" href="#keys-和-scan"></a> keys 和 scan</h3>
<p>使用 <code>keys</code> 指令可以扫出指定模式的 key 列表。</p>
<p>如果这个 redis 正在给线上的业务提供服务，那使用 <code>keys</code> 指令会有什么问题？</p>
<p>首先，Redis 是单线程的。<code>keys</code> 指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。</p>
<p>这个时候可以使用 <code>scan</code> 指令，<code>scan</code> 指令可以无阻塞的提取出指定模式的 key 列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用 <code>keys</code> 指令长。</p>
<p>不过，增量式迭代命令也不是没有缺点的： 举个例子， 使用 <code>SMEMBERS</code> 命令可以返回集合键当前包含的所有元素， 但是对于 <code>SCAN</code> 这类增量式迭代命令来说， 因为在对键进行增量式迭代的过程中， 键可能会被修改， 所以增量式迭代命令只能对被返回的元素提供有限的保证 。</p>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><strong>官网</strong>
<ul>
<li><a href="https://redis.io/" target="_blank" rel="noopener">Redis 官网</a></li>
<li><a href="https://github.com/antirez/redis" target="_blank" rel="noopener">Redis github</a></li>
<li><a href="http://redis.cn/" target="_blank" rel="noopener">Redis 官方文档中文版</a></li>
</ul>
</li>
<li><strong>书籍</strong>
<ul>
<li><a href="https://item.jd.com/11791607.html" target="_blank" rel="noopener">《Redis 实战》</a></li>
<li><a href="https://item.jd.com/11486101.html" target="_blank" rel="noopener">《Redis 设计与实现》</a></li>
</ul>
</li>
<li><strong>教程</strong>
<ul>
<li><a href="http://redisdoc.com/" target="_blank" rel="noopener">Redis 命令参考</a></li>
</ul>
</li>
<li><strong>文章</strong>
<ul>
<li><a href="https://juejin.im/post/5db66ed9e51d452a2f15d833" target="_blank" rel="noopener">《我们一起进大厂》系列- Redis 基础</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/2020/06/24/redis-%E8%BF%90%E7%BB%B4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2020/06/24/redis-%E8%BF%90%E7%BB%B4/" class="post-title-link" itemprop="url">Redis 运维</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-24 10:45:38" itemprop="dateCreated datePublished" datetime="2020-06-24T10:45:38+08:00">2020-06-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-14 16:45:53" itemprop="dateModified" datetime="2022-04-14T16:45:53+08:00">2022-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">KV数据库</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2020/06/24/redis-%E8%BF%90%E7%BB%B4/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/06/24/redis-运维/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>17k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>16 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="redis-运维"><a class="markdownIt-Anchor" href="#redis-运维"></a> Redis 运维</h1>
<blockquote>
<p><strong>Redis</strong> 是一个高性能的 key-value 数据库。</p>
<p>SET 操作每秒钟 110000 次；GET 操作每秒钟 81000 次。</p>
</blockquote>
<h2 id="一-redis-安装"><a class="markdownIt-Anchor" href="#一-redis-安装"></a> 一、Redis 安装</h2>
<h3 id="window-下安装"><a class="markdownIt-Anchor" href="#window-下安装"></a> Window 下安装</h3>
<p><strong>下载地址：</strong><a href="https://github.com/MSOpenTech/redis/releases" target="_blank" rel="noopener">https://github.com/MSOpenTech/redis/releases</a>。</p>
<p>Redis 支持 32 位和 64 位。这个需要根据你系统平台的实际情况选择，这里我们下载 <strong>Redis-x64-xxx.zip</strong>压缩包到 C 盘，解压后，将文件夹重新命名为 <strong>redis</strong>。</p>
<p>打开一个 <strong>cmd</strong> 窗口 使用 cd 命令切换目录到 <strong>C:\redis</strong> 运行 <strong>redis-server.exe redis.windows.conf</strong> 。</p>
<p>如果想方便的话，可以把 redis 的路径加到系统的环境变量里，这样就省得再输路径了，后面的那个 redis.windows.conf 可以省略，如果省略，会启用默认的。</p>
<p>这时候另启一个 cmd 窗口，原来的不要关闭，不然就无法访问服务端了。</p>
<p>切换到 redis 目录下运行 <strong>redis-cli.exe -h 127.0.0.1 -p 6379</strong> 。</p>
<h3 id="linux-下安装"><a class="markdownIt-Anchor" href="#linux-下安装"></a> Linux 下安装</h3>
<p><strong>下载地址：</strong> <a href="http://redis.io/download%EF%BC%8C%E4%B8%8B%E8%BD%BD%E6%9C%80%E6%96%B0%E6%96%87%E6%A1%A3%E7%89%88%E6%9C%AC%E3%80%82" target="_blank" rel="noopener">http://redis.io/download，下载最新文档版本。</a></p>
<p>下载、解压、编译 Redis</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://download.redis.io/releases/redis-5.0.4.tar.gz</span><br><span class="line">tar xzf redis-5.0.4.tar.gz</span><br><span class="line">cd redis-5.0.4</span><br><span class="line">make</span><br></pre></td></tr></table></figure>
<p>为了编译 Redis 源码，你需要 gcc-c++和 tcl。如果你的系统是 CentOS，可以直接执行命令：<code>yum install -y gcc-c++ tcl</code> 来安装。</p>
<p>进入到解压后的 <code>src</code> 目录，通过如下命令启动 Redis:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">src/redis-server</span><br></pre></td></tr></table></figure>
<p>您可以使用内置的客户端与 Redis 进行交互:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> src/redis-cli</span></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> <span class="built_in">set</span> foo bar</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> get foo</span></span><br><span class="line">"bar"</span><br></pre></td></tr></table></figure>
<h3 id="ubuntu-下安装"><a class="markdownIt-Anchor" href="#ubuntu-下安装"></a> Ubuntu 下安装</h3>
<p>在 Ubuntu 系统安装 Redis 可以使用以下命令:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install redis-server</span><br></pre></td></tr></table></figure>
<h3 id="开机启动"><a class="markdownIt-Anchor" href="#开机启动"></a> 开机启动</h3>
<ul>
<li>开机启动配置：<code>echo &quot;/usr/local/bin/redis-server /etc/redis.conf&quot; &gt;&gt; /etc/rc.local</code></li>
</ul>
<h3 id="开放防火墙端口"><a class="markdownIt-Anchor" href="#开放防火墙端口"></a> 开放防火墙端口</h3>
<ul>
<li>添加规则：<code>iptables -I INPUT -p tcp -m tcp --dport 6379 -j ACCEPT</code></li>
<li>保存规则：<code>service iptables save</code></li>
<li>重启 iptables：<code>service iptables restart</code></li>
</ul>
<h3 id="redis-安装脚本"><a class="markdownIt-Anchor" href="#redis-安装脚本"></a> Redis 安装脚本</h3>
<blockquote>
<p>CentOS7 环境安装脚本：<a href="https://github.com/dunwu/linux-tutorial/tree/master/codes/linux/soft" target="_blank" rel="noopener">软件运维配置脚本集合</a></p>
</blockquote>
<p><strong>安装说明</strong></p>
<ul>
<li>采用编译方式安装 Redis, 并将其注册为 systemd 服务</li>
<li>安装路径为：<code>/usr/local/redis</code></li>
<li>默认下载安装 <code>5.0.4</code> 版本，端口号为：<code>6379</code>，密码为空</li>
</ul>
<p><strong>使用方法</strong></p>
<ul>
<li>默认安装 - 执行以下任意命令即可：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -o- https://gitee.com/turnon/linux-tutorial/raw/master/codes/linux/soft/redis-install.sh | bash</span><br><span class="line">wget -qO- https://gitee.com/turnon/linux-tutorial/raw/master/codes/linux/soft/redis-install.sh | bash</span><br></pre></td></tr></table></figure>
<ul>
<li>自定义安装 - 下载脚本到本地，并按照以下格式执行：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sh redis-install.sh [version] [port] [password]</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li><code>version</code> - redis 版本号</li>
<li><code>port</code> - redis 服务端口号</li>
<li><code>password</code> - 访问密码</li>
</ul>
<h2 id="二-redis-单机使用和配置"><a class="markdownIt-Anchor" href="#二-redis-单机使用和配置"></a> 二、Redis 单机使用和配置</h2>
<h3 id="启动-redis"><a class="markdownIt-Anchor" href="#启动-redis"></a> 启动 Redis</h3>
<p><strong>启动 redis 服务</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/redis/src</span><br><span class="line">./redis-server</span><br></pre></td></tr></table></figure>
<p><strong>启动 redis 客户端</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/redis/src</span><br><span class="line">./redis-cli</span><br></pre></td></tr></table></figure>
<p><strong>查看 redis 是否启动</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli</span><br></pre></td></tr></table></figure>
<p>以上命令将打开以下终端：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>
<p>127.0.0.1 是本机 IP ，6379 是 redis 服务端口。现在我们输入 PING 命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br></pre></td></tr></table></figure>
<p>以上说明我们已经成功启动了 redis。</p>
<h3 id="redis-常见配置"><a class="markdownIt-Anchor" href="#redis-常见配置"></a> Redis 常见配置</h3>
<blockquote>
<p>Redis 默认的配置文件是根目录下的 <code>redis.conf</code> 文件。</p>
<p>如果需要指定特定文件作为配置文件，需要使用命令： <code>./redis-server -c xxx.conf</code></p>
<p>每次修改配置后，需要重启才能生效。</p>
<p>Redis 官方默认配置：</p>
<ul>
<li>自描述文档 <a href="https://raw.githubusercontent.com/antirez/redis/2.8/redis.conf" target="_blank" rel="noopener">redis.conf for Redis 2.8</a></li>
<li>自描述文档 <a href="https://raw.githubusercontent.com/antirez/redis/2.6/redis.conf" target="_blank" rel="noopener">redis.conf for Redis 2.6</a>.</li>
<li>自描述文档 <a href="https://raw.githubusercontent.com/antirez/redis/2.4/redis.conf" target="_blank" rel="noopener">redis.conf for Redis 2.4</a>.</li>
</ul>
<p>自 Redis2.6 起就可以直接通过命令行传递 Redis 配置参数。这种方法可以用于测试。自 Redis2.6 起就可以直接通过命令行传递 Redis 配置参数。这种方法可以用于测试。</p>
</blockquote>
<h3 id="设为守护进程"><a class="markdownIt-Anchor" href="#设为守护进程"></a> 设为守护进程</h3>
<p>Redis 默认以非守护进程方式启动，而通常我们会将 Redis 设为守护进程启动方式，配置：<code>daemonize yes</code></p>
<h4 id="远程访问"><a class="markdownIt-Anchor" href="#远程访问"></a> 远程访问</h4>
<p>Redis 默认绑定 127.0.0.1，这样就只能本机才能访问，若要 Redis 允许远程访问，需要配置：<code>bind 0.0.0.0</code></p>
<h4 id="设置密码"><a class="markdownIt-Anchor" href="#设置密码"></a> 设置密码</h4>
<p>Redis 默认访问不需要密码，如果需要设置密码，需要如下配置：</p>
<ul>
<li><code>protected-mode yes</code></li>
<li><code>requirepass &lt;密码&gt;</code></li>
</ul>
<h4 id="配置参数表"><a class="markdownIt-Anchor" href="#配置参数表"></a> 配置参数表</h4>
<table>
<thead>
<tr>
<th style="text-align:left">配置项</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>daemonize no</code></td>
<td style="text-align:left">Redis 默认不是以守护进程的方式运行，可以通过该配置项修改，使用 yes 启用守护进程（Windows 不支持守护线程的配置为 no ）</td>
</tr>
<tr>
<td style="text-align:left"><code>pidfile /var/run/redis.pid</code></td>
<td style="text-align:left">当 Redis 以守护进程方式运行时，Redis 默认会把 pid 写入 /var/run/redis.pid 文件，可以通过 pidfile 指定</td>
</tr>
<tr>
<td style="text-align:left"><code>port 6379</code></td>
<td style="text-align:left">指定 Redis 监听端口，默认端口为 6379，作者在自己的一篇博文中解释了为什么选用 6379 作为默认端口，因为 6379 在手机按键上 MERZ 对应的号码，而 MERZ 取自意大利歌女 Alessia Merz 的名字</td>
</tr>
<tr>
<td style="text-align:left"><code>bind 127.0.0.1</code></td>
<td style="text-align:left">绑定的主机地址</td>
</tr>
<tr>
<td style="text-align:left"><code>timeout 300</code></td>
<td style="text-align:left">当客户端闲置多长时间后关闭连接，如果指定为 0，表示关闭该功能</td>
</tr>
<tr>
<td style="text-align:left"><code>loglevel notice</code></td>
<td style="text-align:left">指定日志记录级别，Redis 总共支持四个级别：debug、verbose、notice、warning，默认为 notice</td>
</tr>
<tr>
<td style="text-align:left"><code>logfile stdout</code></td>
<td style="text-align:left">日志记录方式，默认为标准输出，如果配置 Redis 为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给 /dev/null</td>
</tr>
<tr>
<td style="text-align:left"><code>databases 16</code></td>
<td style="text-align:left">设置数据库的数量，默认数据库为 0，可以使用 SELECT 命令在连接上指定数据库 id</td>
</tr>
<tr>
<td style="text-align:left"><code>save &lt;seconds&gt; &lt;changes&gt;</code> Redis 默认配置文件中提供了三个条件：<strong>save 900 1</strong>、<strong>save 300 10</strong>、<strong>save 60 10000</strong> 分别表示 900 秒（15 分钟）内有 1 个更改，300 秒（5 分钟）内有 10 个更改以及 60 秒内有 10000 个更改。</td>
<td style="text-align:left">指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合</td>
</tr>
<tr>
<td style="text-align:left"><code>rdbcompression yes</code></td>
<td style="text-align:left">指定存储至本地数据库时是否压缩数据，默认为 yes，Redis 采用 LZF 压缩，如果为了节省 CPU 时间，可以关闭该选项，但会导致数据库文件变的巨大</td>
</tr>
<tr>
<td style="text-align:left"><code>dbfilename dump.rdb</code></td>
<td style="text-align:left">指定本地数据库文件名，默认值为 dump.rdb</td>
</tr>
<tr>
<td style="text-align:left"><code>dir ./</code></td>
<td style="text-align:left">指定本地数据库存放目录</td>
</tr>
<tr>
<td style="text-align:left"><code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code></td>
<td style="text-align:left">设置当本机为 slav 服务时，设置 master 服务的 IP 地址及端口，在 Redis 启动时，它会自动从 master 进行数据同步</td>
</tr>
<tr>
<td style="text-align:left"><code>masterauth &lt;master-password&gt;</code></td>
<td style="text-align:left">当 master 服务设置了密码保护时，slav 服务连接 master 的密码</td>
</tr>
<tr>
<td style="text-align:left"><code>requirepass foobared</code></td>
<td style="text-align:left">设置 Redis 连接密码，如果配置了连接密码，客户端在连接 Redis 时需要通过 <code>AUTH &lt;password&gt;</code> 命令提供密码，默认关闭</td>
</tr>
<tr>
<td style="text-align:left"><code>maxclients 128</code></td>
<td style="text-align:left">设置同一时间最大客户端连接数，默认无限制，Redis 可以同时打开的客户端连接数为 Redis 进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis 会关闭新的连接并向客户端返回 max number of clients reached 错误信息</td>
</tr>
<tr>
<td style="text-align:left"><code>maxmemory &lt;bytes&gt;</code></td>
<td style="text-align:left">指定 Redis 最大内存限制，Redis 在启动时会把数据加载到内存中，达到最大内存后，Redis 会先尝试清除已到期或即将到期的 Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis 新的 vm 机制，会把 Key 存放内存，Value 会存放在 swap 区</td>
</tr>
<tr>
<td style="text-align:left"><code>appendonly no</code></td>
<td style="text-align:left">指定是否在每次更新操作后进行日志记录，Redis 在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis 本身同步数据文件是按上面 save 条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为 no</td>
</tr>
<tr>
<td style="text-align:left"><code>appendfilename appendonly.aof</code></td>
<td style="text-align:left">指定更新日志文件名，默认为 appendonly.aof</td>
</tr>
<tr>
<td style="text-align:left"><code>appendfsync everysec</code></td>
<td style="text-align:left">指定更新日志条件，共有 3 个可选值：<strong>no</strong>：表示等操作系统进行数据缓存同步到磁盘（快）<strong>always</strong>：表示每次更新操作后手动调用 fsync() 将数据写到磁盘（慢，安全）<strong>everysec</strong>：表示每秒同步一次（折中，默认值）</td>
</tr>
<tr>
<td style="text-align:left"><code>vm-enabled no</code></td>
<td style="text-align:left">指定是否启用虚拟内存机制，默认值为 no，简单的介绍一下，VM 机制将数据分页存放，由 Redis 将访问量较少的页即冷数据 swap 到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析 Redis 的 VM 机制）</td>
</tr>
<tr>
<td style="text-align:left"><code>vm-swap-file /tmp/redis.swap</code></td>
<td style="text-align:left">虚拟内存文件路径，默认值为 /tmp/redis.swap，不可多个 Redis 实例共享</td>
</tr>
<tr>
<td style="text-align:left"><code>vm-max-memory 0</code></td>
<td style="text-align:left">将所有大于 vm-max-memory 的数据存入虚拟内存，无论 vm-max-memory 设置多小，所有索引数据都是内存存储的(Redis 的索引数据 就是 keys)，也就是说，当 vm-max-memory 设置为 0 的时候，其实是所有 value 都存在于磁盘。默认值为 0</td>
</tr>
<tr>
<td style="text-align:left"><code>vm-page-size 32</code></td>
<td style="text-align:left">Redis swap 文件分成了很多的 page，一个对象可以保存在多个 page 上面，但一个 page 上不能被多个对象共享，vm-page-size 是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page 大小最好设置为 32 或者 64bytes；如果存储很大大对象，则可以使用更大的 page，如果不确定，就使用默认值</td>
</tr>
<tr>
<td style="text-align:left"><code>vm-pages 134217728</code></td>
<td style="text-align:left">设置 swap 文件中的 page 数量，由于页表（一种表示页面空闲或使用的 bitmap）是在放在内存中的，，在磁盘上每 8 个 pages 将消耗 1byte 的内存。</td>
</tr>
<tr>
<td style="text-align:left"><code>vm-max-threads 4</code></td>
<td style="text-align:left">设置访问 swap 文件的线程数,最好不要超过机器的核数,如果设置为 0,那么所有对 swap 文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为 4</td>
</tr>
<tr>
<td style="text-align:left"><code>glueoutputbuf yes</code></td>
<td style="text-align:left">设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启</td>
</tr>
<tr>
<td style="text-align:left"><code>hash-max-zipmap-entries 64 hash-max-zipmap-value 512</code></td>
<td style="text-align:left">指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法</td>
</tr>
<tr>
<td style="text-align:left"><code>activerehashing yes</code></td>
<td style="text-align:left">指定是否激活重置哈希，默认为开启（后面在介绍 Redis 的哈希算法时具体介绍）</td>
</tr>
<tr>
<td style="text-align:left"><code>include /path/to/local.conf</code></td>
<td style="text-align:left">指定包含其它的配置文件，可以在同一主机上多个 Redis 实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件</td>
</tr>
</tbody>
</table>
<h3 id="压力测试"><a class="markdownIt-Anchor" href="#压力测试"></a> 压力测试</h3>
<blockquote>
<p>参考官方文档：<a href="https://redis.io/topics/benchmarks" target="_blank" rel="noopener">How fast is Redis?</a></p>
</blockquote>
<p>Redis 自带了一个性能测试工具：<code>redis-benchmark</code></p>
<p><strong>（1）基本测试</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-benchmark -q -n 100000</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-q</code> 表示静默（quiet）执行</li>
<li><code>-n 100000</code> 请求 10 万次</li>
</ul>
<p><strong>（2）测试指定读写指令</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redis-benchmark -t <span class="built_in">set</span>,lpush -n 100000 -q</span></span><br><span class="line">SET: 74239.05 requests per second</span><br><span class="line">LPUSH: 79239.30 requests per second</span><br></pre></td></tr></table></figure>
<p><strong>（3）测试 pipeline 模式下指定读写指令</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-benchmark -n 1000000 -t set,get -P 16 -q</span><br><span class="line">SET: 403063.28 requests per second</span><br><span class="line">GET: 508388.41 requests per second</span><br></pre></td></tr></table></figure>
<h2 id="三-redis-集群使用和配置"><a class="markdownIt-Anchor" href="#三-redis-集群使用和配置"></a> 三、Redis 集群使用和配置</h2>
<p>Redis 3.0 后支持集群模式。</p>
<h3 id="集群规划"><a class="markdownIt-Anchor" href="#集群规划"></a> 集群规划</h3>
<p><code>Redis</code> 集群一般由 <strong>多个节点</strong> 组成，节点数量至少为 <code>6</code> 个，才能保证组成 <strong>完整高可用</strong> 的集群。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/10/10/16db5250b0d1c392?w=1467&amp;h=803&amp;f=png&amp;s=43428" alt="img" /></p>
<p>理想情况当然是所有节点各自在不同的机器上，首先于资源，本人在部署 Redis 集群时，只得到 3 台服务器。所以，我计划每台服务器部署 2 个 Redis 节点。</p>
<p>【示例】最简高可用 Redis 集群规划</p>
<p>机器配置：16G 内存 + 8 核 CPU + 1T 磁盘</p>
<p>Redis 进程分配 10 G 内存。一般线上生产环境，Redis 的内存尽量不要超过 10g，超过 10g 可能会有问题。</p>
<p>集群拓扑：三主三从；三哨兵，每个哨兵监听所有主节点。</p>
<p>估算性能：</p>
<ul>
<li>容量：三主，占用 30 G 内存，所以最大存储容量为 30 G。假设每条数据记录平均 大小为 10 K，则最大能存储 300 万条数据。</li>
<li>吞吐量：单机一般 TPS/QPS 为 五万到八万左右。假设为五万，那么三主三从架构理论上能达到 TPS 15 万，QPS 30 万。</li>
</ul>
<h3 id="部署集群"><a class="markdownIt-Anchor" href="#部署集群"></a> 部署集群</h3>
<blockquote>
<p>Redis 集群节点的安装与单节点服务相同，差异仅在于部署方式。</p>
<p>注意：为了演示方便，本示例将所有 Redis 集群节点都部署在一台机器上，实际生产环境中，基本都会将节点部署在不同机器上。要求更高的，可能还要考虑多机房部署。</p>
</blockquote>
<p>（1）创建节点目录</p>
<p>我个人偏好将软件放在 <code>/opt</code> 目录下，在我的机器中，Redis 都安装在 <code>/usr/local/redis</code> 目录下。所以，下面的命令和配置都假设 Redis 安装目录为 <code>/usr/local/redis</code> 。</p>
<p>确保机器上已经安装了 Redis 后，执行以下命令，创建 Redis 集群节点实例目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /usr/local/redis/conf/7001</span><br><span class="line">sudo mkdir -p /usr/local/redis/conf/7002</span><br><span class="line">sudo mkdir -p /usr/local/redis/conf/7003</span><br><span class="line">sudo mkdir -p /usr/local/redis/conf/7004</span><br><span class="line">sudo mkdir -p /usr/local/redis/conf/7005</span><br><span class="line">sudo mkdir -p /usr/local/redis/conf/7006</span><br></pre></td></tr></table></figure>
<p>（2）配置集群节点</p>
<p>每个实例目录下，新建 <code>redis.conf</code> 配置文件。</p>
<p>实例配置模板以 7001 节点为例（其他节点，完全替换配置中的端口号 7001 即可），如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 端口号</span></span><br><span class="line">port 7001</span><br><span class="line"><span class="meta">#</span><span class="bash"> 绑定的主机端口（0.0.0.0 表示允许远程访问）</span></span><br><span class="line">bind 0.0.0.0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 以守护进程方式启动</span></span><br><span class="line">daemonize yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 开启集群模式</span></span><br><span class="line">cluster-enabled yes</span><br><span class="line"><span class="meta">#</span><span class="bash"> 集群的配置，配置文件首次启动自动生成</span></span><br><span class="line">cluster-config-file /usr/local/redis/conf/7001/7001.conf</span><br><span class="line"><span class="meta">#</span><span class="bash"> 请求超时时间，设置 10 秒</span></span><br><span class="line">cluster-node-timeout 10000</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 开启 AOF 持久化</span></span><br><span class="line">appendonly yes</span><br><span class="line"><span class="meta">#</span><span class="bash"> 数据存放目录</span></span><br><span class="line">dir /usr/local/redis/conf/7001</span><br><span class="line"><span class="meta">#</span><span class="bash"> 进程文件</span></span><br><span class="line">pidfile /usr/local/redis/conf/7001/7001.pid</span><br><span class="line"><span class="meta">#</span><span class="bash"> 日志文件</span></span><br><span class="line">logfile /usr/local/redis/conf/7001/7001.log</span><br></pre></td></tr></table></figure>
<p>（3）批量启动 Redis 节点</p>
<p>Redis 的 utils/create-cluster 目录下自带了一个名为 create-cluster 的脚本工具，可以利用它来新建、启动、停止、重启 Redis 节点。</p>
<p>脚本中有几个关键参数：</p>
<ul>
<li><code>PORT</code>=30000 - 初始端口号</li>
<li><code>TIMEOUT</code>=2000 - 超时时间</li>
<li><code>NODES</code>=6 - 节点数</li>
<li><code>REPLICAS</code>=1 - 备份数</li>
</ul>
<p>脚本中的每个命令项会根据初始端口号，以及设置的节点数，遍历的去执行操作。</p>
<p>由于前面的规划中，节点端口是从 7001 ~ 7006，所以需要将 PORT 变量设为 7000。</p>
<p>脚本中启动每个 Redis 节点是通过指定命令行参数来配置属性。所以，我们需要改一下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PORT=7000</span><br><span class="line">TIMEOUT=2000</span><br><span class="line">NODES=6</span><br><span class="line">ENDPORT=$((PORT+NODES))</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ...</span></span><br><span class="line"></span><br><span class="line">if [ "$1" == "start" ]</span><br><span class="line">then</span><br><span class="line">    while [ $((PORT &lt; ENDPORT)) != "0" ]; do</span><br><span class="line">        PORT=$((PORT+1))</span><br><span class="line">        echo "Starting $PORT"</span><br><span class="line">        /usr/local/redis/src/redis-server /usr/local/redis/conf/$&#123;PORT&#125;/redis.conf</span><br><span class="line">    done</span><br><span class="line">    exit 0</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>好了，在每台服务器上，都执行 <code>./create-cluster start</code> 来启动节点。</p>
<p>然后，通过 ps 命令来确认 Redis 进程是否已经工作：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> root @ dbClusterDev01 <span class="keyword">in</span> /usr/<span class="built_in">local</span>/redis/conf [11:07:55]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ps -ef | grep redis</span></span><br><span class="line">root      4604     1  0 11:07 ?        00:00:00 /opt/redis/src/redis-server 0.0.0.0:7001 [cluster]</span><br><span class="line">root      4609     1  0 11:07 ?        00:00:00 /opt/redis/src/redis-server 0.0.0.0:7002 [cluster]</span><br><span class="line">root      4614     1  0 11:07 ?        00:00:00 /opt/redis/src/redis-server 0.0.0.0:7003 [cluster]</span><br><span class="line">root      4619     1  0 11:07 ?        00:00:00 /opt/redis/src/redis-server 0.0.0.0:7004 [cluster]</span><br><span class="line">root      4624     1  0 11:07 ?        00:00:00 /opt/redis/src/redis-server 0.0.0.0:7005 [cluster]</span><br><span class="line">root      4629     1  0 11:07 ?        00:00:00 /opt/redis/src/redis-server 0.0.0.0:7006 [cluster]</span><br></pre></td></tr></table></figure>
<p>（4）启动集群</p>
<p>通过 <code>redis-cli --cluster create</code> 命令可以自动配置集群，如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./redis-cli --cluster create 127.0.0.1:7001 127.0.0.1:7002 127.0.0.2:7003 127.0.0.2:7004 127.0.0.3:7005 127.0.0.3:7006 --cluster-replicas 1</span><br></pre></td></tr></table></figure>
<p>redis-cluster 会根据设置的节点数和副本数自动分片（分配 Hash 虚拟槽 slot），如果满意，输入 yes ，直接开始分片。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Performing <span class="built_in">hash</span> slots allocation on 6 nodes...</span></span><br><span class="line">Master[0] -&gt; Slots 0 - 5460</span><br><span class="line">Master[1] -&gt; Slots 5461 - 10922</span><br><span class="line">Master[2] -&gt; Slots 10923 - 16383</span><br><span class="line">Adding replica 127.0.0.2:7004 to 127.0.0.1:7001</span><br><span class="line">Adding replica 127.0.0.3:7006 to 127.0.0.2:7003</span><br><span class="line">Adding replica 127.0.0.1:7002 to 127.0.0.3:7005</span><br><span class="line">M: b721235997deb6b9a7a2be690b5b9663db8057c6 127.0.0.1:7001</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">S: bda9b7036df0bbefe601bda4ce45d3787a2e9bd9 127.0.0.1:7002</span><br><span class="line">   replicates 3623fff69b5243ed18c02a2fbb6f53069b0f1505</span><br><span class="line">M: 91523c0391a044da6cc9f53bb965aabe89502187 127.0.0.2:7003</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">S: 9d899cbe49dead7b8c4f769920cdb75714a441ae 127.0.0.2:7004</span><br><span class="line">   replicates b721235997deb6b9a7a2be690b5b9663db8057c6</span><br><span class="line">M: 3623fff69b5243ed18c02a2fbb6f53069b0f1505 127.0.0.3:7005</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">S: a2869dc153ea4977ca790b76483574a5d56cb40e 127.0.0.3:7006</span><br><span class="line">   replicates 91523c0391a044da6cc9f53bb965aabe89502187</span><br><span class="line">Can I set the above configuration? (type 'yes' to accept): yes</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Nodes configuration updated</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Assign a different config epoch to each node</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Sending CLUSTER MEET messages to join the cluster</span></span><br><span class="line">Waiting for the cluster to join</span><br><span class="line">....</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Performing Cluster Check (using node 127.0.0.1:7001)</span></span><br><span class="line">M: b721235997deb6b9a7a2be690b5b9663db8057c6 127.0.0.1:7001</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: a2869dc153ea4977ca790b76483574a5d56cb40e 127.0.0.1:7006</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 91523c0391a044da6cc9f53bb965aabe89502187</span><br><span class="line">M: 91523c0391a044da6cc9f53bb965aabe89502187 127.0.0.1:7003</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: 3623fff69b5243ed18c02a2fbb6f53069b0f1505 127.0.0.1:7005</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 9d899cbe49dead7b8c4f769920cdb75714a441ae 127.0.0.1:7004</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates b721235997deb6b9a7a2be690b5b9663db8057c6</span><br><span class="line">S: bda9b7036df0bbefe601bda4ce45d3787a2e9bd9 127.0.0.1:7002</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 3623fff69b5243ed18c02a2fbb6f53069b0f1505</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Check <span class="keyword">for</span> open slots...</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Check slots coverage...</span></span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure>
<p>（5）日常维护操作</p>
<ul>
<li>关闭集群 - <code>./create-cluster stop</code></li>
<li>检查集群是否健康（指定任意节点即可）：<code>./redis-cli --cluster check &lt;ip:port&gt;</code></li>
<li>尝试修复集群节点：<code>./redis-cli --cluster fix &lt;ip:port&gt;</code></li>
</ul>
<h3 id="部署哨兵"><a class="markdownIt-Anchor" href="#部署哨兵"></a> 部署哨兵</h3>
<p>redis-cluster 实现了 Redis 的分片、复制。</p>
<p>但 redis-cluster 没有解决故障转移问题，一旦任意分片的 Master 节点宕机、网络不通，就会导致 redis-cluster 的集群不能工作。为了解决高可用的问题，Redis 提供了 Redis 哨兵来监控 Redis 节点状态，并且会在 Master 宕机时，发起选举，将这个 Master 的一个 Slave 节点选举为 Master。</p>
<p>（1）创建节点目录</p>
<p>我个人偏好将软件放在 <code>/opt</code> 目录下，在我的机器中，Redis 都安装在 <code>/usr/local/redis</code> 目录下。所以，下面的命令和配置都假设 Redis 安装目录为 <code>/usr/local/redis</code> 。</p>
<p>确保机器上已经安装了 Redis 后，执行以下命令，创建 Redis 集群节点实例目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /usr/local/redis/conf/27001</span><br><span class="line">sudo mkdir -p /usr/local/redis/conf/27002</span><br><span class="line">sudo mkdir -p /usr/local/redis/conf/27003</span><br></pre></td></tr></table></figure>
<p>（2）配置集群节点</p>
<p>每个实例目录下，新建 <code>redis.conf</code> 配置文件。</p>
<p>实例配置模板以 7001 节点为例（其他节点，完全替换配置中的端口号 7001 即可），如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">port 27001</span><br><span class="line">daemonize yes</span><br><span class="line">sentinel monitor redis-master 172.22.6.3 7001 2</span><br><span class="line">sentinel down-after-milliseconds redis-master 5000</span><br><span class="line">sentinel failover-timeout redis-master 900000</span><br><span class="line">sentinel parallel-syncs redis-master 1</span><br><span class="line"><span class="meta">#</span><span class="bash">sentinel auth-pass redis-master 123456</span></span><br><span class="line">logfile /usr/local/redis/conf/27001/27001.log</span><br></pre></td></tr></table></figure>
<p>（3）批量启动哨兵节点</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/opt/</span>redis<span class="regexp">/src/</span>redis-sentinel <span class="regexp">/usr/</span>local<span class="regexp">/redis/</span>conf<span class="regexp">/27001/</span>sentinel.conf</span><br><span class="line"><span class="regexp">/opt/</span>redis<span class="regexp">/src/</span>redis-sentinel <span class="regexp">/usr/</span>local<span class="regexp">/redis/</span>conf<span class="regexp">/27002/</span>sentinel.conf</span><br><span class="line"><span class="regexp">/opt/</span>redis<span class="regexp">/src/</span>redis-sentinel <span class="regexp">/usr/</span>local<span class="regexp">/redis/</span>conf<span class="regexp">/27003/</span>sentinel.conf</span><br></pre></td></tr></table></figure>
<h3 id="扩容"><a class="markdownIt-Anchor" href="#扩容"></a> 扩容</h3>
<p>（1）查看信息</p>
<p>进入任意节点</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">./redis-cli -h <span class="number">172.22</span><span class="number">.6</span><span class="number">.3</span> -p <span class="number">7001</span></span><br></pre></td></tr></table></figure>
<p>cluster info 查看集群节点状态</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">172.22</span><span class="number">.6</span><span class="number">.3</span>:<span class="number">7001</span>&gt; cluster nodes</span><br><span class="line">f158bf70bb2767cac271ce4efcfc14ba0b7ca98b <span class="number">172.22</span><span class="number">.6</span><span class="number">.3</span>:<span class="symbol">7006@</span><span class="number">17006</span> slave e7aa182e756b76ec85b471797db9b66e4b2da725 <span class="number">0</span> <span class="number">1594528179000</span> <span class="number">6</span> connected</span><br><span class="line">f348e67648460c7a800120d69b4977bf2e4524cb <span class="number">172.22</span><span class="number">.6</span><span class="number">.3</span>:<span class="symbol">7001@</span><span class="number">17001</span> myself,master - <span class="number">0</span> <span class="number">1594528179000</span> <span class="number">1</span> connected <span class="number">0</span><span class="number">-5460</span></span><br><span class="line"><span class="number">52601e2</span>d4af0e64b83f4cc6d20e8316d0ac38b99 <span class="number">172.22</span><span class="number">.6</span><span class="number">.3</span>:<span class="symbol">7004@</span><span class="number">17004</span> slave <span class="number">4802f</span>afe897160c46392c6e569d6f5e466cca696 <span class="number">0</span> <span class="number">1594528178000</span> <span class="number">4</span> connected</span><br><span class="line">c6c6a68674ae8aac3c6ec792c8af4dc1228c6c31 <span class="number">172.22</span><span class="number">.6</span><span class="number">.3</span>:<span class="symbol">7005@</span><span class="number">17005</span> slave f348e67648460c7a800120d69b4977bf2e4524cb <span class="number">0</span> <span class="number">1594528179852</span> <span class="number">5</span> connected</span><br><span class="line">e7aa182e756b76ec85b471797db9b66e4b2da725 <span class="number">172.22</span><span class="number">.6</span><span class="number">.3</span>:<span class="symbol">7002@</span><span class="number">17002</span> master - <span class="number">0</span> <span class="number">1594528178000</span> <span class="number">2</span> connected <span class="number">5461</span><span class="number">-10922</span></span><br><span class="line"><span class="number">4802f</span>afe897160c46392c6e569d6f5e466cca696 <span class="number">172.22</span><span class="number">.6</span><span class="number">.3</span>:<span class="symbol">7003@</span><span class="number">17003</span> master - <span class="number">0</span> <span class="number">1594528178000</span> <span class="number">3</span> connected <span class="number">10923</span><span class="number">-16383</span></span><br></pre></td></tr></table></figure>
<p>cluster info 查看集群信息</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">172<span class="selector-class">.22</span><span class="selector-class">.6</span><span class="selector-class">.3</span><span class="selector-pseudo">:7001</span>&gt; <span class="selector-tag">cluster</span> <span class="selector-tag">info</span></span><br><span class="line"><span class="selector-tag">cluster_state</span><span class="selector-pseudo">:ok</span></span><br><span class="line"><span class="selector-tag">cluster_slots_assigned</span><span class="selector-pseudo">:16384</span></span><br><span class="line"><span class="selector-tag">cluster_slots_ok</span><span class="selector-pseudo">:16384</span></span><br><span class="line"><span class="selector-tag">cluster_slots_pfail</span><span class="selector-pseudo">:0</span></span><br><span class="line"><span class="selector-tag">cluster_slots_fail</span><span class="selector-pseudo">:0</span></span><br><span class="line"><span class="selector-tag">cluster_known_nodes</span><span class="selector-pseudo">:6</span></span><br><span class="line"><span class="selector-tag">cluster_size</span><span class="selector-pseudo">:3</span></span><br><span class="line"><span class="selector-tag">cluster_current_epoch</span><span class="selector-pseudo">:6</span></span><br><span class="line"><span class="selector-tag">cluster_my_epoch</span><span class="selector-pseudo">:1</span></span><br><span class="line"><span class="selector-tag">cluster_stats_messages_ping_sent</span><span class="selector-pseudo">:3406</span></span><br><span class="line"><span class="selector-tag">cluster_stats_messages_pong_sent</span><span class="selector-pseudo">:3569</span></span><br><span class="line"><span class="selector-tag">cluster_stats_messages_publish_sent</span><span class="selector-pseudo">:5035</span></span><br><span class="line"><span class="selector-tag">cluster_stats_messages_sent</span><span class="selector-pseudo">:12010</span></span><br><span class="line"><span class="selector-tag">cluster_stats_messages_ping_received</span><span class="selector-pseudo">:3564</span></span><br><span class="line"><span class="selector-tag">cluster_stats_messages_pong_received</span><span class="selector-pseudo">:3406</span></span><br><span class="line"><span class="selector-tag">cluster_stats_messages_meet_received</span><span class="selector-pseudo">:5</span></span><br><span class="line"><span class="selector-tag">cluster_stats_messages_publish_received</span><span class="selector-pseudo">:5033</span></span><br><span class="line"><span class="selector-tag">cluster_stats_messages_received</span><span class="selector-pseudo">:12008</span></span><br></pre></td></tr></table></figure>
<p>（2）添加节点到集群</p>
<p>将已启动的节点实例添加到集群中</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster<span class="built_in"> add-node </span>127.0.0.1:7007 127.0.0.1:7008</span><br></pre></td></tr></table></figure>
<p><strong>添加主节点</strong></p>
<p>添加一组主节点</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line"><span class="keyword">.</span>/redis-cli --cluster<span class="built_in"> add-node </span>172.22.6.3:7007 172.22.6.3:7001</span><br><span class="line"><span class="keyword">.</span>/redis-cli --cluster<span class="built_in"> add-node </span>172.22.6.3:7008 172.22.6.3:7001</span><br><span class="line"><span class="keyword">.</span>/redis-cli --cluster<span class="built_in"> add-node </span>172.22.6.3:7009 172.22.6.3:7001</span><br></pre></td></tr></table></figure>
<p>查看节点状态</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">172.22</span><span class="number">.6</span><span class="number">.3</span>:<span class="number">7001</span>&gt; cluster nodes</span><br><span class="line">f158bf70bb2767cac271ce4efcfc14ba0b7ca98b <span class="number">172.22</span><span class="number">.6</span><span class="number">.3</span>:<span class="symbol">7006@</span><span class="number">17006</span> slave e7aa182e756b76ec85b471797db9b66e4b2da725 <span class="number">0</span> <span class="number">1594529342575</span> <span class="number">6</span> connected</span><br><span class="line">f348e67648460c7a800120d69b4977bf2e4524cb <span class="number">172.22</span><span class="number">.6</span><span class="number">.3</span>:<span class="symbol">7001@</span><span class="number">17001</span> myself,master - <span class="number">0</span> <span class="number">1594529340000</span> <span class="number">1</span> connected <span class="number">0</span><span class="number">-5460</span></span><br><span class="line"><span class="number">55</span>cacf121662833a4a19dbeb4a5df712cfedf77f <span class="number">172.22</span><span class="number">.6</span><span class="number">.3</span>:<span class="symbol">7009@</span><span class="number">17009</span> master - <span class="number">0</span> <span class="number">1594529342000</span> <span class="number">0</span> connected</span><br><span class="line">c6c6a68674ae8aac3c6ec792c8af4dc1228c6c31 <span class="number">172.22</span><span class="number">.6</span><span class="number">.3</span>:<span class="symbol">7005@</span><span class="number">17005</span> slave f348e67648460c7a800120d69b4977bf2e4524cb <span class="number">0</span> <span class="number">1594529341573</span> <span class="number">5</span> connected</span><br><span class="line"><span class="number">4802f</span>afe897160c46392c6e569d6f5e466cca696 <span class="number">172.22</span><span class="number">.6</span><span class="number">.3</span>:<span class="symbol">7003@</span><span class="number">17003</span> master - <span class="number">0</span> <span class="number">1594529343577</span> <span class="number">3</span> connected <span class="number">10923</span><span class="number">-16383</span></span><br><span class="line">e7aa182e756b76ec85b471797db9b66e4b2da725 <span class="number">172.22</span><span class="number">.6</span><span class="number">.3</span>:<span class="symbol">7002@</span><span class="number">17002</span> master - <span class="number">0</span> <span class="number">1594529342000</span> <span class="number">2</span> connected <span class="number">5461</span><span class="number">-10922</span></span><br><span class="line">e5ba78fe629115977a74fbbe1478caf8868d6d55 <span class="number">172.22</span><span class="number">.6</span><span class="number">.3</span>:<span class="symbol">7007@</span><span class="number">17007</span> master - <span class="number">0</span> <span class="number">1594529341000</span> <span class="number">0</span> connected</span><br><span class="line"><span class="number">52601e2</span>d4af0e64b83f4cc6d20e8316d0ac38b99 <span class="number">172.22</span><span class="number">.6</span><span class="number">.3</span>:<span class="symbol">7004@</span><span class="number">17004</span> slave <span class="number">4802f</span>afe897160c46392c6e569d6f5e466cca696 <span class="number">0</span> <span class="number">1594529340000</span> <span class="number">4</span> connected</span><br><span class="line"><span class="number">79</span>d4fffc2cec210556c3b4c44e63ab506e87eda3 <span class="number">172.22</span><span class="number">.6</span><span class="number">.3</span>:<span class="symbol">7008@</span><span class="number">17008</span> master - <span class="number">0</span> <span class="number">1594529340000</span> <span class="number">7</span> connected</span><br></pre></td></tr></table></figure>
<p>可以发现，新加入的三个主节点，还没有分配哈希槽，所以，暂时还无法访问。</p>
<p><strong>添加从节点</strong></p>
<p>–slave：设置该参数，则新节点以 slave 的角色加入集群<br />
–master-id：这个参数需要设置了–slave 才能生效，–master-id 用来指定新节点的 master 节点。如果不设置该参数，则会随机为节点选择 master 节点。</p>
<p>语法</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster<span class="built_in"> add-node </span> 新节点IP地址：端口    存在节点IP：端口 --cluster-slave （从节点） --cluster-master-id （master节点的ID）</span><br><span class="line">redis-cli --cluster<span class="built_in"> add-node </span>  10.42.141.119:6379  10.42.166.105:6379  --cluster-slave   --cluster-master-id  dfa238fff8a7a49230cff7eb74f573f5645c8ec5</span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line"><span class="keyword">.</span>/redis-cli --cluster<span class="built_in"> add-node </span>172.22.6.3:7010 172.22.6.3:7007 --cluster-slave</span><br><span class="line"><span class="keyword">.</span>/redis-cli --cluster<span class="built_in"> add-node </span>172.22.6.3:7011 172.22.6.3:7008 --cluster-slave</span><br><span class="line"><span class="keyword">.</span>/redis-cli --cluster<span class="built_in"> add-node </span>172.22.6.3:7012 172.22.6.3:7009 --cluster-slave</span><br></pre></td></tr></table></figure>
<p>查看状态</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">172.22</span><span class="number">.6</span><span class="number">.3</span>:<span class="number">7001</span>&gt; cluster nodes</span><br><span class="line">ef5c1b9ce4cc795dc12b2c1e8736a572647b4c3e <span class="number">172.22</span><span class="number">.6</span><span class="number">.3</span>:<span class="symbol">7011@</span><span class="number">17011</span> slave <span class="number">79</span>d4fffc2cec210556c3b4c44e63ab506e87eda3 <span class="number">0</span> <span class="number">1594529492043</span> <span class="number">7</span> connected</span><br><span class="line">f158bf70bb2767cac271ce4efcfc14ba0b7ca98b <span class="number">172.22</span><span class="number">.6</span><span class="number">.3</span>:<span class="symbol">7006@</span><span class="number">17006</span> slave e7aa182e756b76ec85b471797db9b66e4b2da725 <span class="number">0</span> <span class="number">1594529491943</span> <span class="number">6</span> connected</span><br><span class="line">f348e67648460c7a800120d69b4977bf2e4524cb <span class="number">172.22</span><span class="number">.6</span><span class="number">.3</span>:<span class="symbol">7001@</span><span class="number">17001</span> myself,master - <span class="number">0</span> <span class="number">1594529488000</span> <span class="number">1</span> connected <span class="number">0</span><span class="number">-5460</span></span><br><span class="line"><span class="number">5140</span>d1129ed850df59c51cf818c4eb74545d9959 <span class="number">172.22</span><span class="number">.6</span><span class="number">.3</span>:<span class="symbol">7010@</span><span class="number">17010</span> slave e5ba78fe629115977a74fbbe1478caf8868d6d55 <span class="number">0</span> <span class="number">1594529488000</span> <span class="number">0</span> connected</span><br><span class="line"><span class="number">55</span>cacf121662833a4a19dbeb4a5df712cfedf77f <span class="number">172.22</span><span class="number">.6</span><span class="number">.3</span>:<span class="symbol">7009@</span><span class="number">17009</span> master - <span class="number">0</span> <span class="number">1594529488000</span> <span class="number">8</span> connected</span><br><span class="line">c6c6a68674ae8aac3c6ec792c8af4dc1228c6c31 <span class="number">172.22</span><span class="number">.6</span><span class="number">.3</span>:<span class="symbol">7005@</span><span class="number">17005</span> slave f348e67648460c7a800120d69b4977bf2e4524cb <span class="number">0</span> <span class="number">1594529490000</span> <span class="number">5</span> connected</span><br><span class="line"><span class="number">4802f</span>afe897160c46392c6e569d6f5e466cca696 <span class="number">172.22</span><span class="number">.6</span><span class="number">.3</span>:<span class="symbol">7003@</span><span class="number">17003</span> master - <span class="number">0</span> <span class="number">1594529489939</span> <span class="number">3</span> connected <span class="number">10923</span><span class="number">-16383</span></span><br><span class="line">e7aa182e756b76ec85b471797db9b66e4b2da725 <span class="number">172.22</span><span class="number">.6</span><span class="number">.3</span>:<span class="symbol">7002@</span><span class="number">17002</span> master - <span class="number">0</span> <span class="number">1594529491000</span> <span class="number">2</span> connected <span class="number">5461</span><span class="number">-10922</span></span><br><span class="line">e5ba78fe629115977a74fbbe1478caf8868d6d55 <span class="number">172.22</span><span class="number">.6</span><span class="number">.3</span>:<span class="symbol">7007@</span><span class="number">17007</span> master - <span class="number">0</span> <span class="number">1594529490942</span> <span class="number">0</span> connected</span><br><span class="line"><span class="number">52601e2</span>d4af0e64b83f4cc6d20e8316d0ac38b99 <span class="number">172.22</span><span class="number">.6</span><span class="number">.3</span>:<span class="symbol">7004@</span><span class="number">17004</span> slave <span class="number">4802f</span>afe897160c46392c6e569d6f5e466cca696 <span class="number">0</span> <span class="number">1594529491000</span> <span class="number">4</span> connected</span><br><span class="line"><span class="number">02e9f</span>57b5b45c350dc57acf1c8efa8db136db7b7 <span class="number">172.22</span><span class="number">.6</span><span class="number">.3</span>:<span class="symbol">7012@</span><span class="number">17012</span> master - <span class="number">0</span> <span class="number">1594529489000</span> <span class="number">0</span> connected</span><br><span class="line"><span class="number">79</span>d4fffc2cec210556c3b4c44e63ab506e87eda3 <span class="number">172.22</span><span class="number">.6</span><span class="number">.3</span>:<span class="symbol">7008@</span><span class="number">17008</span> master - <span class="number">0</span> <span class="number">1594529489000</span> <span class="number">7</span> connected</span><br></pre></td></tr></table></figure>
<p>分配哈希槽</p>
<p>执行 <code>./redis-cli --cluster rebalance 172.22.6.3:7001 --cluster-threshold 1 --cluster-use-empty-masters</code></p>
<p>参数说明：</p>
<p>rebalance：表明让 Redis 自动根据节点数进行均衡哈希槽分配。</p>
<p>–cluster-use-empty-masters：表明</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200712125827.png" alt="img" /></p>
<p>执行结束后，查看状态：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200712130234.png" alt="img" /></p>
<h2 id="四-redis-命令"><a class="markdownIt-Anchor" href="#四-redis-命令"></a> 四、Redis 命令</h2>
<h3 id="通用命令"><a class="markdownIt-Anchor" href="#通用命令"></a> 通用命令</h3>
<blockquote>
<p>命令详细用法，请参考 <a href="https://redis.io/commands" target="_blank" rel="noopener"><strong>Redis 命令官方文档</strong></a></p>
<p>搬迁两张 cheat sheet 图，原址：<a href="https://www.cheatography.com/tasjaevan/cheat-sheets/redis/" target="_blank" rel="noopener">https://www.cheatography.com/tasjaevan/cheat-sheets/redis/</a></p>
</blockquote>
<p><img src="https://user-gold-cdn.xitu.io/2019/10/10/16db5250b0b8ea57?w=2230&amp;h=2914&amp;f=png&amp;s=246433" alt="img" /></p>
<p><img src="https://user-gold-cdn.xitu.io/2019/10/10/16db5250b0e9ba3c?w=2229&amp;h=2890&amp;f=png&amp;s=192997" alt="img" /></p>
<h3 id="集群命令"><a class="markdownIt-Anchor" href="#集群命令"></a> 集群命令</h3>
<ul>
<li><strong>集群</strong>
<ul>
<li><code>cluster info</code> - 打印集群的信息</li>
<li><code>cluster nodes</code> - 列出集群当前已知的所有节点（ node），以及这些节点的相关信息。</li>
</ul>
</li>
<li><strong>节点</strong>
<ul>
<li><code>cluster meet &lt;ip&gt; &lt;port&gt;</code> - 将 ip 和 port 所指定的节点添加到集群当中，让它成为集群的一份子。</li>
<li><code>cluster forget &lt;node_id&gt;</code> - 从集群中移除 node_id 指定的节点。</li>
<li><code>cluster replicate &lt;node_id&gt;</code> - 将当前节点设置为 node_id 指定的节点的从节点。</li>
<li><code>cluster saveconfig</code> - 将节点的配置文件保存到硬盘里面。</li>
</ul>
</li>
<li><strong>槽(slot)</strong>
<ul>
<li><code>cluster addslots &lt;slot&gt; [slot ...]</code> - 将一个或多个槽（ slot）指派（ assign）给当前节点。</li>
<li><code>cluster delslots &lt;slot&gt; [slot ...]</code> - 移除一个或多个槽对当前节点的指派。</li>
<li><code>cluster flushslots</code> - 移除指派给当前节点的所有槽，让当前节点变成一个没有指派任何槽的节点。</li>
<li><code>cluster setslot &lt;slot&gt; node &lt;node_id&gt;</code> - 将槽 slot 指派给 node_id 指定的节点，如果槽已经指派给另一个节点，那么先让另一个节点删除该槽&gt;，然后再进行指派。</li>
<li><code>cluster setslot &lt;slot&gt; migrating &lt;node_id&gt;</code> - 将本节点的槽 slot 迁移到 node_id 指定的节点中。</li>
<li><code>cluster setslot &lt;slot&gt; importing &lt;node_id&gt;</code> - 从 node_id 指定的节点中导入槽 slot 到本节点。</li>
<li><code>cluster setslot &lt;slot&gt; stable</code> - 取消对槽 slot 的导入（ import）或者迁移（ migrate）。</li>
</ul>
</li>
<li><strong>键</strong>
<ul>
<li><code>cluster keyslot &lt;key&gt;</code> - 计算键 key 应该被放置在哪个槽上。</li>
<li><code>cluster countkeysinslot &lt;slot&gt;</code> - 返回槽 slot 目前包含的键值对数量。</li>
<li><code>cluster getkeysinslot &lt;slot&gt; &lt;count&gt;</code> - 返回 count 个 slot 槽中的键。</li>
</ul>
</li>
</ul>
<h4 id="重新分片"><a class="markdownIt-Anchor" href="#重新分片"></a> 重新分片</h4>
<p>添加节点：./redis-cli --cluster add-node 192.168.1.136:7007 192.168.1.136:7001 --cluster-slave</p>
<p>redis-cli --cluster reshard 172.22.6.3 7001</p>
<h2 id="五-客户端"><a class="markdownIt-Anchor" href="#五-客户端"></a> 五、客户端</h2>
<p>推荐使用 <a href="https://github.com/uglide/RedisDesktopManager" target="_blank" rel="noopener"><strong>RedisDesktopManager</strong></a></p>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><strong>官网</strong>
<ul>
<li><a href="https://redis.io/" target="_blank" rel="noopener">Redis 官网</a></li>
<li><a href="https://github.com/antirez/redis" target="_blank" rel="noopener">Redis github</a></li>
<li><a href="http://redis.cn/" target="_blank" rel="noopener">Redis 官方文档中文版</a></li>
</ul>
</li>
<li><strong>书籍</strong>
<ul>
<li><a href="https://item.jd.com/11791607.html" target="_blank" rel="noopener">《Redis 实战》</a></li>
<li><a href="https://item.jd.com/11486101.html" target="_blank" rel="noopener">《Redis 设计与实现》</a></li>
</ul>
</li>
<li><strong>教程</strong>
<ul>
<li><a href="http://redisdoc.com/" target="_blank" rel="noopener">Redis 命令参考</a></li>
</ul>
</li>
<li><strong>文章</strong>
<ul>
<li><a href="https://juejin.im/post/5b8fc5536fb9a05d2d01fb11" target="_blank" rel="noopener">深入剖析 Redis 系列(三) - Redis 集群模式搭建与原理详解</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/2020/06/16/elasticsearch-%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2020/06/16/elasticsearch-%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">Elasticsearch 面试总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-16 07:10:44" itemprop="dateCreated datePublished" datetime="2020-06-16T07:10:44+08:00">2020-06-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-14 16:45:53" itemprop="dateModified" datetime="2022-04-14T16:45:53+08:00">2022-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">搜索引擎数据库</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E5%BA%93/Elasticsearch/" itemprop="url" rel="index">
                    <span itemprop="name">Elasticsearch</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2020/06/16/elasticsearch-%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/06/16/elasticsearch-面试总结/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>17k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>16 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="elasticsearch-面试总结"><a class="markdownIt-Anchor" href="#elasticsearch-面试总结"></a> Elasticsearch 面试总结</h1>
<h2 id="集群部署"><a class="markdownIt-Anchor" href="#集群部署"></a> 集群部署</h2>
<p>ES 部署情况：</p>
<p>5 节点（配置：8 核 64 G 1T），总计 320 G，5 T。</p>
<p>约 10+ 索引，5 分片，每日新增数据量约为 2G，4000w 条。记录保存 30 天。</p>
<h2 id="性能优化"><a class="markdownIt-Anchor" href="#性能优化"></a> 性能优化</h2>
<h3 id="filesystem-cache"><a class="markdownIt-Anchor" href="#filesystem-cache"></a> filesystem cache</h3>
<p>你往 es 里写的数据，实际上都写到磁盘文件里去了，<strong>查询的时候</strong>，操作系统会将磁盘文件里的数据自动缓存到 <code>filesystem cache</code> 里面去。</p>
<p><a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/images/es-search-process.png" target="_blank" rel="noopener"><img src="https://github.com/doocs/advanced-java/raw/main/docs/high-concurrency/images/es-search-process.png" alt="es-search-process" /></a></p>
<p>es 的搜索引擎严重依赖于底层的 <code>filesystem cache</code> ，你如果给 <code>filesystem cache</code> 更多的内存，尽量让内存可以容纳所有的 <code>idx segment file</code>索引数据文件，那么你搜索的时候就基本都是走内存的，性能会非常高。</p>
<p>性能差距究竟可以有多大？我们之前很多的测试和压测，如果走磁盘一般肯定上秒，搜索性能绝对是秒级别的，1 秒、5 秒、10 秒。但如果是走 <code>filesystem cache</code> ，是走纯内存的，那么一般来说性能比走磁盘要高一个数量级，基本上就是毫秒级的，从几毫秒到几百毫秒不等。</p>
<p>这里有个真实的案例。某个公司 es 节点有 3 台机器，每台机器看起来内存很多，64G，总内存就是 <code>64 * 3 = 192G</code> 。每台机器给 es jvm heap 是 <code>32G</code> ，那么剩下来留给 <code>filesystem cache</code> 的就是每台机器才 <code>32G</code> ，总共集群里给 <code>filesystem cache</code> 的就是 <code>32 * 3 = 96G</code> 内存。而此时，整个磁盘上索引数据文件，在 3 台机器上一共占用了 <code>1T</code> 的磁盘容量，es 数据量是 <code>1T</code> ，那么每台机器的数据量是 <code>300G</code> 。这样性能好吗？ <code>filesystem cache</code> 的内存才 100G，十分之一的数据可以放内存，其他的都在磁盘，然后你执行搜索操作，大部分操作都是走磁盘，性能肯定差。</p>
<p>归根结底，你要让 es 性能要好，最佳的情况下，就是你的机器的内存，至少可以容纳你的总数据量的一半。</p>
<p>根据我们自己的生产环境实践经验，最佳的情况下，是仅仅在 es 中就存少量的数据，就是你要<strong>用来搜索的那些索引</strong>，如果内存留给 <code>filesystem cache</code> 的是 100G，那么你就将索引数据控制在 <code>100G</code> 以内，这样的话，你的数据几乎全部走内存来搜索，性能非常之高，一般可以在 1 秒以内。</p>
<p>比如说你现在有一行数据。 <code>id,name,age ....</code> 30 个字段。但是你现在搜索，只需要根据 <code>id,name,age</code> 三个字段来搜索。如果你傻乎乎往 es 里写入一行数据所有的字段，就会导致说 <code>90%</code> 的数据是不用来搜索的，结果硬是占据了 es 机器上的 <code>filesystem cache</code> 的空间，单条数据的数据量越大，就会导致 <code>filesystem cahce</code> 能缓存的数据就越少。其实，仅仅写入 es 中要用来检索的<strong>少数几个字段</strong>就可以了，比如说就写入 es <code>id,name,age</code> 三个字段，然后你可以把其他的字段数据存在 mysql/hbase 里，我们一般是建议用 <code>es + hbase</code> 这么一个架构。</p>
<p>hbase 的特点是<strong>适用于海量数据的在线存储</strong>，就是对 hbase 可以写入海量数据，但是不要做复杂的搜索，做很简单的一些根据 id 或者范围进行查询的这么一个操作就可以了。从 es 中根据 name 和 age 去搜索，拿到的结果可能就 20 个 <code>doc id</code> ，然后根据 <code>doc id</code> 到 hbase 里去查询每个 <code>doc id</code> 对应的<strong>完整的数据</strong>，给查出来，再返回给前端。</p>
<p>写入 es 的数据最好小于等于，或者是略微大于 es 的 filesystem cache 的内存容量。然后你从 es 检索可能就花费 20ms，然后再根据 es 返回的 id 去 hbase 里查询，查 20 条数据，可能也就耗费个 30ms，可能你原来那么玩儿，1T 数据都放 es，会每次查询都是 5~10s，现在可能性能就会很高，每次查询就是 50ms。</p>
<h3 id="数据预热"><a class="markdownIt-Anchor" href="#数据预热"></a> 数据预热</h3>
<p>假如说，哪怕是你就按照上述的方案去做了，es 集群中每个机器写入的数据量还是超过了 <code>filesystem cache</code> 一倍，比如说你写入一台机器 60G 数据，结果 <code>filesystem cache</code> 就 30G，还是有 30G 数据留在了磁盘上。</p>
<p>其实可以做<strong>数据预热</strong>。</p>
<p>举个例子，拿微博来说，你可以把一些大 V，平时看的人很多的数据，你自己提前后台搞个系统，每隔一会儿，自己的后台系统去搜索一下热数据，刷到 <code>filesystem cache</code> 里去，后面用户实际上来看这个热数据的时候，他们就是直接从内存里搜索了，很快。</p>
<p>或者是电商，你可以将平时查看最多的一些商品，比如说 iphone 8，热数据提前后台搞个程序，每隔 1 分钟自己主动访问一次，刷到 <code>filesystem cache</code> 里去。</p>
<p>对于那些你觉得比较热的、经常会有人访问的数据，最好<strong>做一个专门的缓存预热子系统</strong>，就是对热数据每隔一段时间，就提前访问一下，让数据进入 <code>filesystem cache</code> 里面去。这样下次别人访问的时候，性能一定会好很多。</p>
<h3 id="冷热分离"><a class="markdownIt-Anchor" href="#冷热分离"></a> 冷热分离</h3>
<p>es 可以做类似于 mysql 的水平拆分，就是说将大量的访问很少、频率很低的数据，单独写一个索引，然后将访问很频繁的热数据单独写一个索引。最好是将<strong>冷数据写入一个索引中，然后热数据写入另外一个索引中</strong>，这样可以确保热数据在被预热之后，尽量都让他们留在 <code>filesystem os cache</code> 里，<strong>别让冷数据给冲刷掉</strong>。</p>
<p>你看，假设你有 6 台机器，2 个索引，一个放冷数据，一个放热数据，每个索引 3 个 shard。3 台机器放热数据 index，另外 3 台机器放冷数据 index。然后这样的话，你大量的时间是在访问热数据 index，热数据可能就占总数据量的 10%，此时数据量很少，几乎全都保留在 <code>filesystem cache</code> 里面了，就可以确保热数据的访问性能是很高的。但是对于冷数据而言，是在别的 index 里的，跟热数据 index 不在相同的机器上，大家互相之间都没什么联系了。如果有人访问冷数据，可能大量数据是在磁盘上的，此时性能差点，就 10% 的人去访问冷数据，90% 的人在访问热数据，也无所谓了。</p>
<h3 id="document-模型设计"><a class="markdownIt-Anchor" href="#document-模型设计"></a> document 模型设计</h3>
<p>对于 MySQL，我们经常有一些复杂的关联查询。在 es 里该怎么玩儿，es 里面的复杂的关联查询尽量别用，一旦用了性能一般都不太好。</p>
<p>最好是先在 Java 系统里就完成关联，将关联好的数据直接写入 es 中。搜索的时候，就不需要利用 es 的搜索语法来完成 join 之类的关联搜索了。</p>
<p>document 模型设计是非常重要的，很多操作，不要在搜索的时候才想去执行各种复杂的乱七八糟的操作。es 能支持的操作就那么多，不要考虑用 es 做一些它不好操作的事情。如果真的有那种操作，尽量在 document 模型设计的时候，写入的时候就完成。另外对于一些太复杂的操作，比如 join/nested/parent-child 搜索都要尽量避免，性能都很差的。</p>
<h3 id="分页性能优化"><a class="markdownIt-Anchor" href="#分页性能优化"></a> 分页性能优化</h3>
<p>es 的分页是较坑的，为啥呢？举个例子吧，假如你每页是 10 条数据，你现在要查询第 100 页，实际上是会把每个 shard 上存储的前 1000 条数据都查到一个协调节点上，如果你有个 5 个 shard，那么就有 5000 条数据，接着协调节点对这 5000 条数据进行一些合并、处理，再获取到最终第 100 页的 10 条数据。</p>
<p>分布式的，你要查第 100 页的 10 条数据，不可能说从 5 个 shard，每个 shard 就查 2 条数据，最后到协调节点合并成 10 条数据吧？你<strong>必须</strong>得从每个 shard 都查 1000 条数据过来，然后根据你的需求进行排序、筛选等等操作，最后再次分页，拿到里面第 100 页的数据。你翻页的时候，翻的越深，每个 shard 返回的数据就越多，而且协调节点处理的时间越长，非常坑爹。所以用 es 做分页的时候，你会发现越翻到后面，就越是慢。</p>
<p>我们之前也是遇到过这个问题，用 es 作分页，前几页就几十毫秒，翻到 10 页或者几十页的时候，基本上就要 5~10 秒才能查出来一页数据了。</p>
<p>有什么解决方案吗？</p>
<h4 id="不允许深度分页默认深度分页性能很差"><a class="markdownIt-Anchor" href="#不允许深度分页默认深度分页性能很差"></a> 不允许深度分页（默认深度分页性能很差）</h4>
<p>跟产品经理说，你系统不允许翻那么深的页，默认翻的越深，性能就越差。</p>
<h4 id="类似于-app-里的推荐商品不断下拉出来一页一页的"><a class="markdownIt-Anchor" href="#类似于-app-里的推荐商品不断下拉出来一页一页的"></a> 类似于 app 里的推荐商品不断下拉出来一页一页的</h4>
<p>类似于微博中，下拉刷微博，刷出来一页一页的，你可以用 <code>scroll api</code> ，关于如何使用，自行上网搜索。</p>
<p>scroll 会一次性给你生成<strong>所有数据的一个快照</strong>，然后每次滑动向后翻页就是通过<strong>游标</strong> <code>scroll_id</code> 移动，获取下一页下一页这样子，性能会比上面说的那种分页性能要高很多很多，基本上都是毫秒级的。</p>
<p>但是，唯一的一点就是，这个适合于那种类似微博下拉翻页的，<strong>不能随意跳到任何一页的场景</strong>。也就是说，你不能先进入第 10 页，然后去第 120 页，然后又回到第 58 页，不能随意乱跳页。所以现在很多产品，都是不允许你随意翻页的，app，也有一些网站，做的就是你只能往下拉，一页一页的翻。</p>
<p>初始化时必须指定 <code>scroll</code> 参数，告诉 es 要保存此次搜索的上下文多长时间。你需要确保用户不会持续不断翻页翻几个小时，否则可能因为超时而失败。</p>
<p>除了用 <code>scroll api</code> ，你也可以用 <code>search_after</code> 来做， <code>search_after</code> 的思想是使用前一页的结果来帮助检索下一页的数据，显然，这种方式也不允许你随意翻页，你只能一页页往后翻。初始化时，需要使用一个唯一值的字段作为 sort 字段。</p>
<p><strong>1.1、设计阶段调优</strong></p>
<p>（1）根据业务增量需求，采取基于日期模板创建索引，通过 roll over API 滚动索引；</p>
<p>（2）使用别名进行索引管理；</p>
<p>（3）每天凌晨定时对索引做 force_merge 操作，以释放空间；</p>
<p>（4）采取冷热分离机制，热数据存储到 SSD，提高检索效率；冷数据定期进行 shrink 操作，以缩减存储；</p>
<p>（5）采取 curator 进行索引的生命周期管理；</p>
<p>（6）仅针对需要分词的字段，合理的设置分词器；</p>
<p>（7）Mapping 阶段充分结合各个字段的属性，是否需要检索、是否需要存储等。………</p>
<p><strong>1.2、写入调优</strong></p>
<p>（1）写入前副本数设置为 0；</p>
<p>（2）写入前关闭 refresh_interval 设置为-1，禁用刷新机制；</p>
<p>（3）写入过程中：采取 bulk 批量写入；</p>
<p>（4）写入后恢复副本数和刷新间隔；</p>
<p>（5）尽量使用自动生成的 id。</p>
<p>1.3、查询调优</p>
<p>（1）禁用 wildcard；</p>
<p>（2）禁用批量 terms（成百上千的场景）；</p>
<p>（3）充分利用倒排索引机制，能 keyword 类型尽量 keyword；</p>
<p>（4）数据量大时候，可以先基于时间敲定索引再检索；</p>
<p>（5）设置合理的路由机制。</p>
<p>1.4、其他调优</p>
<p>部署调优，业务调优等。</p>
<p>上面的提及一部分，面试者就基本对你之前的实践或者运维经验有所评估了。</p>
<h2 id="工作原理"><a class="markdownIt-Anchor" href="#工作原理"></a> 工作原理</h2>
<h3 id="es-写数据过程"><a class="markdownIt-Anchor" href="#es-写数据过程"></a> es 写数据过程</h3>
<ul>
<li>客户端选择一个 node 发送请求过去，这个 node 就是 <code>coordinating node</code> （协调节点）。</li>
<li><code>coordinating node</code> 对 document 进行<strong>路由</strong>，将请求转发给对应的 node（有 primary shard）。</li>
<li>实际的 node 上的 <code>primary shard</code> 处理请求，然后将数据同步到 <code>replica node</code> 。</li>
<li><code>coordinating node</code> 如果发现 <code>primary node</code> 和所有 <code>replica node</code> 都搞定之后，就返回响应结果给客户端。</li>
</ul>
<p><a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/images/es-write.png" target="_blank" rel="noopener"><img src="https://github.com/doocs/advanced-java/raw/main/docs/high-concurrency/images/es-write.png" alt="es-write" /></a></p>
<h3 id="es-读数据过程"><a class="markdownIt-Anchor" href="#es-读数据过程"></a> es 读数据过程</h3>
<p>可以通过 <code>doc id</code> 来查询，会根据 <code>doc id</code> 进行 hash，判断出来当时把 <code>doc id</code> 分配到了哪个 shard 上面去，从那个 shard 去查询。</p>
<ul>
<li>客户端发送请求到<strong>任意</strong>一个 node，成为 <code>coordinate node</code> 。</li>
<li><code>coordinate node</code> 对 <code>doc id</code> 进行哈希路由，将请求转发到对应的 node，此时会使用 <code>round-robin</code> <strong>随机轮询算法</strong>，在 <code>primary shard</code> 以及其所有 replica 中随机选择一个，让读请求负载均衡。</li>
<li>接收请求的 node 返回 document 给 <code>coordinate node</code> 。</li>
<li><code>coordinate node</code> 返回 document 给客户端。</li>
</ul>
<h3 id="es-搜索数据过程"><a class="markdownIt-Anchor" href="#es-搜索数据过程"></a> es 搜索数据过程</h3>
<p>es 最强大的是做全文检索，就是比如你有三条数据：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">java真好玩儿啊</span></span><br><span class="line"><span class="keyword">java好难学啊</span></span><br><span class="line"><span class="keyword">j2ee特别牛</span></span><br></pre></td></tr></table></figure>
<p>你根据 <code>java</code> 关键词来搜索，将包含 <code>java</code> 的 <code>document</code> 给搜索出来。es 就会给你返回：java 真好玩儿啊，java 好难学啊。</p>
<ul>
<li>客户端发送请求到一个 <code>coordinate node</code> 。</li>
<li>协调节点将搜索请求转发到<strong>所有</strong>的 shard 对应的 <code>primary shard</code> 或 <code>replica shard</code> ，都可以。</li>
<li>query phase：每个 shard 将自己的搜索结果（其实就是一些 <code>doc id</code> ）返回给协调节点，由协调节点进行数据的合并、排序、分页等操作，产出最终结果。</li>
<li>fetch phase：接着由协调节点根据 <code>doc id</code> 去各个节点上<strong>拉取实际</strong>的 <code>document</code> 数据，最终返回给客户端。</li>
</ul>
<blockquote>
<p>写请求是写入 primary shard，然后同步给所有的 replica shard；读请求可以从 primary shard 或 replica shard 读取，采用的是随机轮询算法。</p>
</blockquote>
<h3 id="写数据底层原理"><a class="markdownIt-Anchor" href="#写数据底层原理"></a> 写数据底层原理</h3>
<p><a href="https://github.com/doocs/advanced-java/blob/main/docs/high-concurrency/images/es-write-detail.png" target="_blank" rel="noopener"><img src="https://github.com/doocs/advanced-java/raw/master/docs/high-concurrency/images/es-write-detail.png" alt="es-write-detail" /></a></p>
<p>先写入内存 buffer，在 buffer 里的时候数据是搜索不到的；同时将数据写入 translog 日志文件。</p>
<p>如果 buffer 快满了，或者到一定时间，就会将内存 buffer 数据 <code>refresh</code> 到一个新的 <code>segment file</code> 中，但是此时数据不是直接进入 <code>segment file</code> 磁盘文件，而是先进入 <code>os cache</code> 。这个过程就是 <code>refresh</code> 。</p>
<p>每隔 1 秒钟，es 将 buffer 中的数据写入一个<strong>新的</strong> <code>segment file</code> ，每秒钟会产生一个<strong>新的磁盘文件</strong> <code>segment file</code> ，这个 <code>segment file</code> 中就存储最近 1 秒内 buffer 中写入的数据。</p>
<p>但是如果 buffer 里面此时没有数据，那当然不会执行 refresh 操作，如果 buffer 里面有数据，默认 1 秒钟执行一次 refresh 操作，刷入一个新的 segment file 中。</p>
<p>操作系统里面，磁盘文件其实都有一个东西，叫做 <code>os cache</code> ，即操作系统缓存，就是说数据写入磁盘文件之前，会先进入 <code>os cache</code> ，先进入操作系统级别的一个内存缓存中去。只要 <code>buffer</code> 中的数据被 refresh 操作刷入 <code>os cache</code> 中，这个数据就可以被搜索到了。</p>
<p>为什么叫 es 是<strong>准实时</strong>的？ <code>NRT</code> ，全称 <code>near real-time</code> 。默认是每隔 1 秒 refresh 一次的，所以 es 是准实时的，因为写入的数据 1 秒之后才能被看到。可以通过 es 的 <code>restful api</code> 或者 <code>java api</code> ，<strong>手动</strong>执行一次 refresh 操作，就是手动将 buffer 中的数据刷入 <code>os cache</code> 中，让数据立马就可以被搜索到。只要数据被输入 <code>os cache</code> 中，buffer 就会被清空了，因为不需要保留 buffer 了，数据在 translog 里面已经持久化到磁盘去一份了。</p>
<p>重复上面的步骤，新的数据不断进入 buffer 和 translog，不断将 <code>buffer</code> 数据写入一个又一个新的 <code>segment file</code> 中去，每次 <code>refresh</code> 完 buffer 清空，translog 保留。随着这个过程推进，translog 会变得越来越大。当 translog 达到一定长度的时候，就会触发 <code>commit</code> 操作。</p>
<p>commit 操作发生第一步，就是将 buffer 中现有数据 <code>refresh</code> 到 <code>os cache</code> 中去，清空 buffer。然后，将一个 <code>commit point</code> 写入磁盘文件，里面标识着这个 <code>commit point</code> 对应的所有 <code>segment file</code> ，同时强行将 <code>os cache</code> 中目前所有的数据都 <code>fsync</code> 到磁盘文件中去。最后<strong>清空</strong> 现有 translog 日志文件，重启一个 translog，此时 commit 操作完成。</p>
<p>这个 commit 操作叫做 <code>flush</code> 。默认 30 分钟自动执行一次 <code>flush</code> ，但如果 translog 过大，也会触发 <code>flush</code> 。flush 操作就对应着 commit 的全过程，我们可以通过 es api，手动执行 flush 操作，手动将 os cache 中的数据 fsync 强刷到磁盘上去。</p>
<p>translog 日志文件的作用是什么？你执行 commit 操作之前，数据要么是停留在 buffer 中，要么是停留在 os cache 中，无论是 buffer 还是 os cache 都是内存，一旦这台机器死了，内存中的数据就全丢了。所以需要将数据对应的操作写入一个专门的日志文件 <code>translog</code> 中，一旦此时机器宕机，再次重启的时候，es 会自动读取 translog 日志文件中的数据，恢复到内存 buffer 和 os cache 中去。</p>
<p>translog 其实也是先写入 os cache 的，默认每隔 5 秒刷一次到磁盘中去，所以默认情况下，可能有 5 秒的数据会仅仅停留在 buffer 或者 translog 文件的 os cache 中，如果此时机器挂了，会<strong>丢失</strong> 5 秒钟的数据。但是这样性能比较好，最多丢 5 秒的数据。也可以将 translog 设置成每次写操作必须是直接 <code>fsync</code> 到磁盘，但是性能会差很多。</p>
<p>实际上你在这里，如果面试官没有问你 es 丢数据的问题，你可以在这里给面试官炫一把，你说，其实 es 第一是准实时的，数据写入 1 秒后可以搜索到；可能会丢失数据的。有 5 秒的数据，停留在 buffer、translog os cache、segment file os cache 中，而不在磁盘上，此时如果宕机，会导致 5 秒的<strong>数据丢失</strong>。</p>
<p><strong>总结一下</strong>，数据先写入内存 buffer，然后每隔 1s，将数据 refresh 到 os cache，到了 os cache 数据就能被搜索到（所以我们才说 es 从写入到能被搜索到，中间有 1s 的延迟）。每隔 5s，将数据写入 translog 文件（这样如果机器宕机，内存数据全没，最多会有 5s 的数据丢失），translog 大到一定程度，或者默认每隔 30mins，会触发 commit 操作，将缓冲区的数据都 flush 到 segment file 磁盘文件中。</p>
<blockquote>
<p>数据写入 segment file 之后，同时就建立好了倒排索引。</p>
</blockquote>
<h3 id="删除更新数据底层原理"><a class="markdownIt-Anchor" href="#删除更新数据底层原理"></a> 删除/更新数据底层原理</h3>
<p>如果是删除操作，commit 的时候会生成一个 <code>.del</code> 文件，里面将某个 doc 标识为 <code>deleted</code> 状态，那么搜索的时候根据 <code>.del</code> 文件就知道这个 doc 是否被删除了。</p>
<p>如果是更新操作，就是将原来的 doc 标识为 <code>deleted</code> 状态，然后新写入一条数据。</p>
<p>buffer 每 refresh 一次，就会产生一个 <code>segment file</code> ，所以默认情况下是 1 秒钟一个 <code>segment file</code> ，这样下来 <code>segment file</code> 会越来越多，此时会定期执行 merge。每次 merge 的时候，会将多个 <code>segment file</code> 合并成一个，同时这里会将标识为 <code>deleted</code> 的 doc 给<strong>物理删除掉</strong>，然后将新的 <code>segment file</code> 写入磁盘，这里会写一个 <code>commit point</code> ，标识所有新的 <code>segment file</code> ，然后打开 <code>segment file</code> 供搜索使用，同时删除旧的 <code>segment file</code> 。</p>
<h3 id="底层-lucene"><a class="markdownIt-Anchor" href="#底层-lucene"></a> 底层 lucene</h3>
<p>简单来说，lucene 就是一个 jar 包，里面包含了封装好的各种建立倒排索引的算法代码。我们用 Java 开发的时候，引入 lucene jar，然后基于 lucene 的 api 去开发就可以了。</p>
<p>通过 lucene，我们可以将已有的数据建立索引，lucene 会在本地磁盘上面，给我们组织索引的数据结构。</p>
<h3 id="倒排索引"><a class="markdownIt-Anchor" href="#倒排索引"></a> 倒排索引</h3>
<p>在搜索引擎中，每个文档都有一个对应的文档 ID，文档内容被表示为一系列关键词的集合。例如，文档 1 经过分词，提取了 20 个关键词，每个关键词都会记录它在文档中出现的次数和出现位置。</p>
<p>那么，倒排索引就是<strong>关键词到文档</strong> ID 的映射，每个关键词都对应着一系列的文件，这些文件中都出现了关键词。</p>
<p>举个栗子。</p>
<p>有以下文档：</p>
<table>
<thead>
<tr>
<th>DocId</th>
<th>Doc</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>谷歌地图之父跳槽 Facebook</td>
</tr>
<tr>
<td>2</td>
<td>谷歌地图之父加盟 Facebook</td>
</tr>
<tr>
<td>3</td>
<td>谷歌地图创始人拉斯离开谷歌加盟 Facebook</td>
</tr>
<tr>
<td>4</td>
<td>谷歌地图之父跳槽 Facebook 与 Wave 项目取消有关</td>
</tr>
<tr>
<td>5</td>
<td>谷歌地图之父拉斯加盟社交网站 Facebook</td>
</tr>
</tbody>
</table>
<p>对文档进行分词之后，得到以下<strong>倒排索引</strong>。</p>
<table>
<thead>
<tr>
<th>WordId</th>
<th>Word</th>
<th>DocIds</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>谷歌</td>
<td>1, 2, 3, 4, 5</td>
</tr>
<tr>
<td>2</td>
<td>地图</td>
<td>1, 2, 3, 4, 5</td>
</tr>
<tr>
<td>3</td>
<td>之父</td>
<td>1, 2, 4, 5</td>
</tr>
<tr>
<td>4</td>
<td>跳槽</td>
<td>1, 4</td>
</tr>
<tr>
<td>5</td>
<td>Facebook</td>
<td>1, 2, 3, 4, 5</td>
</tr>
<tr>
<td>6</td>
<td>加盟</td>
<td>2, 3, 5</td>
</tr>
<tr>
<td>7</td>
<td>创始人</td>
<td>3</td>
</tr>
<tr>
<td>8</td>
<td>拉斯</td>
<td>3, 5</td>
</tr>
<tr>
<td>9</td>
<td>离开</td>
<td>3</td>
</tr>
<tr>
<td>10</td>
<td>与</td>
<td>4</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>另外，实用的倒排索引还可以记录更多的信息，比如文档频率信息，表示在文档集合中有多少个文档包含某个单词。</p>
<p>那么，有了倒排索引，搜索引擎可以很方便地响应用户的查询。比如用户输入查询 <code>Facebook</code> ，搜索系统查找倒排索引，从中读出包含这个单词的文档，这些文档就是提供给用户的搜索结果。</p>
<p>要注意倒排索引的两个重要细节：</p>
<ul>
<li>倒排索引中的所有词项对应一个或多个文档；</li>
<li>倒排索引中的词项<strong>根据字典顺序升序排列</strong></li>
</ul>
<blockquote>
<p>上面只是一个简单的栗子，并没有严格按照字典顺序升序排列。</p>
</blockquote>
<h2 id="elasticsearch-的倒排索引是什么"><a class="markdownIt-Anchor" href="#elasticsearch-的倒排索引是什么"></a> elasticsearch 的倒排索引是什么</h2>
<p>面试官：想了解你对基础概念的认知。</p>
<p>解答：通俗解释一下就可以。</p>
<p>传统的我们的检索是通过文章，逐个遍历找到对应关键词的位置。</p>
<p>而倒排索引，是通过分词策略，形成了词和文章的映射关系表，这种词典+映射表即为倒排索引。有了倒排索引，就能实现 o（1）时间复杂度的效率检索文章了，极大的提高了检索效率。</p>
<p><img src="https://pic3.zhimg.com/80/v2-bf18227dc4554da0dcc7b970dbd582ae_720w.jpg" alt="img" /></p>
<p>学术的解答方式：</p>
<p>倒排索引，相反于一篇文章包含了哪些词，它从词出发，记载了这个词在哪些文档中出现过，由两部分组成——词典和倒排表。</p>
<p>加分项：倒排索引的底层实现是基于：FST（Finite State Transducer）数据结构。</p>
<p>lucene 从 4+版本后开始大量使用的数据结构是 FST。FST 有两个优点：</p>
<p>（1）空间占用小。通过对词典中单词前缀和后缀的重复利用，压缩了存储空间；</p>
<p>（2）查询速度快。O(len(str))的查询时间复杂度。</p>
<h2 id="3-elasticsearch-索引数据多了怎么办如何调优部署"><a class="markdownIt-Anchor" href="#3-elasticsearch-索引数据多了怎么办如何调优部署"></a> 3、elasticsearch 索引数据多了怎么办，如何调优，部署</h2>
<p>面试官：想了解大数据量的运维能力。</p>
<p>解答：索引数据的规划，应在前期做好规划，正所谓“设计先行，编码在后”，这样才能有效的避免突如其来的数据激增导致集群处理能力不足引发的线上客户检索或者其他业务受到影响。</p>
<p>如何调优，正如问题 1 所说，这里细化一下：</p>
<p><strong>3.1 动态索引层面</strong></p>
<p>基于模板+时间+rollover api 滚动创建索引，举例：设计阶段定义：blog 索引的模板格式为：blog<em>index</em>时间戳的形式，每天递增数据。这样做的好处：不至于数据量激增导致单个索引数据量非常大，接近于上线 2 的 32 次幂-1，索引存储达到了 TB+甚至更大。</p>
<p>一旦单个索引很大，存储等各种风险也随之而来，所以要提前考虑+及早避免。</p>
<p><strong>3.2 存储层面</strong></p>
<p>冷热数据分离存储，热数据（比如最近 3 天或者一周的数据），其余为冷数据。</p>
<p>对于冷数据不会再写入新数据，可以考虑定期 force_merge 加 shrink 压缩操作，节省存储空间和检索效率。</p>
<p><strong>3.3 部署层面</strong></p>
<p>一旦之前没有规划，这里就属于应急策略。</p>
<p>结合 ES 自身的支持动态扩展的特点，动态新增机器的方式可以缓解集群压力，注意：如果之前主节点等规划合理，不需要重启集群也能完成动态新增的。</p>
<h2 id="4-elasticsearch-是如何实现-master-选举的"><a class="markdownIt-Anchor" href="#4-elasticsearch-是如何实现-master-选举的"></a> 4、elasticsearch 是如何实现 master 选举的</h2>
<p>面试官：想了解 ES 集群的底层原理，不再只关注业务层面了。</p>
<p>解答：</p>
<p>前置前提：</p>
<p>（1）只有候选主节点（master：true）的节点才能成为主节点。</p>
<p>（2）最小主节点数（min_master_nodes）的目的是防止脑裂。</p>
<p>核对了一下代码，核心入口为 findMaster，选择主节点成功返回对应 Master，否则返回 null。选举流程大致描述如下：</p>
<p>第一步：确认候选主节点数达标，elasticsearch.yml 设置的值</p>
<p>discovery.zen.minimum_master_nodes；</p>
<p>第二步：比较：先判定是否具备 master 资格，具备候选主节点资格的优先返回；</p>
<p>若两节点都为候选主节点，则 id 小的值会主节点。注意这里的 id 为 string 类型。</p>
<p>题外话：获取节点 id 的方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1GET &#x2F;_cat&#x2F;nodes?v&amp;h&#x3D;ip,port,heapPercent,heapMax,id,name</span><br><span class="line"></span><br><span class="line">2ip port heapPercent heapMax id name</span><br></pre></td></tr></table></figure>
<h2 id="详细描述一下-elasticsearch-索引文档的过程"><a class="markdownIt-Anchor" href="#详细描述一下-elasticsearch-索引文档的过程"></a> 详细描述一下 Elasticsearch 索引文档的过程</h2>
<p>面试官：想了解 ES 的底层原理，不再只关注业务层面了。</p>
<p>解答：</p>
<p>这里的索引文档应该理解为文档写入 ES，创建索引的过程。</p>
<p>文档写入包含：单文档写入和批量 bulk 写入，这里只解释一下：单文档写入流程。</p>
<p>记住官方文档中的这个图。</p>
<p><img src="https://pic3.zhimg.com/80/v2-bf1b23846420eb4fdace5c6415ad7cf2_720w.jpg" alt="img" /></p>
<p>第一步：客户写集群某节点写入数据，发送请求。（如果没有指定路由/协调节点，请求的节点扮演路由节点的角色。）</p>
<p>第二步：节点 1 接受到请求后，使用文档_id 来确定文档属于分片 0。请求会被转到另外的节点，假定节点 3。因此分片 0 的主分片分配到节点 3 上。</p>
<p>第三步：节点 3 在主分片上执行写操作，如果成功，则将请求并行转发到节点 1 和节点 2 的副本分片上，等待结果返回。所有的副本分片都报告成功，节点 3 将向协调节点（节点 1）报告成功，节点 1 向请求客户端报告写入成功。</p>
<p>如果面试官再问：第二步中的文档获取分片的过程？</p>
<p>回答：借助路由算法获取，路由算法就是根据路由和文档 id 计算目标的分片 id 的过程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1shard &#x3D; hash(_routing) % (num_of_primary_shards)</span><br></pre></td></tr></table></figure>
<h2 id="详细描述一下-elasticsearch-搜索的过程"><a class="markdownIt-Anchor" href="#详细描述一下-elasticsearch-搜索的过程"></a> 详细描述一下 Elasticsearch 搜索的过程？</h2>
<p>面试官：想了解 ES 搜索的底层原理，不再只关注业务层面了。</p>
<p>解答：</p>
<p>搜索拆解为“query then fetch” 两个阶段。</p>
<p>query 阶段的目的：定位到位置，但不取。</p>
<p>步骤拆解如下：</p>
<p>（1）假设一个索引数据有 5 主+1 副本 共 10 分片，一次请求会命中（主或者副本分片中）的一个。</p>
<p>（2）每个分片在本地进行查询，结果返回到本地有序的优先队列中。</p>
<p>（3）第 2）步骤的结果发送到协调节点，协调节点产生一个全局的排序列表。</p>
<p>fetch 阶段的目的：取数据。</p>
<p>路由节点获取所有文档，返回给客户端。</p>
<h2 id="elasticsearch-在部署时对-linux-的设置有哪些优化方法"><a class="markdownIt-Anchor" href="#elasticsearch-在部署时对-linux-的设置有哪些优化方法"></a> Elasticsearch 在部署时，对 Linux 的设置有哪些优化方法</h2>
<p>面试官：想了解对 ES 集群的运维能力。</p>
<p>解答：</p>
<p>（1）关闭缓存 swap;</p>
<p>（2）堆内存设置为：Min（节点内存/2, 32GB）;</p>
<p>（3）设置最大文件句柄数；</p>
<p>（4）线程池+队列大小根据业务需要做调整；</p>
<p>（5）磁盘存储 raid 方式——存储有条件使用 RAID10，增加单节点性能以及避免单节点存储故障。</p>
<h2 id="lucence-内部结构是什么"><a class="markdownIt-Anchor" href="#lucence-内部结构是什么"></a> lucence 内部结构是什么？</h2>
<p>面试官：想了解你的知识面的广度和深度。</p>
<p>解答：</p>
<p><img src="https://pic1.zhimg.com/80/v2-576954e3b238870ec089d68abe0de1d4_720w.jpg" alt="img" /></p>
<p>Lucene 是有索引和搜索的两个过程，包含索引创建，索引，搜索三个要点。可以基于这个脉络展开一些。</p>
<h2 id="elasticsearch-是如何实现-master-选举的"><a class="markdownIt-Anchor" href="#elasticsearch-是如何实现-master-选举的"></a> Elasticsearch 是如何实现 Master 选举的？</h2>
<p>（1）Elasticsearch 的选主是 ZenDiscovery 模块负责的，主要包含 Ping（节点之间通过这个 RPC 来发现彼此）和 Unicast（单播模块包含一个主机列表以控制哪些节点需要 ping 通）这两部分；</p>
<p>（2）对所有可以成为 master 的节点（node.master: true）根据 nodeId 字典排序，每次选举每个节点都把自己所知道节点排一次序，然后选出第一个（第 0 位）节点，暂且认为它是 master 节点。</p>
<p>（3）如果对某个节点的投票数达到一定的值（可以成为 master 节点数 n/2+1）并且该节点自己也选举自己，那这个节点就是 master。否则重新选举一直到满足上述条件。</p>
<p>（4）补充：master 节点的职责主要包括集群、节点和索引的管理，不负责文档级别的管理；data 节点可以关闭 http 功能*。</p>
<h2 id="10-elasticsearch-中的节点比如共-20-个其中的-10-个"><a class="markdownIt-Anchor" href="#10-elasticsearch-中的节点比如共-20-个其中的-10-个"></a> 10、Elasticsearch 中的节点（比如共 20 个），其中的 10 个</h2>
<p>选了一个 master，另外 10 个选了另一个 master，怎么办？</p>
<p>（1）当集群 master 候选数量不小于 3 个时，可以通过设置最少投票通过数量（discovery.zen.minimum_master_nodes）超过所有候选节点一半以上来解决脑裂问题；</p>
<p>（3）当候选数量为两个时，只能修改为唯一的一个 master 候选，其他作为 data 节点，避免脑裂问题。</p>
<h2 id="客户端在和集群连接时如何选择特定的节点执行请求的"><a class="markdownIt-Anchor" href="#客户端在和集群连接时如何选择特定的节点执行请求的"></a> 客户端在和集群连接时，如何选择特定的节点执行请求的？</h2>
<p>TransportClient 利用 transport 模块远程连接一个 elasticsearch 集群。它并不加入到集群中，只是简单的获得一个或者多个初始化的 transport 地址，并以 轮询 的方式与这些地址进行通信。</p>
<h2 id="详细描述一下-elasticsearch-索引文档的过程-2"><a class="markdownIt-Anchor" href="#详细描述一下-elasticsearch-索引文档的过程-2"></a> 详细描述一下 Elasticsearch 索引文档的过程。</h2>
<p>协调节点默认使用文档 ID 参与计算（也支持通过 routing），以便为路由提供合适的分片。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shard &#x3D; hash(document_id) % (num_of_primary_shards)</span><br></pre></td></tr></table></figure>
<p>（1）当分片所在的节点接收到来自协调节点的请求后，会将请求写入到 MemoryBuffer，然后定时（默认是每隔 1 秒）写入到 Filesystem Cache，这个从 MomeryBuffer 到 Filesystem Cache 的过程就叫做 refresh；</p>
<p>（2）当然在某些情况下，存在 Momery Buffer 和 Filesystem Cache 的数据可能会丢失，ES 是通过 translog 的机制来保证数据的可靠性的。其实现机制是接收到请求后，同时也会写入到 translog 中 ，当 Filesystem cache 中的数据写入到磁盘中时，才会清除掉，这个过程叫做 flush；</p>
<p>（3）在 flush 过程中，内存中的缓冲将被清除，内容被写入一个新段，段的 fsync 将创建一个新的提交点，并将内容刷新到磁盘，旧的 translog 将被删除并开始一个新的 translog。</p>
<p>（4）flush 触发的时机是定时触发（默认 30 分钟）或者 translog 变得太大（默认为 512M）时；</p>
<p><img src="https://pic4.zhimg.com/80/v2-5e0c4bfbd57a4fae4895c480aaaa0a37_720w.jpg" alt="img" /></p>
<p>补充：关于 Lucene 的 Segement：</p>
<p>（1）Lucene 索引是由多个段组成，段本身是一个功能齐全的倒排索引。</p>
<p>（2）段是不可变的，允许 Lucene 将新的文档增量地添加到索引中，而不用从头重建索引。</p>
<p>（3）对于每一个搜索请求而言，索引中的所有段都会被搜索，并且每个段会消耗 CPU 的时钟周、文件句柄和内存。这意味着段的数量越多，搜索性能会越低。</p>
<p>（4）为了解决这个问题，Elasticsearch 会合并小段到一个较大的段，提交新的合并段到磁盘，并删除那些旧的小段。</p>
<h2 id="详细描述一下-elasticsearch-更新和删除文档的过程"><a class="markdownIt-Anchor" href="#详细描述一下-elasticsearch-更新和删除文档的过程"></a> 详细描述一下 Elasticsearch 更新和删除文档的过程。</h2>
<p>（1）删除和更新也都是写操作，但是 Elasticsearch 中的文档是不可变的，因此不能被删除或者改动以展示其变更；</p>
<p>（2）磁盘上的每个段都有一个相应的.del 文件。当删除请求发送后，文档并没有真的被删除，而是在.del 文件中被标记为删除。该文档依然能匹配查询，但是会在结果中被过滤掉。当段合并时，在.del 文件中被标记为删除的文档将不会被写入新段。</p>
<p>（3）在新的文档被创建时，Elasticsearch 会为该文档指定一个版本号，当执行更新时，旧版本的文档在.del 文件中被标记为删除，新版本的文档被索引到一个新段。旧版本的文档依然能匹配查询，但是会在结果中被过滤掉。</p>
<h2 id="详细描述一下-elasticsearch-搜索的过程-2"><a class="markdownIt-Anchor" href="#详细描述一下-elasticsearch-搜索的过程-2"></a> 详细描述一下 Elasticsearch 搜索的过程。</h2>
<p>（1）搜索被执行成一个两阶段过程，我们称之为 Query Then Fetch；</p>
<p>（2）在初始查询阶段时，查询会广播到索引中每一个分片拷贝（主分片或者副本分片）。 每个分片在本地执行搜索并构建一个匹配文档的大小为 from + size 的优先队列。</p>
<p>PS：在搜索的时候是会查询 Filesystem Cache 的，但是有部分数据还在 MemoryBuffer，所以搜索是近实时的。</p>
<p>（3）每个分片返回各自优先队列中 所有文档的 ID 和排序值 给协调节点，它合并这些值到自己的优先队列中来产生一个全局排序后的结果列表。</p>
<p>（4）接下来就是 取回阶段，协调节点辨别出哪些文档需要被取回并向相关的分片提交多个 GET 请求。每个分片加载并 丰 富 文档，如果有需要的话，接着返回文档给协调节点。一旦所有的文档都被取回了，协调节点返回结果给客户端。</p>
<p>（5）补充：Query Then Fetch 的搜索类型在文档相关性打分的时候参考的是本分片的数据，这样在文档数量较少的时候可能不够准确，DFS Query Then Fetch 增加了一个预查询的处理，询问 Term 和 Document frequency，这个评分更准确，但是性能会变差。*</p>
<p><img src="https://pic2.zhimg.com/80/v2-4c25616e623de2aee23bd63ec22a5bfd_720w.jpg" alt="img" /></p>
<h2 id="在-elasticsearch-中是怎么根据一个词找到对应的倒排索引的"><a class="markdownIt-Anchor" href="#在-elasticsearch-中是怎么根据一个词找到对应的倒排索引的"></a> 在 Elasticsearch 中，是怎么根据一个词找到对应的倒排索引的？</h2>
<p>（1）Lucene 的索引过程，就是按照全文检索的基本过程，将倒排表写成此文件格式的过程。</p>
<p>（2）Lucene 的搜索过程，就是按照此文件格式将索引进去的信息读出来，然后计算每篇文档打分(score)的过程。</p>
<h2 id="elasticsearch-在部署时对-linux-的设置有哪些优化方法-2"><a class="markdownIt-Anchor" href="#elasticsearch-在部署时对-linux-的设置有哪些优化方法-2"></a> Elasticsearch 在部署时，对 Linux 的设置有哪些优化方法？</h2>
<p>（1）64 GB 内存的机器是非常理想的， 但是 32 GB 和 16 GB 机器也是很常见的。少于 8 GB 会适得其反。</p>
<p>（2）如果你要在更快的 CPUs 和更多的核心之间选择，选择更多的核心更好。多个内核提供的额外并发远胜过稍微快一点点的时钟频率。</p>
<p>（3）如果你负担得起 SSD，它将远远超出任何旋转介质。 基于 SSD 的节点，查询和索引性能都有提升。如果你负担得起，SSD 是一个好的选择。</p>
<p>（4）即使数据中心们近在咫尺，也要避免集群跨越多个数据中心。绝对要避免集群跨越大的地理距离。</p>
<p>（5）请确保运行你应用程序的 JVM 和服务器的 JVM 是完全一样的。 在 Elasticsearch 的几个地方，使用 Java 的本地序列化。</p>
<p>（6）通过设置 gateway.recover_after_nodes、gateway.expected_nodes、gateway.recover_after_time 可以在集群重启的时候避免过多的分片交换，这可能会让数据恢复从数个小时缩短为几秒钟。</p>
<p>（7）Elasticsearch 默认被配置为使用单播发现，以防止节点无意中加入集群。只有在同一台机器上运行的节点才会自动组成集群。最好使用单播代替组播。</p>
<p>（8）不要随意修改垃圾回收器（CMS）和各个线程池的大小。</p>
<p>（9）把你的内存的（少于）一半给 Lucene（但不要超过 32 GB！），通过 ES_HEAP_SIZE 环境变量设置。</p>
<p>（10）内存交换到磁盘对服务器性能来说是致命的。如果内存交换到磁盘上，一个 100 微秒的操作可能变成 10 毫秒。 再想想那么多 10 微秒的操作时延累加起来。 不难看出 swapping 对于性能是多么可怕。</p>
<p>（11）Lucene 使用了大 量 的文件。同时，Elasticsearch 在节点和 HTTP 客户端之间进行通信也使用了大量的套接字。 所有这一切都需要足够的文件描述符。你应该增加你的文件描述符，设置一个很大的值，如 64,000。</p>
<p>补充：索引阶段性能提升方法</p>
<p>（1）使用批量请求并调整其大小：每次批量数据 5–15 MB 大是个不错的起始点。</p>
<p>（2）存储：使用 SSD</p>
<p>（3）段和合并：Elasticsearch 默认值是 20 MB/s，对机械磁盘应该是个不错的设置。如果你用的是 SSD，可以考虑提高到 100–200 MB/s。如果你在做批量导入，完全不在意搜索，你可以彻底关掉合并限流。另外还可以增加 index.translog.flush_threshold_size 设置，从默认的 512 MB 到更大一些的值，比如 1 GB，这可以在一次清空触发的时候在事务日志里积累出更大的段。</p>
<p>（4）如果你的搜索结果不需要近实时的准确度，考虑把每个索引的 index.refresh_interval 改到 30s。</p>
<p>（5）如果你在做大批量导入，考虑通过设置 index.number_of_replicas: 0 关闭副本。</p>
<h2 id="对于-gc-方面在使用-elasticsearch-时要注意什么"><a class="markdownIt-Anchor" href="#对于-gc-方面在使用-elasticsearch-时要注意什么"></a> 对于 GC 方面，在使用 Elasticsearch 时要注意什么？</h2>
<p>（1）倒排词典的索引需要常驻内存，无法 GC，需要监控 data node 上 segmentmemory 增长趋势。</p>
<p>（2）各类缓存，field cache, filter cache, indexing cache, bulk queue 等等，要设置合理的大小，并且要应该根据最坏的情况来看 heap 是否够用，也就是各类缓存全部占满的时候，还有 heap 空间可以分配给其他任务吗？避免采用 clear cache 等“自欺欺人”的方式来释放内存。</p>
<p>（3）避免返回大量结果集的搜索与聚合。确实需要大量拉取数据的场景，可以采用 scan &amp; scroll api 来实现。</p>
<p>（4）cluster stats 驻留内存并无法水平扩展，超大规模集群可以考虑分拆成多个集群通过 tribe node 连接。</p>
<p>（5）想知道 heap 够不够，必须结合实际应用场景，并对集群的 heap 使用情况做持续的监控。</p>
<p>（6）根据监控数据理解内存需求，合理配置各类 circuit breaker，将内存溢出风险降低到最低</p>
<h2 id="18-elasticsearch-对于大数据量上亿量级的聚合如何实现"><a class="markdownIt-Anchor" href="#18-elasticsearch-对于大数据量上亿量级的聚合如何实现"></a> 18、Elasticsearch 对于大数据量（上亿量级）的聚合如何实现？</h2>
<p>Elasticsearch 提供的首个近似聚合是 cardinality 度量。它提供一个字段的基数，即该字段的 distinct 或者 unique 值的数目。它是基于 HLL 算法的。HLL 会先对我们的输入作哈希运算，然后根据哈希运算的结果中的 bits 做概率估算从而得到基数。其特点是：可配置的精度，用来控制内存的使用（更精确 ＝ 更多内存）；小的数据集精度是非常高的；我们可以通过配置参数，来设置去重需要的固定内存使用量。无论数千还是数十亿的唯一值，内存使用量只与你配置的精确度相关。</p>
<h2 id="19-在并发情况下elasticsearch-如果保证读写一致"><a class="markdownIt-Anchor" href="#19-在并发情况下elasticsearch-如果保证读写一致"></a> 19、在并发情况下，Elasticsearch 如果保证读写一致？</h2>
<p>（1）可以通过版本号使用乐观并发控制，以确保新版本不会被旧版本覆盖，由应用层来处理具体的冲突；</p>
<p>（2）另外对于写操作，一致性级别支持 quorum/one/all，默认为 quorum，即只有当大多数分片可用时才允许写操作。但即使大多数可用，也可能存在因为网络等原因导致写入副本失败，这样该副本被认为故障，分片将会在一个不同的节点上重建。</p>
<p>（3）对于读操作，可以设置 replication 为 sync(默认)，这使得操作在主分片和副本分片都完成后才会返回；如果设置 replication 为 async 时，也可以通过设置搜索请求参数_preference 为 primary 来查询主分片，确保文档是最新版本。</p>
<h2 id="20-如何监控-elasticsearch-集群状态"><a class="markdownIt-Anchor" href="#20-如何监控-elasticsearch-集群状态"></a> 20、如何监控 Elasticsearch 集群状态？</h2>
<p>Marvel 让你可以很简单的通过 Kibana 监控 Elasticsearch。你可以实时查看你的集群健康状态和性能，也可以分析过去的集群、索引和节点指标。</p>
<h2 id="21-介绍下你们电商搜索的整体技术架构"><a class="markdownIt-Anchor" href="#21-介绍下你们电商搜索的整体技术架构"></a> 21、介绍下你们电商搜索的整体技术架构。</h2>
<p><img src="https://pic1.zhimg.com/80/v2-5bdbe7ada0ddee9d8b2f03c0a379e0d4_720w.jpg" alt="img" /></p>
<h2 id="介绍一下你们的个性化搜索方案"><a class="markdownIt-Anchor" href="#介绍一下你们的个性化搜索方案"></a> 介绍一下你们的个性化搜索方案？</h2>
<p>基于 word2vec 和 Elasticsearch 实现个性化搜索</p>
<p>（1）基于 word2vec、Elasticsearch 和自定义的脚本插件，我们就实现了一个个性化的搜索服务，相对于原有的实现，新版的点击率和转化率都有大幅的提升；</p>
<p>（2）基于 word2vec 的商品向量还有一个可用之处，就是可以用来实现相似商品的推荐；</p>
<p>（3）使用 word2vec 来实现个性化搜索或个性化推荐是有一定局限性的，因为它只能处理用户点击历史这样的时序数据，而无法全面的去考虑用户偏好，这个还是有很大的改进和提升的空间；</p>
<h2 id="是否了解字典树"><a class="markdownIt-Anchor" href="#是否了解字典树"></a> 是否了解字典树？</h2>
<p>常用字典数据结构如下所示：</p>
<p><img src="https://pic2.zhimg.com/80/v2-8bb844c5b8fb944111fa8cecdb0e12d5_720w.jpg" alt="img" /></p>
<p>Trie 的核心思想是空间换时间，利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。它有 3 个基本性质：</p>
<p>1）根节点不包含字符，除根节点外每一个节点都只包含一个字符。</p>
<p>2）从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。</p>
<p>3）每个节点的所有子节点包含的字符都不相同。</p>
<p><img src="https://pic4.zhimg.com/80/v2-26a48882a8f09a50dfeb79cc25045fcf_720w.jpg" alt="img" /></p>
<p>（1）可以看到，trie 树每一层的节点数是 26^i 级别的。所以为了节省空间，我们还可以用动态链表，或者用数组来模拟动态。而空间的花费，不会超过单词数 × 单词长度。</p>
<p>（2）实现：对每个结点开一个字母集大小的数组，每个结点挂一个链表，使用左儿子右兄弟表示法记录这棵树；</p>
<p>（3）对于中文的字典树，每个节点的子节点用一个哈希表存储，这样就不用浪费太大的空间，而且查询速度上可以保留哈希的复杂度 O(1)。</p>
<h2 id="拼写纠错是如何实现的"><a class="markdownIt-Anchor" href="#拼写纠错是如何实现的"></a> 拼写纠错是如何实现的？</h2>
<p>（1）拼写纠错是基于编辑距离来实现；编辑距离是一种标准的方法，它用来表示经过插入、删除和替换操作从一个字符串转换到另外一个字符串的最小操作步数；</p>
<p>（2）编辑距离的计算过程：比如要计算 batyu 和 beauty 的编辑距离，先创建一个 7×8 的表（batyu 长度为 5，coffee 长度为 6，各加 2），接着，在如下位置填入黑色数字。其他格的计算过程是取以下三个值的最小值：</p>
<p>如果最上方的字符等于最左方的字符，则为左上方的数字。否则为左上方的数字+1。（对于 3,3 来说为 0）</p>
<p>左方数字+1（对于 3,3 格来说为 2）</p>
<p>上方数字+1（对于 3,3 格来说为 2）</p>
<p>最终取右下角的值即为编辑距离的值 3。</p>
<p><img src="https://pic4.zhimg.com/80/v2-66f01f0d578c83274e90a7ddf704b633_720w.jpg" alt="img" /></p>
<p>对于拼写纠错，我们考虑构造一个度量空间（Metric Space），该空间内任何关系满足以下三条基本条件：</p>
<p>d(x,y) = 0 – 假如 x 与 y 的距离为 0，则 x=y</p>
<p>d(x,y) = d(y,x) – x 到 y 的距离等同于 y 到 x 的距离</p>
<p>d(x,y) + d(y,z) &gt;= d(x,z) – 三角不等式</p>
<p>（1）根据三角不等式，则满足与 query 距离在 n 范围内的另一个字符转 B，其与 A 的距离最大为 d+n，最小为 d-n。</p>
<p>（2）BK 树的构造就过程如下：每个节点有任意个子节点，每条边有个值表示编辑距离。所有子节点到父节点的边上标注 n 表示编辑距离恰好为 n。比如，我们有棵树父节点是”book”和两个子节点”cake”和”books”，”book”到”books”的边标号 1，”book”到”cake”的边上标号 4。从字典里构造好树后，无论何时你想插入新单词时，计算该单词与根节点的编辑距离，并且查找数值为 d(neweord, root)的边。递归得与各子节点进行比较，直到没有子节点，你就可以创建新的子节点并将新单词保存在那。比如，插入”boo”到刚才上述例子的树中，我们先检查根节点，查找 d(“book”, “boo”) = 1 的边，然后检查标号为 1 的边的子节点，得到单词”books”。我们再计算距离 d(“books”, “boo”)=2，则将新单词插在”books”之后，边标号为 2。</p>
<p>（3）查询相似词如下：计算单词与根节点的编辑距离 d，然后递归查找每个子节点标号为 d-n 到 d+n（包含）的边。假如被检查的节点与搜索单词的距离 d 小于 n，则返回该节点并继续查询。比如输入 cape 且最大容忍距离为 1，则先计算和根的编辑距离 d(“book”, “cape”)=4，然后接着找和根节点之间编辑距离为 3 到 5 的，这个就找到了 cake 这个节点，计算 d(“cake”, “cape”)=1，满足条件所以返回 cake，然后再找和 cake 节点编辑距离是 0 到 2 的，分别找到 cape 和 cart 节点，这样就得到 cape 这个满足条件的结果。</p>
<p><img src="https://pic4.zhimg.com/80/v2-79f2a89041e546d9feccf55e4ff1c0d7_720w.jpg" alt="img" /></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/2020/06/16/elasticsearch-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2020/06/16/elasticsearch-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">Elasticsearch 快速入门</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-16 07:10:44" itemprop="dateCreated datePublished" datetime="2020-06-16T07:10:44+08:00">2020-06-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-14 16:45:53" itemprop="dateModified" datetime="2022-04-14T16:45:53+08:00">2022-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">搜索引擎数据库</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E5%BA%93/Elasticsearch/" itemprop="url" rel="index">
                    <span itemprop="name">Elasticsearch</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2020/06/16/elasticsearch-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/06/16/elasticsearch-快速入门/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="elasticsearch-快速入门"><a class="markdownIt-Anchor" href="#elasticsearch-快速入门"></a> Elasticsearch 快速入门</h1>
<blockquote>
<p><strong><a href="https://github.com/elastic/elasticsearch" target="_blank" rel="noopener">Elasticsearch</a> 是一个分布式、RESTful 风格的搜索和数据分析引擎</strong>，能够解决不断涌现出的各种用例。 作为 Elastic Stack 的核心，它集中存储您的数据，帮助您发现意料之中以及意料之外的情况。</p>
<p><a href="https://github.com/elastic/elasticsearch" target="_blank" rel="noopener">Elasticsearch</a> 基于搜索库 <a href="https://github.com/apache/lucene-solr" target="_blank" rel="noopener">Lucene</a> 开发。ElasticSearch 隐藏了 Lucene 的复杂性，提供了简单易用的 REST API / Java API 接口（另外还有其他语言的 API 接口）。</p>
<p><em>以下简称 ES</em>。</p>
</blockquote>
<h2 id="一-elasticsearch-简介"><a class="markdownIt-Anchor" href="#一-elasticsearch-简介"></a> 一、Elasticsearch 简介</h2>
<h3 id="什么是-elasticsearch"><a class="markdownIt-Anchor" href="#什么是-elasticsearch"></a> 什么是 Elasticsearch</h3>
<p><strong><a href="https://github.com/elastic/elasticsearch" target="_blank" rel="noopener">Elasticsearch</a> 是一个分布式、RESTful 风格的搜索和数据分析引擎</strong>，能够解决不断涌现出的各种用例。 作为 Elastic Stack 的核心，它集中存储您的数据，帮助您发现意料之中以及意料之外的情况。</p>
<p><a href="https://github.com/elastic/elasticsearch" target="_blank" rel="noopener">Elasticsearch</a> <strong>基于搜索库 <a href="https://github.com/apache/lucene-solr" target="_blank" rel="noopener">Lucene</a> 开发</strong>。ElasticSearch 隐藏了 Lucene 的复杂性，提供了简单易用的 REST API / Java API 接口（另外还有其他语言的 API 接口）。</p>
<p>ElasticSearch 可以视为一个文档存储，它<strong>将复杂数据结构序列化为 JSON 存储</strong>。</p>
<p><strong>ElasticSearch 是近乎于实时的全文搜素</strong>，这是指：</p>
<ul>
<li>从写入数据到数据可以被搜索，存在较小的延迟（大概是 1s）</li>
<li>基于 ES 执行搜索和分析可以达到秒级</li>
</ul>
<h3 id="核心概念"><a class="markdownIt-Anchor" href="#核心概念"></a> 核心概念</h3>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">index -&gt;<span class="built_in"> type </span>-&gt; mapping -&gt; document -&gt; field</span><br></pre></td></tr></table></figure>
<h4 id="cluster"><a class="markdownIt-Anchor" href="#cluster"></a> Cluster</h4>
<p>集群包含多个节点，每个节点属于哪个集群都是通过一个配置来决定的，对于中小型应用来说，刚开始一个集群就一个节点很正常。</p>
<h4 id="node"><a class="markdownIt-Anchor" href="#node"></a> Node</h4>
<p>Node 是集群中的一个节点，节点也有一个名称，默认是随机分配的。默认节点会去加入一个名称为 <code>elasticsearch</code> 的集群。如果直接启动一堆节点，那么它们会自动组成一个 elasticsearch 集群，当然一个节点也可以组成 elasticsearch 集群。</p>
<h4 id="index"><a class="markdownIt-Anchor" href="#index"></a> Index</h4>
<p><strong>可以认为是文档（document）的优化集合。</strong></p>
<p>ES 会为所有字段建立索引，经过处理后写入一个反向索引（Inverted Index）。查找数据的时候，直接查找该索引。</p>
<p>所以，ES 数据管理的顶层单位就叫做 Index（索引）。它是单个数据库的同义词。每个 Index （即数据库）的名字必须是小写。</p>
<h4 id="type"><a class="markdownIt-Anchor" href="#type"></a> Type</h4>
<p>每个索引里可以有一个或者多个类型（type）。<code>类型（type）</code> 是 index 的一个逻辑分类。</p>
<p>不同的 Type 应该有相似的结构（schema），举例来说，<code>id</code>字段不能在这个组是字符串，在另一个组是数值。这是与关系型数据库的表的<a href="https://www.elastic.co/guide/en/elasticsearch/guide/current/mapping.html" target="_blank" rel="noopener">一个区别</a>。性质完全不同的数据（比如<code>products</code>和<code>logs</code>）应该存成两个 Index，而不是一个 Index 里面的两个 Type（虽然可以做到）。</p>
<blockquote>
<p>注意：根据<a href="https://www.elastic.co/blog/index-type-parent-child-join-now-future-in-elasticsearch" target="_blank" rel="noopener">规划</a>，Elastic 6.x 版只允许每个 Index 包含一个 Type，7.x 版将会彻底移除 Type。</p>
</blockquote>
<h4 id="document"><a class="markdownIt-Anchor" href="#document"></a> Document</h4>
<p>Index 里面单条的记录称为 Document（文档）。许多条 Document 构成了一个 Index。</p>
<p>每个 <strong><code>文档（document）</code></strong> 都是字段（field）的集合。</p>
<p>Document 使用 JSON 格式表示，下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">"user"</span>: <span class="string">"张三"</span>,</span><br><span class="line"><span class="string">"title"</span>: <span class="string">"工程师"</span>,</span><br><span class="line"><span class="string">"desc"</span>: <span class="string">"数据库管理"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同一个 Index 里面的 Document，不要求有相同的结构（scheme），但是最好保持相同，这样有利于提高搜索效率。</p>
<h4 id="field"><a class="markdownIt-Anchor" href="#field"></a> Field</h4>
<p><strong><code>字段（field）</code></strong> 是包含数据的键值对。</p>
<p>默认情况下，Elasticsearch 对每个字段中的所有数据建立索引，并且每个索引字段都具有专用的优化数据结构。</p>
<h4 id="shard"><a class="markdownIt-Anchor" href="#shard"></a> Shard</h4>
<p>当单台机器不足以存储大量数据时，Elasticsearch 可以将一个索引中的数据切分为多个 <strong><code>分片（shard）</code></strong> 。 <strong><code>分片（shard）</code></strong> 分布在多台服务器上存储。有了 shard 就可以横向扩展，存储更多数据，让搜索和分析等操作分布到多台服务器上去执行，提升吞吐量和性能。每个 shard 都是一个 lucene index。</p>
<h4 id="replica"><a class="markdownIt-Anchor" href="#replica"></a> Replica</h4>
<p>任何一个服务器随时可能故障或宕机，此时 shard 可能就会丢失，因此可以为每个 shard 创建多个 <strong><code>副本（replica）</code></strong>。replica 可以在 shard 故障时提供备用服务，保证数据不丢失，多个 replica 还可以提升搜索操作的吞吐量和性能。primary shard（建立索引时一次设置，不能修改，默认 5 个），replica shard（随时修改数量，默认 1 个），默认每个索引 10 个 shard，5 个 primary shard，5 个 replica shard，最小的高可用配置，是 2 台服务器。</p>
<h4 id="es-核心概念-vs-db-核心概念"><a class="markdownIt-Anchor" href="#es-核心概念-vs-db-核心概念"></a> ES 核心概念 vs. DB 核心概念</h4>
<table>
<thead>
<tr>
<th>ES</th>
<th>DB</th>
</tr>
</thead>
<tbody>
<tr>
<td>index</td>
<td>数据库</td>
</tr>
<tr>
<td>type</td>
<td>数据表</td>
</tr>
<tr>
<td>docuemnt</td>
<td>一行数据</td>
</tr>
</tbody>
</table>
<h2 id="二-elasticsearch-基本原理"><a class="markdownIt-Anchor" href="#二-elasticsearch-基本原理"></a> 二、ElasticSearch 基本原理</h2>
<h3 id="es-写数据过程"><a class="markdownIt-Anchor" href="#es-写数据过程"></a> ES 写数据过程</h3>
<ul>
<li>客户端选择一个 node 发送请求过去，这个 node 就是 <code>coordinating node</code>（协调节点）。</li>
<li><code>coordinating node</code> 对 document 进行<strong>路由</strong>，将请求转发给对应的 node（有 primary shard）。</li>
<li>实际的 node 上的 <code>primary shard</code> 处理请求，然后将数据同步到 <code>replica node</code>。</li>
<li><code>coordinating node</code> 如果发现 <code>primary node</code> 和所有 <code>replica node</code> 都搞定之后，就返回响应结果给客户端。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20210712104055.png" alt="img" /></p>
<h3 id="es-读数据过程"><a class="markdownIt-Anchor" href="#es-读数据过程"></a> ES 读数据过程</h3>
<p>可以通过 <code>doc id</code> 来查询，会根据 <code>doc id</code> 进行 hash，判断出来当时把 <code>doc id</code> 分配到了哪个 shard 上面去，从那个 shard 去查询。</p>
<ul>
<li>客户端发送请求到<strong>任意</strong>一个 node，成为 <code>coordinate node</code>。</li>
<li><code>coordinate node</code> 对 <code>doc id</code> 进行哈希路由，将请求转发到对应的 node，此时会使用 <code>round-robin</code> <strong>轮询算法</strong>，在 <code>primary shard</code> 以及其所有 replica 中随机选择一个，让读请求负载均衡。</li>
<li>接收请求的 node 返回 document 给 <code>coordinate node</code>。</li>
<li><code>coordinate node</code> 返回 document 给客户端。</li>
</ul>
<h3 id="es-搜索数据过程"><a class="markdownIt-Anchor" href="#es-搜索数据过程"></a> es 搜索数据过程</h3>
<p>es 最强大的是做全文检索，就是比如你有三条数据：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">java真好玩儿啊</span></span><br><span class="line"><span class="keyword">java好难学啊</span></span><br><span class="line"><span class="keyword">j2ee特别牛</span></span><br></pre></td></tr></table></figure>
<p>你根据 <code>java</code> 关键词来搜索，将包含 <code>java</code> 的 <code>document</code> 给搜索出来。es 就会给你返回：java 真好玩儿啊，java 好难学啊。</p>
<ul>
<li>客户端发送请求到一个 <code>coordinate node</code> 。</li>
<li>协调节点将搜索请求转发到<strong>所有</strong>的 shard 对应的 <code>primary shard</code> 或 <code>replica shard</code> ，都可以。</li>
<li>query phase：每个 shard 将自己的搜索结果（其实就是一些 <code>doc id</code> ）返回给协调节点，由协调节点进行数据的合并、排序、分页等操作，产出最终结果。</li>
<li>fetch phase：接着由协调节点根据 <code>doc id</code> 去各个节点上<strong>拉取实际</strong>的 <code>document</code> 数据，最终返回给客户端。</li>
</ul>
<blockquote>
<p>写请求是写入 primary shard，然后同步给所有的 replica shard；读请求可以从 primary shard 或 replica shard 读取，采用的是随机轮询算法。</p>
</blockquote>
<h3 id="写数据底层原理"><a class="markdownIt-Anchor" href="#写数据底层原理"></a> 写数据底层原理</h3>
<p><a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/images/es-write-detail.png" target="_blank" rel="noopener"><img src="https://github.com/doocs/advanced-java/raw/master/docs/high-concurrency/images/es-write-detail.png" alt="es-write-detail" /></a></p>
<p>先写入内存 buffer，在 buffer 里的时候数据是搜索不到的；同时将数据写入 translog 日志文件。</p>
<p>如果 buffer 快满了，或者到一定时间，就会将内存 buffer 数据 <code>refresh</code> 到一个新的 <code>segment file</code> 中，但是此时数据不是直接进入 <code>segment file</code> 磁盘文件，而是先进入 <code>os cache</code> 。这个过程就是 <code>refresh</code>。</p>
<p>每隔 1 秒钟，es 将 buffer 中的数据写入一个<strong>新的</strong> <code>segment file</code>，每秒钟会产生一个<strong>新的磁盘文件</strong> <code>segment file</code>，这个 <code>segment file</code> 中就存储最近 1 秒内 buffer 中写入的数据。</p>
<p>但是如果 buffer 里面此时没有数据，那当然不会执行 refresh 操作，如果 buffer 里面有数据，默认 1 秒钟执行一次 refresh 操作，刷入一个新的 segment file 中。</p>
<p>操作系统里面，磁盘文件其实都有一个东西，叫做 <code>os cache</code>，即操作系统缓存，就是说数据写入磁盘文件之前，会先进入 <code>os cache</code>，先进入操作系统级别的一个内存缓存中去。只要 <code>buffer</code> 中的数据被 refresh 操作刷入 <code>os cache</code>中，这个数据就可以被搜索到了。</p>
<p>为什么叫 es 是<strong>准实时</strong>的？ <code>NRT</code>，全称 <code>near real-time</code>。默认是每隔 1 秒 refresh 一次的，所以 es 是准实时的，因为写入的数据 1 秒之后才能被看到。可以通过 es 的 <code>restful api</code> 或者 <code>java api</code>，<strong>手动</strong>执行一次 refresh 操作，就是手动将 buffer 中的数据刷入 <code>os cache</code>中，让数据立马就可以被搜索到。只要数据被输入 <code>os cache</code> 中，buffer 就会被清空了，因为不需要保留 buffer 了，数据在 translog 里面已经持久化到磁盘去一份了。</p>
<p>重复上面的步骤，新的数据不断进入 buffer 和 translog，不断将 <code>buffer</code> 数据写入一个又一个新的 <code>segment file</code> 中去，每次 <code>refresh</code> 完 buffer 清空，translog 保留。随着这个过程推进，translog 会变得越来越大。当 translog 达到一定长度的时候，就会触发 <code>commit</code> 操作。</p>
<p>commit 操作发生第一步，就是将 buffer 中现有数据 <code>refresh</code> 到 <code>os cache</code> 中去，清空 buffer。然后，将一个 <code>commit point</code> 写入磁盘文件，里面标识着这个 <code>commit point</code> 对应的所有 <code>segment file</code>，同时强行将 <code>os cache</code> 中目前所有的数据都 <code>fsync</code> 到磁盘文件中去。最后<strong>清空</strong> 现有 translog 日志文件，重启一个 translog，此时 commit 操作完成。</p>
<p>这个 commit 操作叫做 <code>flush</code>。默认 30 分钟自动执行一次 <code>flush</code>，但如果 translog 过大，也会触发 <code>flush</code>。flush 操作就对应着 commit 的全过程，我们可以通过 es api，手动执行 flush 操作，手动将 os cache 中的数据 fsync 强刷到磁盘上去。</p>
<p>translog 日志文件的作用是什么？你执行 commit 操作之前，数据要么是停留在 buffer 中，要么是停留在 os cache 中，无论是 buffer 还是 os cache 都是内存，一旦这台机器死了，内存中的数据就全丢了。所以需要将数据对应的操作写入一个专门的日志文件 <code>translog</code> 中，一旦此时机器宕机，再次重启的时候，es 会自动读取 translog 日志文件中的数据，恢复到内存 buffer 和 os cache 中去。</p>
<p>translog 其实也是先写入 os cache 的，默认每隔 5 秒刷一次到磁盘中去，所以默认情况下，可能有 5 秒的数据会仅仅停留在 buffer 或者 translog 文件的 os cache 中，如果此时机器挂了，会<strong>丢失</strong> 5 秒钟的数据。但是这样性能比较好，最多丢 5 秒的数据。也可以将 translog 设置成每次写操作必须是直接 <code>fsync</code> 到磁盘，但是性能会差很多。</p>
<p>实际上你在这里，如果面试官没有问你 es 丢数据的问题，你可以在这里给面试官炫一把，你说，其实 es 第一是准实时的，数据写入 1 秒后可以搜索到；可能会丢失数据的。有 5 秒的数据，停留在 buffer、translog os cache、segment file os cache 中，而不在磁盘上，此时如果宕机，会导致 5 秒的<strong>数据丢失</strong>。</p>
<p><strong>总结一下</strong>，数据先写入内存 buffer，然后每隔 1s，将数据 refresh 到 os cache，到了 os cache 数据就能被搜索到（所以我们才说 es 从写入到能被搜索到，中间有 1s 的延迟）。每隔 5s，将数据写入 translog 文件（这样如果机器宕机，内存数据全没，最多会有 5s 的数据丢失），translog 大到一定程度，或者默认每隔 30mins，会触发 commit 操作，将缓冲区的数据都 flush 到 segment file 磁盘文件中。</p>
<blockquote>
<p>数据写入 segment file 之后，同时就建立好了倒排索引。</p>
</blockquote>
<h3 id="删除更新数据底层原理"><a class="markdownIt-Anchor" href="#删除更新数据底层原理"></a> 删除/更新数据底层原理</h3>
<p>如果是删除操作，commit 的时候会生成一个 <code>.del</code> 文件，里面将某个 doc 标识为 <code>deleted</code> 状态，那么搜索的时候根据 <code>.del</code> 文件就知道这个 doc 是否被删除了。</p>
<p>如果是更新操作，就是将原来的 doc 标识为 <code>deleted</code> 状态，然后新写入一条数据。</p>
<p>buffer 每 refresh 一次，就会产生一个 <code>segment file</code>，所以默认情况下是 1 秒钟一个 <code>segment file</code>，这样下来 <code>segment file</code> 会越来越多，此时会定期执行 merge。每次 merge 的时候，会将多个 <code>segment file</code> 合并成一个，同时这里会将标识为 <code>deleted</code> 的 doc 给<strong>物理删除掉</strong>，然后将新的 <code>segment file</code> 写入磁盘，这里会写一个 <code>commit point</code>，标识所有新的 <code>segment file</code>，然后打开 <code>segment file</code> 供搜索使用，同时删除旧的 <code>segment file</code>。</p>
<h3 id="底层-lucene"><a class="markdownIt-Anchor" href="#底层-lucene"></a> 底层 lucene</h3>
<p>简单来说，lucene 就是一个 jar 包，里面包含了封装好的各种建立倒排索引的算法代码。我们用 Java 开发的时候，引入 lucene jar，然后基于 lucene 的 api 去开发就可以了。</p>
<p>通过 lucene，我们可以将已有的数据建立索引，lucene 会在本地磁盘上面，给我们组织索引的数据结构。</p>
<h3 id="倒排索引"><a class="markdownIt-Anchor" href="#倒排索引"></a> 倒排索引</h3>
<p>在搜索引擎中，每个文档都有一个对应的文档 ID，文档内容被表示为一系列关键词的集合。例如，文档 1 经过分词，提取了 20 个关键词，每个关键词都会记录它在文档中出现的次数和出现位置。</p>
<p>那么，倒排索引就是<strong>关键词到文档</strong> ID 的映射，每个关键词都对应着一系列的文件，这些文件中都出现了关键词。</p>
<p>举个栗子。</p>
<p>有以下文档：</p>
<table>
<thead>
<tr>
<th>DocId</th>
<th>Doc</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>谷歌地图之父跳槽 Facebook</td>
</tr>
<tr>
<td>2</td>
<td>谷歌地图之父加盟 Facebook</td>
</tr>
<tr>
<td>3</td>
<td>谷歌地图创始人拉斯离开谷歌加盟 Facebook</td>
</tr>
<tr>
<td>4</td>
<td>谷歌地图之父跳槽 Facebook 与 Wave 项目取消有关</td>
</tr>
<tr>
<td>5</td>
<td>谷歌地图之父拉斯加盟社交网站 Facebook</td>
</tr>
</tbody>
</table>
<p>对文档进行分词之后，得到以下<strong>倒排索引</strong>。</p>
<table>
<thead>
<tr>
<th>WordId</th>
<th>Word</th>
<th>DocIds</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>谷歌</td>
<td>1,2,3,4,5</td>
</tr>
<tr>
<td>2</td>
<td>地图</td>
<td>1,2,3,4,5</td>
</tr>
<tr>
<td>3</td>
<td>之父</td>
<td>1,2,4,5</td>
</tr>
<tr>
<td>4</td>
<td>跳槽</td>
<td>1,4</td>
</tr>
<tr>
<td>5</td>
<td>Facebook</td>
<td>1,2,3,4,5</td>
</tr>
<tr>
<td>6</td>
<td>加盟</td>
<td>2,3,5</td>
</tr>
<tr>
<td>7</td>
<td>创始人</td>
<td>3</td>
</tr>
<tr>
<td>8</td>
<td>拉斯</td>
<td>3,5</td>
</tr>
<tr>
<td>9</td>
<td>离开</td>
<td>3</td>
</tr>
<tr>
<td>10</td>
<td>与</td>
<td>4</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>另外，实用的倒排索引还可以记录更多的信息，比如文档频率信息，表示在文档集合中有多少个文档包含某个单词。</p>
<p>那么，有了倒排索引，搜索引擎可以很方便地响应用户的查询。比如用户输入查询 <code>Facebook</code>，搜索系统查找倒排索引，从中读出包含这个单词的文档，这些文档就是提供给用户的搜索结果。</p>
<p>要注意倒排索引的两个重要细节：</p>
<ul>
<li>倒排索引中的所有词项对应一个或多个文档；</li>
<li>倒排索引中的词项<strong>根据字典顺序升序排列</strong></li>
</ul>
<blockquote>
<p>上面只是一个简单的栗子，并没有严格按照字典顺序升序排列。</p>
</blockquote>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><strong>官方</strong>
<ul>
<li><a href="https://www.elastic.co/cn/products/elasticsearch" target="_blank" rel="noopener">Elasticsearch 官网</a></li>
<li><a href="https://github.com/elastic/elasticsearch" target="_blank" rel="noopener">Elasticsearch Github</a></li>
<li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html" target="_blank" rel="noopener">Elasticsearch 官方文档</a></li>
</ul>
</li>
<li><strong>文章</strong>
<ul>
<li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/rpm.html#rpm" target="_blank" rel="noopener">Install Elasticsearch with RPM</a></li>
<li><a href="https://www.ruanyifeng.com/blog/2017/08/elasticsearch.html" target="_blank" rel="noopener">https://www.ruanyifeng.com/blog/2017/08/elasticsearch.html</a></li>
<li><a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/es-introduction.md" target="_blank" rel="noopener">es-introduction</a></li>
<li><a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/es-write-query-search.md" target="_blank" rel="noopener">es-write-query-search</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/2020/06/16/elasticsearch-rest-api/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2020/06/16/elasticsearch-rest-api/" class="post-title-link" itemprop="url">Elasticsearch Rest API</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-16 07:10:44" itemprop="dateCreated datePublished" datetime="2020-06-16T07:10:44+08:00">2020-06-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-14 16:45:53" itemprop="dateModified" datetime="2022-04-14T16:45:53+08:00">2022-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">搜索引擎数据库</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E5%BA%93/Elasticsearch/" itemprop="url" rel="index">
                    <span itemprop="name">Elasticsearch</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2020/06/16/elasticsearch-rest-api/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/06/16/elasticsearch-rest-api/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>15k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>13 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="elasticsearch-rest-api"><a class="markdownIt-Anchor" href="#elasticsearch-rest-api"></a> ElasticSearch Rest API</h1>
<blockquote>
<p><strong><a href="https://github.com/elastic/elasticsearch" target="_blank" rel="noopener">Elasticsearch</a> 是一个分布式、RESTful 风格的搜索和数据分析引擎</strong>，能够解决不断涌现出的各种用例。 作为 Elastic Stack 的核心，它集中存储您的数据，帮助您发现意料之中以及意料之外的情况。</p>
<p><a href="https://github.com/elastic/elasticsearch" target="_blank" rel="noopener">Elasticsearch</a> 基于搜索库 <a href="https://github.com/apache/lucene-solr" target="_blank" rel="noopener">Lucene</a> 开发。ElasticSearch 隐藏了 Lucene 的复杂性，提供了简单易用的 REST API / Java API 接口（另外还有其他语言的 API 接口）。</p>
<p><em>以下简称 ES</em>。</p>
<p>REST API 最详尽的文档应该参考：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/rest-apis.html" target="_blank" rel="noopener">ES 官方 REST API</a></p>
</blockquote>
<h2 id="1-elasticsearch-rest-api-语法格式"><a class="markdownIt-Anchor" href="#1-elasticsearch-rest-api-语法格式"></a> 1. ElasticSearch Rest API 语法格式</h2>
<p>向 Elasticsearch 发出的请求的组成部分与其它普通的 HTTP 请求是一样的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X&lt;VERB&gt; <span class="string">'&lt;PROTOCOL&gt;://&lt;HOST&gt;:&lt;PORT&gt;/&lt;PATH&gt;?&lt;QUERY_STRING&gt;'</span> -d <span class="string">'&lt;BODY&gt;'</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>VERB</code>：HTTP 方法，支持：<code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>HEAD</code>, <code>DELETE</code></li>
<li><code>PROTOCOL</code>：http 或者 https 协议（只有在 Elasticsearch 前面有 https 代理的时候可用）</li>
<li><code>HOST</code>：Elasticsearch 集群中的任何一个节点的主机名，如果是在本地的节点，那么就叫 localhost</li>
<li><code>PORT</code>：Elasticsearch HTTP 服务所在的端口，默认为 9200 PATH API 路径（例如_count 将返回集群中文档的数量），</li>
<li><code>PATH</code>：可以包含多个组件，例如 <code>_cluster/stats</code> 或者 <code>_nodes/stats/jvm</code></li>
<li><code>QUERY_STRING</code>：一些可选的查询请求参数，例如?pretty 参数将使请求返回更加美观易读的 JSON 数据</li>
<li><code>BODY</code>：一个 JSON 格式的请求主体（如果请求需要的话）</li>
</ul>
<h2 id="2-索引-api"><a class="markdownIt-Anchor" href="#2-索引-api"></a> 2. 索引 API</h2>
<blockquote>
<p>参考资料：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/cat-indices.html" target="_blank" rel="noopener">Elasticsearch 官方之 cat 索引 API</a></p>
</blockquote>
<h3 id="21-创建索引"><a class="markdownIt-Anchor" href="#21-创建索引"></a> 2.1. 创建索引</h3>
<p>新建 Index，可以直接向 ES 服务器发出 <code>PUT</code> 请求。</p>
<p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"settings"</span>: &#123; ... any settings ... &#125;,</span><br><span class="line">    <span class="string">"mappings"</span>: &#123;</span><br><span class="line">        <span class="string">"type_one"</span>: &#123; ... any mappings ... &#125;,</span><br><span class="line">        <span class="string">"type_two"</span>: &#123; ... any mappings ... &#125;,</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT /user</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"settings"</span>: &#123;</span><br><span class="line">    <span class="string">"index"</span>: &#123;</span><br><span class="line">      <span class="string">"number_of_shards"</span>: 3,</span><br><span class="line">      <span class="string">"number_of_replicas"</span>: 2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务器返回一个 JSON 对象，里面的 <code>acknowledged</code> 字段表示操作成功。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">"acknowledged"</span>:<span class="literal">true</span>,<span class="string">"shards_acknowledged"</span>:<span class="literal">true</span>,<span class="string">"index"</span>:<span class="string">"user"</span>&#125;</span><br></pre></td></tr></table></figure>
<p>如果你想禁止自动创建索引，可以通过在 <code>config/elasticsearch.yml</code> 的每个节点下添加下面的配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">action.auto_create_index: <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h3 id="22-删除索引"><a class="markdownIt-Anchor" href="#22-删除索引"></a> 2.2. 删除索引</h3>
<p>然后，我们可以通过发送 <code>DELETE</code> 请求，删除这个 Index。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">DELETE /user</span><br></pre></td></tr></table></figure>
<p>删除多个索引</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">DELETE /index_one,index_two</span><br><span class="line">DELETE /index_*</span><br></pre></td></tr></table></figure>
<h3 id="23-查看索引"><a class="markdownIt-Anchor" href="#23-查看索引"></a> 2.3. 查看索引</h3>
<p>可以通过 GET 请求查看索引信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看索引相关信息</span></span><br><span class="line">GET kibana_sample_data_ecommerce</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看索引的文档总数</span></span><br><span class="line">GET kibana_sample_data_ecommerce/_count</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看前10条文档，了解文档格式</span></span><br><span class="line">GET kibana_sample_data_ecommerce/_search</span><br><span class="line"></span><br><span class="line"><span class="comment"># _cat indices API</span></span><br><span class="line"><span class="comment"># 查看indices</span></span><br><span class="line">GET /_cat/indices/kibana*?v&amp;s=index</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看状态为绿的索引</span></span><br><span class="line">GET /_cat/indices?v&amp;health=green</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照文档个数排序</span></span><br><span class="line">GET /_cat/indices?v&amp;s=docs.count:desc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看具体的字段</span></span><br><span class="line">GET /_cat/indices/kibana*?pri&amp;v&amp;h=health,index,pri,rep,docs.count,mt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看索引占用的内存</span></span><br><span class="line">GET /_cat/indices?v&amp;h=i,tm&amp;s=tm:desc</span><br></pre></td></tr></table></figure>
<h3 id="24-索引别名"><a class="markdownIt-Anchor" href="#24-索引别名"></a> 2.4. 索引别名</h3>
<p>ES 的索引别名就是给一个索引或者多个索引起的另一个名字，典型的应用场景是针对索引使用的平滑切换。</p>
<p>首先，创建索引 my_index，然后将别名 my_alias 指向它，示例如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">PUT /my_index/_alias/my_alias</span><br></pre></td></tr></table></figure>
<p>也可以通过如下形式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">POST /_aliases</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"actions"</span>: [</span><br><span class="line">    &#123; <span class="string">"add"</span>: &#123; <span class="string">"index"</span>: <span class="string">"my_index"</span>, <span class="string">"alias"</span>: <span class="string">"my_alias"</span> &#125;&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以在一次请求中增加别名和移除别名混合使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">POST /_aliases</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"actions"</span>: [</span><br><span class="line">    &#123; <span class="string">"remove"</span>: &#123; <span class="string">"index"</span>: <span class="string">"my_index"</span>, <span class="string">"alias"</span>: <span class="string">"my_alias"</span> &#125;&#125;</span><br><span class="line">    &#123; <span class="string">"add"</span>: &#123; <span class="string">"index"</span>: <span class="string">"my_index_v2"</span>, <span class="string">"alias"</span>: <span class="string">"my_alias"</span> &#125;&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是，如果别名与索引是一对一的，使用别名索引文档或者查询文档是可以的，但是如果别名和索引是一对多的，使用别名会发生错误，因为 ES 不知道把文档写入哪个索引中去或者从哪个索引中读取文档。</p>
</blockquote>
<p>ES 索引别名有个典型的应用场景是平滑切换，更多细节可以查看 <a href="https://www.knowledgedict.com/tutorial/elasticsearch-index-smooth-shift.html" target="_blank" rel="noopener">Elasticsearch（ES）索引零停机（无需重启）无缝平滑切换的方法</a>。</p>
<h3 id="25-打开关闭索引"><a class="markdownIt-Anchor" href="#25-打开关闭索引"></a> 2.5. 打开/关闭索引</h3>
<p>通过在 <code>POST</code> 中添加 <code>_close</code> 或 <code>_open</code> 可以打开、关闭索引。</p>
<p>打开索引</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打开索引</span></span><br><span class="line">POST kibana_sample_data_ecommerce/_open</span><br><span class="line"><span class="comment"># 关闭索引</span></span><br><span class="line">POST kibana_sample_data_ecommerce/_close</span><br></pre></td></tr></table></figure>
<h2 id="3-文档"><a class="markdownIt-Anchor" href="#3-文档"></a> 3. 文档</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">############Create Document############</span></span><br><span class="line"><span class="comment">#create document. 自动生成 _id</span></span><br><span class="line">POST users/_doc</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">"user"</span> : <span class="string">"Mike"</span>,</span><br><span class="line">    <span class="string">"post_date"</span> : <span class="string">"2019-04-15T14:12:12"</span>,</span><br><span class="line">    <span class="string">"message"</span> : <span class="string">"trying out Kibana"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#create document. 指定Id。如果id已经存在，报错</span></span><br><span class="line">PUT users/_doc/1?op_type=create</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"user"</span> : <span class="string">"Jack"</span>,</span><br><span class="line">    <span class="string">"post_date"</span> : <span class="string">"2019-05-15T14:12:12"</span>,</span><br><span class="line">    <span class="string">"message"</span> : <span class="string">"trying out Elasticsearch"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#create document. 指定 ID 如果已经存在，就报错</span></span><br><span class="line">PUT users/_create/1</span><br><span class="line">&#123;</span><br><span class="line">     <span class="string">"user"</span> : <span class="string">"Jack"</span>,</span><br><span class="line">    <span class="string">"post_date"</span> : <span class="string">"2019-05-15T14:12:12"</span>,</span><br><span class="line">    <span class="string">"message"</span> : <span class="string">"trying out Elasticsearch"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">### Get Document by ID</span></span><br><span class="line"><span class="comment">#Get the document by ID</span></span><br><span class="line">GET users/_doc/1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">###  Index &amp; Update</span></span><br><span class="line"><span class="comment">#Update 指定 ID  (先删除，在写入)</span></span><br><span class="line">GET users/_doc/1</span><br><span class="line"></span><br><span class="line">PUT users/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">"user"</span> : <span class="string">"Mike"</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#GET users/_doc/1</span></span><br><span class="line"><span class="comment">#在原文档上增加字段</span></span><br><span class="line">POST users/_update/1/</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"doc"</span>:&#123;</span><br><span class="line">        <span class="string">"post_date"</span> : <span class="string">"2019-05-15T14:12:12"</span>,</span><br><span class="line">        <span class="string">"message"</span> : <span class="string">"trying out Elasticsearch"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### Delete by Id</span></span><br><span class="line"><span class="comment"># 删除文档</span></span><br><span class="line">DELETE users/_doc/1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### Bulk 操作</span></span><br><span class="line"><span class="comment">#执行两次，查看每次的结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#执行第1次</span></span><br><span class="line">POST _bulk</span><br><span class="line">&#123; <span class="string">"index"</span> : &#123; <span class="string">"_index"</span> : <span class="string">"test"</span>, <span class="string">"_id"</span> : <span class="string">"1"</span> &#125; &#125;</span><br><span class="line">&#123; <span class="string">"field1"</span> : <span class="string">"value1"</span> &#125;</span><br><span class="line">&#123; <span class="string">"delete"</span> : &#123; <span class="string">"_index"</span> : <span class="string">"test"</span>, <span class="string">"_id"</span> : <span class="string">"2"</span> &#125; &#125;</span><br><span class="line">&#123; <span class="string">"create"</span> : &#123; <span class="string">"_index"</span> : <span class="string">"test2"</span>, <span class="string">"_id"</span> : <span class="string">"3"</span> &#125; &#125;</span><br><span class="line">&#123; <span class="string">"field1"</span> : <span class="string">"value3"</span> &#125;</span><br><span class="line">&#123; <span class="string">"update"</span> : &#123;<span class="string">"_id"</span> : <span class="string">"1"</span>, <span class="string">"_index"</span> : <span class="string">"test"</span>&#125; &#125;</span><br><span class="line">&#123; <span class="string">"doc"</span> : &#123;<span class="string">"field2"</span> : <span class="string">"value2"</span>&#125; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#执行第2次</span></span><br><span class="line">POST _bulk</span><br><span class="line">&#123; <span class="string">"index"</span> : &#123; <span class="string">"_index"</span> : <span class="string">"test"</span>, <span class="string">"_id"</span> : <span class="string">"1"</span> &#125; &#125;</span><br><span class="line">&#123; <span class="string">"field1"</span> : <span class="string">"value1"</span> &#125;</span><br><span class="line">&#123; <span class="string">"delete"</span> : &#123; <span class="string">"_index"</span> : <span class="string">"test"</span>, <span class="string">"_id"</span> : <span class="string">"2"</span> &#125; &#125;</span><br><span class="line">&#123; <span class="string">"create"</span> : &#123; <span class="string">"_index"</span> : <span class="string">"test2"</span>, <span class="string">"_id"</span> : <span class="string">"3"</span> &#125; &#125;</span><br><span class="line">&#123; <span class="string">"field1"</span> : <span class="string">"value3"</span> &#125;</span><br><span class="line">&#123; <span class="string">"update"</span> : &#123;<span class="string">"_id"</span> : <span class="string">"1"</span>, <span class="string">"_index"</span> : <span class="string">"test"</span>&#125; &#125;</span><br><span class="line">&#123; <span class="string">"doc"</span> : &#123;<span class="string">"field2"</span> : <span class="string">"value2"</span>&#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">### mget 操作</span></span><br><span class="line">GET /_mget</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"docs"</span> : [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"_index"</span> : <span class="string">"test"</span>,</span><br><span class="line">            <span class="string">"_id"</span> : <span class="string">"1"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"_index"</span> : <span class="string">"test"</span>,</span><br><span class="line">            <span class="string">"_id"</span> : <span class="string">"2"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#URI中指定index</span></span><br><span class="line">GET /<span class="built_in">test</span>/_mget</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"docs"</span> : [</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="string">"_id"</span> : <span class="string">"1"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="string">"_id"</span> : <span class="string">"2"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GET /_mget</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"docs"</span> : [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"_index"</span> : <span class="string">"test"</span>,</span><br><span class="line">            <span class="string">"_id"</span> : <span class="string">"1"</span>,</span><br><span class="line">            <span class="string">"_source"</span> : <span class="literal">false</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"_index"</span> : <span class="string">"test"</span>,</span><br><span class="line">            <span class="string">"_id"</span> : <span class="string">"2"</span>,</span><br><span class="line">            <span class="string">"_source"</span> : [<span class="string">"field3"</span>, <span class="string">"field4"</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"_index"</span> : <span class="string">"test"</span>,</span><br><span class="line">            <span class="string">"_id"</span> : <span class="string">"3"</span>,</span><br><span class="line">            <span class="string">"_source"</span> : &#123;</span><br><span class="line">                <span class="string">"include"</span>: [<span class="string">"user"</span>],</span><br><span class="line">                <span class="string">"exclude"</span>: [<span class="string">"user.location"</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">### msearch 操作</span></span><br><span class="line">POST kibana_sample_data_ecommerce/_msearch</span><br><span class="line">&#123;&#125;</span><br><span class="line">&#123;<span class="string">"query"</span> : &#123;<span class="string">"match_all"</span> : &#123;&#125;&#125;,<span class="string">"size"</span>:1&#125;</span><br><span class="line">&#123;<span class="string">"index"</span> : <span class="string">"kibana_sample_data_flights"</span>&#125;</span><br><span class="line">&#123;<span class="string">"query"</span> : &#123;<span class="string">"match_all"</span> : &#123;&#125;&#125;,<span class="string">"size"</span>:2&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 清除测试数据</span></span><br><span class="line"><span class="comment">#清除数据</span></span><br><span class="line">DELETE users</span><br><span class="line">DELETE <span class="built_in">test</span></span><br><span class="line">DELETE test2</span><br></pre></td></tr></table></figure>
<h3 id="31-创建文档"><a class="markdownIt-Anchor" href="#31-创建文档"></a> 3.1. 创建文档</h3>
<h4 id="指定-id"><a class="markdownIt-Anchor" href="#指定-id"></a> 指定 ID</h4>
<p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT /_index/_type/_create/_id</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT /user/_doc/_create/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"user"</span>: <span class="string">"张三"</span>,</span><br><span class="line">  <span class="string">"title"</span>: <span class="string">"工程师"</span>,</span><br><span class="line">  <span class="string">"desc"</span>: <span class="string">"数据库管理"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：指定 Id，如果 id 已经存在，则报错</p>
</blockquote>
<h4 id="自动生成-id"><a class="markdownIt-Anchor" href="#自动生成-id"></a> 自动生成 ID</h4>
<p>新增记录的时候，也可以不指定 Id，这时要改成 POST 请求。</p>
<p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">POST /_index/_type</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">POST /user/_doc</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"user"</span>: <span class="string">"张三"</span>,</span><br><span class="line">  <span class="string">"title"</span>: <span class="string">"工程师"</span>,</span><br><span class="line">  <span class="string">"desc"</span>: <span class="string">"超级管理员"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="32-删除文档"><a class="markdownIt-Anchor" href="#32-删除文档"></a> 3.2. 删除文档</h3>
<p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">DELETE /_index/_doc/_id</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">DELETE /user/_doc/1</span><br></pre></td></tr></table></figure>
<h3 id="33-更新文档"><a class="markdownIt-Anchor" href="#33-更新文档"></a> 3.3. 更新文档</h3>
<h4 id="先删除再写入"><a class="markdownIt-Anchor" href="#先删除再写入"></a> 先删除，再写入</h4>
<p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT /_index/_type/_id</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT /user/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"user"</span>: <span class="string">"李四"</span>,</span><br><span class="line">  <span class="string">"title"</span>: <span class="string">"工程师"</span>,</span><br><span class="line">  <span class="string">"desc"</span>: <span class="string">"超级管理员"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="在原文档上增加字段"><a class="markdownIt-Anchor" href="#在原文档上增加字段"></a> 在原文档上增加字段</h4>
<p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">POST /_index/_update/_id</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">POST /user/_update/1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"doc"</span>:&#123;</span><br><span class="line">        <span class="string">"age"</span> : <span class="string">"30"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="34-查询文档"><a class="markdownIt-Anchor" href="#34-查询文档"></a> 3.4. 查询文档</h3>
<h4 id="指定-id-查询"><a class="markdownIt-Anchor" href="#指定-id-查询"></a> 指定 ID 查询</h4>
<p>语法格式：</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">GET /<span class="variable">_index</span>/<span class="variable">_type</span>/<span class="variable">_id</span></span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET /user/_doc/1</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"_index"</span>: <span class="string">"user"</span>,</span><br><span class="line">  <span class="attr">"_type"</span>: <span class="string">"_doc"</span>,</span><br><span class="line">  <span class="attr">"_id"</span>: <span class="string">"1"</span>,</span><br><span class="line">  <span class="attr">"_version"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"_seq_no"</span>: <span class="number">536248</span>,</span><br><span class="line">  <span class="attr">"_primary_term"</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">"found"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"_source"</span>: &#123;</span><br><span class="line">    <span class="attr">"user"</span>: <span class="string">"张三"</span>,</span><br><span class="line">    <span class="attr">"title"</span>: <span class="string">"工程师"</span>,</span><br><span class="line">    <span class="attr">"desc"</span>: <span class="string">"数据库管理"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回的数据中，<code>found</code> 字段表示查询成功，<code>_source</code> 字段返回原始记录。</p>
<p>如果 id 不正确，就查不到数据，<code>found</code> 字段就是 <code>false</code></p>
<h4 id="查询所有记录"><a class="markdownIt-Anchor" href="#查询所有记录"></a> 查询所有记录</h4>
<p>使用 <code>GET</code> 方法，直接请求 <code>/index/type/_search</code>，就会返回所有记录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl <span class="string">'localhost:9200/user/admin/_search?pretty'</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"took"</span> : 1,</span><br><span class="line">  <span class="string">"timed_out"</span> : <span class="literal">false</span>,</span><br><span class="line">  <span class="string">"_shards"</span> : &#123;</span><br><span class="line">    <span class="string">"total"</span> : 3,</span><br><span class="line">    <span class="string">"successful"</span> : 3,</span><br><span class="line">    <span class="string">"skipped"</span> : 0,</span><br><span class="line">    <span class="string">"failed"</span> : 0</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"hits"</span> : &#123;</span><br><span class="line">    <span class="string">"total"</span> : 2,</span><br><span class="line">    <span class="string">"max_score"</span> : 1.0,</span><br><span class="line">    <span class="string">"hits"</span> : [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"_index"</span> : <span class="string">"user"</span>,</span><br><span class="line">        <span class="string">"_type"</span> : <span class="string">"admin"</span>,</span><br><span class="line">        <span class="string">"_id"</span> : <span class="string">"WWuoDG8BHwECs7SiYn93"</span>,</span><br><span class="line">        <span class="string">"_score"</span> : 1.0,</span><br><span class="line">        <span class="string">"_source"</span> : &#123;</span><br><span class="line">          <span class="string">"user"</span> : <span class="string">"李四"</span>,</span><br><span class="line">          <span class="string">"title"</span> : <span class="string">"工程师"</span>,</span><br><span class="line">          <span class="string">"desc"</span> : <span class="string">"系统管理"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"_index"</span> : <span class="string">"user"</span>,</span><br><span class="line">        <span class="string">"_type"</span> : <span class="string">"admin"</span>,</span><br><span class="line">        <span class="string">"_id"</span> : <span class="string">"1"</span>,</span><br><span class="line">        <span class="string">"_score"</span> : 1.0,</span><br><span class="line">        <span class="string">"_source"</span> : &#123;</span><br><span class="line">          <span class="string">"user"</span> : <span class="string">"张三"</span>,</span><br><span class="line">          <span class="string">"title"</span> : <span class="string">"工程师"</span>,</span><br><span class="line">          <span class="string">"desc"</span> : <span class="string">"超级管理员"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，返回结果的 <code>took</code>字段表示该操作的耗时（单位为毫秒），<code>timed_out</code>字段表示是否超时，<code>hits</code>字段表示命中的记录，里面子字段的含义如下。</p>
<ul>
<li><code>total</code>：返回记录数，本例是 2 条。</li>
<li><code>max_score</code>：最高的匹配程度，本例是<code>1.0</code>。</li>
<li><code>hits</code>：返回的记录组成的数组。</li>
</ul>
<p>返回的记录中，每条记录都有一个<code>_score</code>字段，表示匹配的程序，默认是按照这个字段降序排列。</p>
<h3 id="35-全文搜索"><a class="markdownIt-Anchor" href="#35-全文搜索"></a> 3.5. 全文搜索</h3>
<p>ES 的查询非常特别，使用自己的<a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.5/query-dsl.html" target="_blank" rel="noopener">查询语法</a>，要求 GET 请求带有数据体。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -H <span class="string">'Content-Type: application/json'</span> <span class="string">'localhost:9200/user/admin/_search?pretty'</span>  -d <span class="string">'</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">"query" : &#123; "match" : &#123; "desc" : "管理" &#125;&#125;</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure>
<p>上面代码使用 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.5/query-dsl-match-query.html" target="_blank" rel="noopener">Match 查询</a>，指定的匹配条件是<code>desc</code>字段里面包含&quot;软件&quot;这个词。返回结果如下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"took"</span> : <span class="number">2</span>,</span><br><span class="line">  <span class="string">"timed_out"</span> : <span class="literal">false</span>,</span><br><span class="line">  <span class="string">"_shards"</span> : &#123;</span><br><span class="line">    <span class="string">"total"</span> : <span class="number">3</span>,</span><br><span class="line">    <span class="string">"successful"</span> : <span class="number">3</span>,</span><br><span class="line">    <span class="string">"skipped"</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="string">"failed"</span> : <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"hits"</span> : &#123;</span><br><span class="line">    <span class="string">"total"</span> : <span class="number">2</span>,</span><br><span class="line">    <span class="string">"max_score"</span> : <span class="number">0.38200712</span>,</span><br><span class="line">    <span class="string">"hits"</span> : [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"_index"</span> : <span class="string">"user"</span>,</span><br><span class="line">        <span class="string">"_type"</span> : <span class="string">"admin"</span>,</span><br><span class="line">        <span class="string">"_id"</span> : <span class="string">"WWuoDG8BHwECs7SiYn93"</span>,</span><br><span class="line">        <span class="string">"_score"</span> : <span class="number">0.38200712</span>,</span><br><span class="line">        <span class="string">"_source"</span> : &#123;</span><br><span class="line">          <span class="string">"user"</span> : <span class="string">"李四"</span>,</span><br><span class="line">          <span class="string">"title"</span> : <span class="string">"工程师"</span>,</span><br><span class="line">          <span class="string">"desc"</span> : <span class="string">"系统管理"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"_index"</span> : <span class="string">"user"</span>,</span><br><span class="line">        <span class="string">"_type"</span> : <span class="string">"admin"</span>,</span><br><span class="line">        <span class="string">"_id"</span> : <span class="string">"1"</span>,</span><br><span class="line">        <span class="string">"_score"</span> : <span class="number">0.3487891</span>,</span><br><span class="line">        <span class="string">"_source"</span> : &#123;</span><br><span class="line">          <span class="string">"user"</span> : <span class="string">"张三"</span>,</span><br><span class="line">          <span class="string">"title"</span> : <span class="string">"工程师"</span>,</span><br><span class="line">          <span class="string">"desc"</span> : <span class="string">"超级管理员"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Elastic 默认一次返回 10 条结果，可以通过<code>size</code>字段改变这个设置，还可以通过<code>from</code>字段，指定位移。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl <span class="string">'localhost:9200/user/admin/_search'</span>  -d <span class="string">'</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  "query" : &#123; "match" : &#123; "desc" : "管理" &#125;&#125;,</span></span><br><span class="line"><span class="string">  "from": 1,</span></span><br><span class="line"><span class="string">  "size": 1</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure>
<p>上面代码指定，从位置 1 开始（默认是从位置 0 开始），只返回一条结果。</p>
<h3 id="36-逻辑运算"><a class="markdownIt-Anchor" href="#36-逻辑运算"></a> 3.6. 逻辑运算</h3>
<p>如果有多个搜索关键字， Elastic 认为它们是<code>or</code>关系。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl <span class="string">'localhost:9200/user/admin/_search'</span>  -d <span class="string">'</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">"query" : &#123; "match" : &#123; "desc" : "软件 系统" &#125;&#125;</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure>
<p>上面代码搜索的是<code>软件 or 系统</code>。</p>
<p>如果要执行多个关键词的<code>and</code>搜索，必须使用<a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.5/query-dsl-bool-query.html" target="_blank" rel="noopener">布尔查询</a>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -H <span class="string">'Content-Type: application/json'</span> <span class="string">'localhost:9200/user/admin/_search?pretty'</span>  -d <span class="string">'</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string"> "query": &#123;</span></span><br><span class="line"><span class="string">  "bool": &#123;</span></span><br><span class="line"><span class="string">   "must": [</span></span><br><span class="line"><span class="string">    &#123; "match": &#123; "desc": "管理" &#125; &#125;,</span></span><br><span class="line"><span class="string">    &#123; "match": &#123; "desc": "超级" &#125; &#125;</span></span><br><span class="line"><span class="string">   ]</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"> &#125;</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure>
<h3 id="37-批量执行"><a class="markdownIt-Anchor" href="#37-批量执行"></a> 3.7. 批量执行</h3>
<p>支持在一次 API 调用中，对不同的索引进行操作</p>
<p>支持四种类型操作</p>
<ul>
<li>index</li>
<li>create</li>
<li>update</li>
<li>delete</li>
</ul>
<p>操作中单条操作失败，并不会影响其他操作。</p>
<p>返回结果包括了每一条操作执行的结果。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">POST _bulk</span><br><span class="line">&#123; <span class="string">"index"</span> : &#123; <span class="string">"_index"</span> : <span class="string">"test"</span>, <span class="string">"_id"</span> : <span class="string">"1"</span> &#125; &#125;</span><br><span class="line">&#123; <span class="string">"field1"</span> : <span class="string">"value1"</span> &#125;</span><br><span class="line">&#123; <span class="string">"delete"</span> : &#123; <span class="string">"_index"</span> : <span class="string">"test"</span>, <span class="string">"_id"</span> : <span class="string">"2"</span> &#125; &#125;</span><br><span class="line">&#123; <span class="string">"create"</span> : &#123; <span class="string">"_index"</span> : <span class="string">"test2"</span>, <span class="string">"_id"</span> : <span class="string">"3"</span> &#125; &#125;</span><br><span class="line">&#123; <span class="string">"field1"</span> : <span class="string">"value3"</span> &#125;</span><br><span class="line">&#123; <span class="string">"update"</span> : &#123;<span class="string">"_id"</span> : <span class="string">"1"</span>, <span class="string">"_index"</span> : <span class="string">"test"</span>&#125; &#125;</span><br><span class="line">&#123; <span class="string">"doc"</span> : &#123;<span class="string">"field2"</span> : <span class="string">"value2"</span>&#125; &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：上面的示例如果执行多次，执行结果都不一样。</p>
</blockquote>
<h3 id="38-批量读取"><a class="markdownIt-Anchor" href="#38-批量读取"></a> 3.8. 批量读取</h3>
<p>读多个索引</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET /_mget</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"docs"</span> : [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"_index"</span> : <span class="string">"test"</span>,</span><br><span class="line">            <span class="string">"_id"</span> : <span class="string">"1"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"_index"</span> : <span class="string">"test"</span>,</span><br><span class="line">            <span class="string">"_id"</span> : <span class="string">"2"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读一个索引</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET /<span class="built_in">test</span>/_mget</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"docs"</span> : [</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="string">"_id"</span> : <span class="string">"1"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="string">"_id"</span> : <span class="string">"2"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET /_mget</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"docs"</span> : [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"_index"</span> : <span class="string">"test"</span>,</span><br><span class="line">            <span class="string">"_id"</span> : <span class="string">"1"</span>,</span><br><span class="line">            <span class="string">"_source"</span> : <span class="literal">false</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"_index"</span> : <span class="string">"test"</span>,</span><br><span class="line">            <span class="string">"_id"</span> : <span class="string">"2"</span>,</span><br><span class="line">            <span class="string">"_source"</span> : [<span class="string">"field3"</span>, <span class="string">"field4"</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"_index"</span> : <span class="string">"test"</span>,</span><br><span class="line">            <span class="string">"_id"</span> : <span class="string">"3"</span>,</span><br><span class="line">            <span class="string">"_source"</span> : &#123;</span><br><span class="line">                <span class="string">"include"</span>: [<span class="string">"user"</span>],</span><br><span class="line">                <span class="string">"exclude"</span>: [<span class="string">"user.location"</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="39-批量查询"><a class="markdownIt-Anchor" href="#39-批量查询"></a> 3.9. 批量查询</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">POST kibana_sample_data_ecommerce/_msearch</span><br><span class="line">&#123;&#125;</span><br><span class="line">&#123;<span class="string">"query"</span> : &#123;<span class="string">"match_all"</span> : &#123;&#125;&#125;,<span class="string">"size"</span>:1&#125;</span><br><span class="line">&#123;<span class="string">"index"</span> : <span class="string">"kibana_sample_data_flights"</span>&#125;</span><br><span class="line">&#123;<span class="string">"query"</span> : &#123;<span class="string">"match_all"</span> : &#123;&#125;&#125;,<span class="string">"size"</span>:2&#125;</span><br></pre></td></tr></table></figure>
<h3 id="310-uri-search-查询语义"><a class="markdownIt-Anchor" href="#310-uri-search-查询语义"></a> 3.10. URI Search 查询语义</h3>
<p>Elasticsearch URI Search 遵循 QueryString 查询语义，其形式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET /movies/_search?q=2012&amp;df=title&amp;sort=year:desc&amp;from=0&amp;size=10&amp;timeout=1s</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">"profile"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>q</code></strong> 指定查询语句，使用 QueryString 语义</li>
<li><strong><code>df</code></strong> 默认字段，不指定时</li>
<li><strong><code>sort</code></strong> 排序：from 和 size 用于分页</li>
<li><strong><code>profile</code></strong> 可以查看查询时如何被执行的</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET /movies/_search?q=title:2012&amp;sort=year:desc&amp;from=0&amp;size=10&amp;timeout=1s</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">"profile"</span>:<span class="string">"true"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="term-和-phrase"><a class="markdownIt-Anchor" href="#term-和-phrase"></a> Term 和 Phrase</h4>
<p>Beautiful Mind 等效于 Beautiful OR Mind</p>
<p>“Beautiful Mind” 等效于 Beautiful AND Mind</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Term 查询</span></span><br><span class="line">GET /movies/_search?q=title:Beautiful Mind</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">"profile"</span>:<span class="string">"true"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用引号，Phrase 查询</span></span><br><span class="line">GET /movies/_search?q=title:<span class="string">"Beautiful Mind"</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">"profile"</span>:<span class="string">"true"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="分组与引号"><a class="markdownIt-Anchor" href="#分组与引号"></a> 分组与引号</h4>
<p>title:(Beautiful AND Mind)</p>
<p>title=“Beautiful Mind”</p>
<h4 id="and-or-not-或者"><a class="markdownIt-Anchor" href="#and-or-not-或者"></a> AND、OR、NOT 或者 &amp;&amp;、||、!</h4>
<blockquote>
<p>注意：AND、OR、NOT 必须大写</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 布尔操作符</span></span><br><span class="line">GET /movies/_search?q=title:(Beautiful AND Mind)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">"profile"</span>:<span class="string">"true"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET /movies/_search?q=title:(Beautiful NOT Mind)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">"profile"</span>:<span class="string">"true"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="范围查询"><a class="markdownIt-Anchor" href="#范围查询"></a> 范围查询</h4>
<ul>
<li><code>[]</code> 表示闭区间</li>
<li><code>{}</code> 表示开区间</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 范围查询 ,区间写法</span></span><br><span class="line">GET /movies/_search?q=title:beautiful AND year:&#123;2010 TO 2018%7D</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">"profile"</span>:<span class="string">"true"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET /movies/_search?q=title:beautiful AND year:[* TO 2018]</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">"profile"</span>:<span class="string">"true"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="算数符号"><a class="markdownIt-Anchor" href="#算数符号"></a> 算数符号</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 2010 年以后的记录</span></span><br><span class="line">GET /movies/_search?q=year:&gt;2010</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">"profile"</span>:<span class="string">"true"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2010 年到 2018 年的记录</span></span><br><span class="line">GET /movies/_search?q=year:(&gt;2010 &amp;&amp; &lt;=2018)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">"profile"</span>:<span class="string">"true"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2010 年到 2018 年的记录</span></span><br><span class="line">GET /movies/_search?q=year:(+&gt;2010 +&lt;=2018)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">"profile"</span>:<span class="string">"true"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="通配符查询"><a class="markdownIt-Anchor" href="#通配符查询"></a> 通配符查询</h4>
<ul>
<li><code>?</code> 代表 1 个字符</li>
<li><code>*</code> 代表 0 或多个字符</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET /movies/_search?q=title:mi?d</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">"profile"</span>:<span class="string">"true"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET /movies/_search?q=title:b*</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">"profile"</span>:<span class="string">"true"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="正则表达式"><a class="markdownIt-Anchor" href="#正则表达式"></a> 正则表达式</h4>
<p>title:[bt]oy</p>
<h4 id="模糊匹配与近似查询"><a class="markdownIt-Anchor" href="#模糊匹配与近似查询"></a> 模糊匹配与近似查询</h4>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 相似度在 1 个字符以内</span></span><br><span class="line">GET /movies/_search?q=title:beautifl~1</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">"profile"</span>:<span class="string">"true"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 相似度在 2 个字符以内</span></span><br><span class="line">GET /movies/_search?q=title:<span class="string">"Lord Rings"</span>~2</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">"profile"</span>:<span class="string">"true"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="311-request-body-dsl"><a class="markdownIt-Anchor" href="#311-request-body-dsl"></a> 3.11. Request Body &amp; DSL</h3>
<p>Elasticsearch 除了 URI Search 查询方式，还支持将查询语句通过 Http Request Body 发起查询。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET /kibana_sample_data_ecommerce/_search?ignore_unavailable=<span class="literal">true</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">"profile"</span>:<span class="string">"true"</span>,</span><br><span class="line">	<span class="string">"query"</span>: &#123;</span><br><span class="line">	  <span class="string">"match_all"</span>: &#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="分页"><a class="markdownIt-Anchor" href="#分页"></a> 分页</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET /kibana_sample_data_ecommerce/_search?ignore_unavailable=<span class="literal">true</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"profile"</span>: <span class="string">"true"</span>,</span><br><span class="line">  <span class="string">"from"</span>: 0,</span><br><span class="line">  <span class="string">"size"</span>: 10,</span><br><span class="line">  <span class="string">"query"</span>: &#123;</span><br><span class="line">    <span class="string">"match_all"</span>: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="排序"><a class="markdownIt-Anchor" href="#排序"></a> 排序</h4>
<p>最好在数字型或日期型字段上排序</p>
<p>因为对于多值类型或分析过的字段排序，系统会选一个值，无法得知该值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET /kibana_sample_data_ecommerce/_search?ignore_unavailable=<span class="literal">true</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"profile"</span>: <span class="string">"true"</span>,</span><br><span class="line">  <span class="string">"sort"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"order_date"</span>: <span class="string">"desc"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"from"</span>: 1,</span><br><span class="line">  <span class="string">"size"</span>: 10,</span><br><span class="line">  <span class="string">"query"</span>: &#123;</span><br><span class="line">    <span class="string">"match_all"</span>: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="_source-过滤"><a class="markdownIt-Anchor" href="#_source-过滤"></a> _source 过滤</h4>
<p>如果 <code>_source</code> 没有存储，那就只返回匹配的文档的元数据</p>
<p><code>_source</code> 支持使用通配符，如：<code>_source[&quot;name*&quot;, &quot;desc*&quot;]</code></p>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET /kibana_sample_data_ecommerce/_search?ignore_unavailable=<span class="literal">true</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"profile"</span>: <span class="string">"true"</span>,</span><br><span class="line">  <span class="string">"_source"</span>: [</span><br><span class="line">    <span class="string">"order_date"</span>,</span><br><span class="line">    <span class="string">"category.keyword"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"from"</span>: 1,</span><br><span class="line">  <span class="string">"size"</span>: 10,</span><br><span class="line">  <span class="string">"query"</span>: &#123;</span><br><span class="line">    <span class="string">"match_all"</span>: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="脚本字段"><a class="markdownIt-Anchor" href="#脚本字段"></a> 脚本字段</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET /kibana_sample_data_ecommerce/_search?ignore_unavailable=<span class="literal">true</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"profile"</span>: <span class="string">"true"</span>,</span><br><span class="line">  <span class="string">"script_fields"</span>: &#123;</span><br><span class="line">    <span class="string">"new_field"</span>: &#123;</span><br><span class="line">      <span class="string">"script"</span>: &#123;</span><br><span class="line">        <span class="string">"lang"</span>: <span class="string">"painless"</span>,</span><br><span class="line">        <span class="string">"source"</span>:<span class="string">"doc['order_date'].value+' hello'"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"from"</span>: 1,</span><br><span class="line">  <span class="string">"size"</span>: 10,</span><br><span class="line">  <span class="string">"query"</span>: &#123;</span><br><span class="line">    <span class="string">"match_all"</span>: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用查询表达式-match"><a class="markdownIt-Anchor" href="#使用查询表达式-match"></a> 使用查询表达式 - Match</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">POST movies/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"query"</span>: &#123;</span><br><span class="line">    <span class="string">"match"</span>: &#123;</span><br><span class="line">      <span class="string">"title"</span>: <span class="string">"last christmas"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">POST movies/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"query"</span>: &#123;</span><br><span class="line">    <span class="string">"match"</span>: &#123;</span><br><span class="line">      <span class="string">"title"</span>: &#123;</span><br><span class="line">        <span class="string">"query"</span>: <span class="string">"last christmas"</span>,</span><br><span class="line">        <span class="string">"operator"</span>: <span class="string">"and"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="短语搜索-match-phrase"><a class="markdownIt-Anchor" href="#短语搜索-match-phrase"></a> 短语搜索 - Match Phrase</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">POST movies/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"query"</span>: &#123;</span><br><span class="line">    <span class="string">"match_phrase"</span>: &#123;</span><br><span class="line">      <span class="string">"title"</span>:&#123;</span><br><span class="line">        <span class="string">"query"</span>: <span class="string">"last christmas"</span></span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-集群-api"><a class="markdownIt-Anchor" href="#4-集群-api"></a> 4. 集群 API</h2>
<blockquote>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster.html" target="_blank" rel="noopener">Elasticsearch 官方之 Cluster API</a></p>
</blockquote>
<p>一些集群级别的 API 可能会在节点的子集上运行，这些节点可以用节点过滤器指定。例如，任务管理、节点统计和节点信息 API 都可以报告来自一组过滤节点而不是所有节点的结果。</p>
<p>节点过滤器以逗号分隔的单个过滤器列表的形式编写，每个过滤器从所选子集中添加或删除节点。每个过滤器可以是以下之一：</p>
<ul>
<li><code>_all</code>：将所有节点添加到子集</li>
<li><code>_local</code>：将本地节点添加到子集</li>
<li><code>_master</code>：将当前主节点添加到子集</li>
<li>根据节点 ID 或节点名将匹配节点添加到子集</li>
<li>根据 IP 地址或主机名将匹配节点添加到子集</li>
<li>使用通配符，将节点名、地址名或主机名匹配的节点添加到子集</li>
<li><code>master:true</code>, <code>data:true</code>, <code>ingest:true</code>, <code>voting_only:true</code>, <code>ml:true</code> 或 <code>coordinating_only:true</code>, 分别意味着将所有主节点、所有数据节点、所有摄取节点、所有仅投票节点、所有机器学习节点和所有协调节点添加到子集中。</li>
<li><code>master:false</code>, <code>data:false</code>, <code>ingest:false</code>, <code>voting_only:true</code>, <code>ml:false</code> 或 <code>coordinating_only:false</code>, 分别意味着将所有主节点、所有数据节点、所有摄取节点、所有仅投票节点、所有机器学习节点和所有协调节点排除在子集外。</li>
<li>配对模式，使用 <code>*</code> 通配符，格式为 <code>attrname:attrvalue</code>，将所有具有自定义节点属性的节点添加到子集中，其名称和值与相应的模式匹配。自定义节点属性是通过 <code>node.attr.attrname: attrvalue</code> 形式在配置文件中设置的。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果没有给出过滤器，默认是查询所有节点</span></span><br><span class="line">GET /_nodes</span><br><span class="line"><span class="comment"># 查询所有节点</span></span><br><span class="line">GET /_nodes/_all</span><br><span class="line"><span class="comment"># 查询本地节点</span></span><br><span class="line">GET /_nodes/_local</span><br><span class="line"><span class="comment"># 查询主节点</span></span><br><span class="line">GET /_nodes/_master</span><br><span class="line"><span class="comment"># 根据名称查询节点（支持通配符）</span></span><br><span class="line">GET /_nodes/node_name_goes_here</span><br><span class="line">GET /_nodes/node_name_goes_*</span><br><span class="line"><span class="comment"># 根据地址查询节点（支持通配符）</span></span><br><span class="line">GET /_nodes/10.0.0.3,10.0.0.4</span><br><span class="line">GET /_nodes/10.0.0.*</span><br><span class="line"><span class="comment"># 根据规则查询节点</span></span><br><span class="line">GET /_nodes/_all,master:<span class="literal">false</span></span><br><span class="line">GET /_nodes/data:<span class="literal">true</span>,ingest:<span class="literal">true</span></span><br><span class="line">GET /_nodes/coordinating_only:<span class="literal">true</span></span><br><span class="line">GET /_nodes/master:<span class="literal">true</span>,voting_only:<span class="literal">false</span></span><br><span class="line"><span class="comment"># 根据自定义属性查询节点（如：查询配置文件中含 node.attr.rack:2 属性的节点）</span></span><br><span class="line">GET /_nodes/rack:2</span><br><span class="line">GET /_nodes/ra*:2</span><br><span class="line">GET /_nodes/ra*:2*</span><br></pre></td></tr></table></figure>
<h3 id="41-集群健康-api"><a class="markdownIt-Anchor" href="#41-集群健康-api"></a> 4.1. 集群健康 API</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET /_cluster/health</span><br><span class="line">GET /_cluster/health?level=shards</span><br><span class="line">GET /_cluster/health/kibana_sample_data_ecommerce,kibana_sample_data_flights</span><br><span class="line">GET /_cluster/health/kibana_sample_data_flights?level=shards</span><br></pre></td></tr></table></figure>
<h3 id="42-集群状态-api"><a class="markdownIt-Anchor" href="#42-集群状态-api"></a> 4.2. 集群状态 API</h3>
<p>集群状态 API 返回表示整个集群状态的元数据。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET /_cluster/state</span><br></pre></td></tr></table></figure>
<h2 id="5-节点-api"><a class="markdownIt-Anchor" href="#5-节点-api"></a> 5. 节点 API</h2>
<blockquote>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/cat-nodes.html" target="_blank" rel="noopener">Elasticsearch 官方之 cat Nodes API</a>——返回有关集群节点的信息。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看默认的字段</span></span><br><span class="line">GET /_cat/nodes?v=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 查看指定的字段</span></span><br><span class="line">GET /_cat/nodes?v=<span class="literal">true</span>&amp;h=id,ip,port,v,m</span><br></pre></td></tr></table></figure>
<h2 id="6-分片-api"><a class="markdownIt-Anchor" href="#6-分片-api"></a> 6. 分片 API</h2>
<blockquote>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/cat-shards.html" target="_blank" rel="noopener">Elasticsearch 官方之 cat Shards API</a>——shards 命令是哪些节点包含哪些分片的详细视图。它会告诉你它是主还是副本、文档数量、它在磁盘上占用的字节数以及它所在的节点。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看默认的字段</span></span><br><span class="line">GET /_cat/shards</span><br><span class="line"><span class="comment"># 根据名称查询分片（支持通配符）</span></span><br><span class="line">GET /_cat/shards/my-index-*</span><br><span class="line"><span class="comment"># 查看指定的字段</span></span><br><span class="line">GET /_cat/shards?h=index,shard,prirep,state,unassigned.reason</span><br></pre></td></tr></table></figure>
<h2 id="7-监控-api"><a class="markdownIt-Anchor" href="#7-监控-api"></a> 7. 监控 API</h2>
<p>Elasticsearch 中集群相关的健康、统计等相关的信息都是围绕着 <code>cat</code> API 进行的。</p>
<p>通过 GET 请求发送 cat，下面列出了所有可用的 API：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET /_cat</span><br><span class="line"></span><br><span class="line">=^.^=</span><br><span class="line">/_cat/allocation</span><br><span class="line">/_cat/shards</span><br><span class="line">/_cat/shards/&#123;index&#125;</span><br><span class="line">/_cat/master</span><br><span class="line">/_cat/nodes</span><br><span class="line">/_cat/tasks</span><br><span class="line">/_cat/indices</span><br><span class="line">/_cat/indices/&#123;index&#125;</span><br><span class="line">/_cat/segments</span><br><span class="line">/_cat/segments/&#123;index&#125;</span><br><span class="line">/_cat/count</span><br><span class="line">/_cat/count/&#123;index&#125;</span><br><span class="line">/_cat/recovery</span><br><span class="line">/_cat/recovery/&#123;index&#125;</span><br><span class="line">/_cat/health</span><br><span class="line">/_cat/pending_tasks</span><br><span class="line">/_cat/aliases</span><br><span class="line">/_cat/aliases/&#123;<span class="built_in">alias</span>&#125;</span><br><span class="line">/_cat/thread_pool</span><br><span class="line">/_cat/thread_pool/&#123;thread_pools&#125;</span><br><span class="line">/_cat/plugins</span><br><span class="line">/_cat/fielddata</span><br><span class="line">/_cat/fielddata/&#123;fields&#125;</span><br><span class="line">/_cat/nodeattrs</span><br><span class="line">/_cat/repositories</span><br><span class="line">/_cat/snapshots/&#123;repository&#125;</span><br><span class="line">/_cat/templates</span><br></pre></td></tr></table></figure>
<h2 id="8-参考资料"><a class="markdownIt-Anchor" href="#8-参考资料"></a> 8. 参考资料</h2>
<ul>
<li><strong>官方</strong>
<ul>
<li><a href="https://www.elastic.co/cn/products/elasticsearch" target="_blank" rel="noopener">Elasticsearch 官网</a></li>
<li><a href="https://github.com/elastic/elasticsearch" target="_blank" rel="noopener">Elasticsearch Github</a></li>
<li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html" target="_blank" rel="noopener">Elasticsearch 官方文档</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blog/page/7/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/blog/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/18/">18</a><a class="extend next" rel="next" href="/blog/page/9/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="Zhang Peng"
    src="/blog/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Zhang Peng</p>
  <div class="site-description" itemprop="description">Dunwu's Blog</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">173</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">102</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/dunwu" title="GitHub &amp;rarr; https:&#x2F;&#x2F;github.com&#x2F;dunwu" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:forbreak@163.com" title="E-Mail &amp;rarr; mailto:forbreak@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/blog/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-paper-plane"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhang Peng</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">976k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">14:48</span>
</div>

        












        
      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1/canvas-nest.min.js"></script>
  <script src="/blog/lib/anime.min.js"></script>
  <script src="/blog/lib/velocity/velocity.min.js"></script>
  <script src="/blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/pisces.js"></script>


<script src="/blog/js/next-boot.js"></script>

<script src="/blog/js/bookmark.js"></script>




  




  
<script src="/blog/js/local-search.js"></script>














  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://blog-ajay4qmfci.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>

</body>
</html>
