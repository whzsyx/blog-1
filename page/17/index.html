<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon.ico">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/themes/blue/pace-theme-minimal.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/pace.min.js"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/blog/',
    scheme: 'Pisces',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":true},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":true,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="Dunwu&#39;s Blog">
<meta property="og:type" content="website">
<meta property="og:title" content="Dunwu">
<meta property="og:url" content="https://dunwu.github.io/blog/page/17/index.html">
<meta property="og:site_name" content="Dunwu">
<meta property="og:description" content="Dunwu&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Zhang Peng">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://dunwu.github.io/blog/page/17/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Dunwu</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/blog/atom.xml" title="Dunwu" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/blog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Dunwu</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <h1 class="site-subtitle" itemprop="description">大道至简，知易行难</h1>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/blog/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">102</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">37</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">173</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/dunwu" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/2015/01/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2015/01/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">设计模式之中介者模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-01-22 13:34:00" itemprop="dateCreated datePublished" datetime="2015-01-22T13:34:00+08:00">2015-01-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-14 16:45:53" itemprop="dateModified" datetime="2022-04-14T16:45:53+08:00">2022-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index">
                    <span itemprop="name">设计</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2015/01/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/01/22/设计模式之中介者模式/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="设计模式之中介者模式"><a class="markdownIt-Anchor" href="#设计模式之中介者模式"></a> 设计模式之中介者模式</h1>
<h2 id="1-意图"><a class="markdownIt-Anchor" href="#1-意图"></a> 1. 意图</h2>
<p><strong>中介者模式</strong>（Mediator） 是一种行为设计模式， 能让你减少对象之间混乱无序的依赖关系。 该模式会限制对象之间的直接交互， 迫使它们通过一个中介者对象进行合作。</p>
<h2 id="2-适用场景"><a class="markdownIt-Anchor" href="#2-适用场景"></a> 2. 适用场景</h2>
<ul>
<li>当一些对象和其他对象紧密耦合以致难以对其进行修改时， 可使用中介者模式。</li>
<li>当组件因过于依赖其他组件而无法在不同应用中复用时， 可使用中介者模式。</li>
<li>如果为了能在不同情景下复用一些基本行为， 导致你需要被迫创建大量组件子类时， 可使用中介者模式。</li>
</ul>
<h2 id="3-结构"><a class="markdownIt-Anchor" href="#3-结构"></a> 3. 结构</h2>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20210520171152.png" alt="img" /></p>
<h3 id="31-结构说明"><a class="markdownIt-Anchor" href="#31-结构说明"></a> 3.1. 结构说明</h3>
<ol>
<li><strong>组件</strong> （Component） 是各种包含业务逻辑的类。 每个组件都有一个指向中介者的引用， 该引用被声明为中介者接口类型。 组件不知道中介者实际所属的类， 因此你可通过将其连接到不同的中介者以使其能在其他程序中复用。</li>
<li><strong>中介者</strong> （Mediator） 接口声明了与组件交流的方法， 但通常仅包括一个通知方法。 组件可将任意上下文 （包括自己的对象） 作为该方法的参数， 只有这样接收组件和发送者类之间才不会耦合。</li>
<li><strong>具体中介者</strong> （Concrete Mediator） 封装了多种组件间的关系。 具体中介者通常会保存所有组件的引用并对其进行管理， 甚至有时会对其生命周期进行管理。</li>
<li>组件并不知道其他组件的情况。 如果组件内发生了重要事件， 它只能通知中介者。 中介者收到通知后能轻易地确定发送者， 这或许已足以判断接下来需要触发的组件了。
<ul>
<li>对于组件来说， 中介者看上去完全就是一个黑箱。 发送者不知道最终会由谁来处理自己的请求， 接收者也不知道最初是谁发出了请求。</li>
</ul>
</li>
</ol>
<h3 id="32-结构代码范式"><a class="markdownIt-Anchor" href="#32-结构代码范式"></a> 3.2. 结构代码范式</h3>
<p><strong>Mediator</strong> : 为 Colleague 对象定义一个交流接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Send</span><span class="params">(String message, Colleague colleague)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ConcreteMediator</strong> : 实现 Mediator 中的交流接口。 这个类中需要了解并维护所有的 colleague 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteMediator</span> <span class="keyword">extends</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ConcreteColleague1 colleague1;</span><br><span class="line">    <span class="keyword">private</span> ConcreteColleague2 colleague2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColleague1</span><span class="params">(ConcreteColleague1 colleague1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.colleague1 = colleague1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColleague2</span><span class="params">(ConcreteColleague2 colleague2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.colleague2 = colleague2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span><span class="params">(String message, Colleague colleague)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (colleague == colleague1) &#123;</span><br><span class="line">            colleague2.Notify(message);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (colleague == colleague2)&#123;</span><br><span class="line">            colleague1.Notify(message);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Error!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Colleague 组</strong> : 每个 Colleague 对象应该知道它的 Mediator 对象，但不知道其他同事对象。它只能联系 Mediator 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Mediator mediator;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Colleague</span><span class="params">(Mediator mediator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mediator = mediator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        mediator.Send(message, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Notify</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteColleague1</span> <span class="keyword">extends</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteColleague1</span><span class="params">(Mediator mediator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(mediator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Notify</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"同事1得到信息："</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteColleague2</span> <span class="keyword">extends</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteColleague2</span><span class="params">(Mediator mediator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(mediator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Notify</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"同事2得到信息："</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MediatorPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConcreteMediator mediator = <span class="keyword">new</span> ConcreteMediator();</span><br><span class="line">        ConcreteColleague1 colleague1 = <span class="keyword">new</span> ConcreteColleague1(mediator);</span><br><span class="line">        ConcreteColleague2 colleague2 = <span class="keyword">new</span> ConcreteColleague2(mediator);</span><br><span class="line"></span><br><span class="line">        mediator.setColleague1(colleague1);</span><br><span class="line">        mediator.setColleague2(colleague2);</span><br><span class="line"></span><br><span class="line">        colleague1.Send(<span class="string">"How are you?"</span>);</span><br><span class="line">        colleague2.Send(<span class="string">"Fine, thank you. And you?"</span>);</span><br><span class="line">        colleague1.Send(<span class="string">"I'm fine. Thankes."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">同事<span class="number">2</span>得到信息：How are you?</span><br><span class="line">同事<span class="number">1</span>得到信息：Fine, thank you. And you?</span><br><span class="line">同事<span class="number">2</span>得到信息：I<span class="string">'m fine. Thankes.</span></span><br></pre></td></tr></table></figure>
<h2 id="4-伪代码"><a class="markdownIt-Anchor" href="#4-伪代码"></a> 4. 伪代码</h2>
<p>在本例中， <strong>中介者</strong>模式可帮助你减少各种 UI 类 （按钮、 复选框和文本标签） 之间的相互依赖关系。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20210520171433.png" alt="img" /></p>
<p>用户触发的元素不会直接与其他元素交流， 即使看上去它们应该这样做。 相反， 元素只需让中介者知晓事件即可， 并能在发出通知时同时传递任何上下文信息。</p>
<p>本例中的中介者是整个认证对话框。 对话框知道具体元素应如何进行合作并促进它们的间接交流。 当接收到事件通知后， 对话框会确定负责处理事件的元素并据此重定向请求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 中介者接口声明了一个能让组件将各种事件通知给中介者的方法。中介者可对这</span></span><br><span class="line"><span class="comment">// 些事件做出响应并将执行工作传递给其他组件。</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Mediator</span> <span class="title">is</span></span></span><br><span class="line">    method notify(sender: Component, event: string)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体中介者类可解开各组件之间相互交叉的连接关系并将其转移到中介者中。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthenticationDialog</span> <span class="keyword">implements</span> <span class="title">Mediator</span> <span class="title">is</span></span></span><br><span class="line">    private field title: string</span><br><span class="line">    <span class="keyword">private</span> field loginOrRegisterChkBx: Checkbox</span><br><span class="line">    <span class="keyword">private</span> field loginUsername, loginPassword: Textbox</span><br><span class="line">    <span class="keyword">private</span> field registrationUsername, registrationPassword,</span><br><span class="line">                  registrationEmail: Textbox</span><br><span class="line">    <span class="keyword">private</span> field okBtn, cancelBtn: Button</span><br><span class="line"></span><br><span class="line">    <span class="function">constructor <span class="title">AuthenticationDialog</span><span class="params">()</span> is</span></span><br><span class="line"><span class="function">        <span class="comment">// 创建所有组件对象并将当前中介者传递给其构造函数以建立连接。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">// 当组件中有事件发生时，它会通知中介者。中介者接收到通知后可自行处理，</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 也可将请求传递给另一个组件。</span></span></span><br><span class="line"><span class="function">    method <span class="title">notify</span><span class="params">(sender, event)</span> is</span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">(sender == loginOrRegisterChkBx and event == <span class="string">"check"</span>)</span></span></span><br><span class="line"><span class="function">            <span class="title">if</span> <span class="params">(loginOrRegisterChkBx.checked)</span></span></span><br><span class="line"><span class="function">                title </span>= <span class="string">"登录"</span></span><br><span class="line">                <span class="comment">// 1. 显示登录表单组件。</span></span><br><span class="line">                <span class="comment">// 2. 隐藏注册表单组件。</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                title = <span class="string">"注册"</span></span><br><span class="line">                <span class="comment">// 1. 显示注册表单组件。</span></span><br><span class="line">                <span class="comment">// 2. 隐藏登录表单组件。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sender == okBtn &amp;&amp; event == <span class="string">"click"</span>)</span><br><span class="line">            <span class="keyword">if</span> (loginOrRegister.checked)</span><br><span class="line">                <span class="comment">// 尝试找到使用登录信息的用户。</span></span><br><span class="line">                <span class="keyword">if</span> (!found)</span><br><span class="line">                    <span class="comment">// 在登录字段上方显示错误信息。</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 1. 使用注册字段中的数据创建用户账号。</span></span><br><span class="line">                <span class="comment">// 2. 完成用户登录工作。 …</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件会使用中介者接口与中介者进行交互。因此只需将它们与不同的中介者连接</span></span><br><span class="line"><span class="comment">// 起来，你就能在其他情境中使用这些组件了。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span> <span class="title">is</span></span></span><br><span class="line">    field dialog: Mediator</span><br><span class="line"></span><br><span class="line">    <span class="function">constructor <span class="title">Component</span><span class="params">(dialog)</span> is</span></span><br><span class="line"><span class="function">        <span class="keyword">this</span>.dialog </span>= dialog</span><br><span class="line"></span><br><span class="line">    <span class="function">method <span class="title">click</span><span class="params">()</span> is</span></span><br><span class="line"><span class="function">        dialog.<span class="title">notify</span><span class="params">(<span class="keyword">this</span>, <span class="string">"click"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    method <span class="title">keypress</span><span class="params">()</span> is</span></span><br><span class="line"><span class="function">        dialog.<span class="title">notify</span><span class="params">(<span class="keyword">this</span>, <span class="string">"keypress"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 具体组件之间无法进行交流。它们只有一个交流渠道，那就是向中介者发送通知。</span></span></span><br><span class="line"><span class="function">class Button extends Component is</span></span><br><span class="line"><span class="function">    <span class="comment">// ...</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">class Textbox extends Component is</span></span><br><span class="line"><span class="function">    <span class="comment">// ...</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">class Checkbox extends Component is</span></span><br><span class="line"><span class="function">    method <span class="title">check</span><span class="params">()</span> is</span></span><br><span class="line"><span class="function">        dialog.<span class="title">notify</span><span class="params">(<span class="keyword">this</span>, <span class="string">"check"</span>)</span></span></span><br><span class="line"><span class="function">    <span class="comment">// ...</span></span></span><br></pre></td></tr></table></figure>
<h2 id="5-与其他模式的关系"><a class="markdownIt-Anchor" href="#5-与其他模式的关系"></a> 5. 与其他模式的关系</h2>
<ul>
<li><a href="https://refactoringguru.cn/design-patterns/chain-of-responsibility" target="_blank" rel="noopener">责任链模式</a>、 <a href="https://refactoringguru.cn/design-patterns/command" target="_blank" rel="noopener">命令模式</a>、 <a href="https://refactoringguru.cn/design-patterns/mediator" target="_blank" rel="noopener">中介者模式</a>和<a href="https://refactoringguru.cn/design-patterns/observer" target="_blank" rel="noopener">观察者模式</a>用于处理请求发送者和接收者之间的不同连接方式：
<ul>
<li><em>责任链</em>按照顺序将请求动态传递给一系列的潜在接收者， 直至其中一名接收者对请求进行处理。</li>
<li><em>命令</em>在发送者和请求者之间建立单向连接。</li>
<li><em>中介者</em>清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行间接沟通。</li>
<li><em>观察者</em>允许接收者动态地订阅或取消接收请求。</li>
</ul>
</li>
<li><a href="https://refactoringguru.cn/design-patterns/facade" target="_blank" rel="noopener">外观模式</a>和<a href="https://refactoringguru.cn/design-patterns/mediator" target="_blank" rel="noopener">中介者</a>的职责类似： 它们都尝试在大量紧密耦合的类中组织起合作。
<ul>
<li><em>外观</em>为子系统中的所有对象定义了一个简单接口， 但是它不提供任何新功能。 子系统本身不会意识到外观的存在。 子系统中的对象可以直接进行交流。</li>
<li><em>中介者</em>将系统中组件的沟通行为中心化。 各组件只知道中介者对象， 无法直接相互交流。</li>
</ul>
</li>
<li><a href="https://refactoringguru.cn/design-patterns/mediator" target="_blank" rel="noopener">中介者</a>和<a href="https://refactoringguru.cn/design-patterns/observer" target="_blank" rel="noopener">观察者</a>之间的区别往往很难记住。 在大部分情况下， 你可以使用其中一种模式， 而有时可以同时使用。 让我们来看看如何做到这一点。
<ul>
<li><em>中介者</em>的主要目标是消除一系列系统组件之间的相互依赖。 这些组件将依赖于同一个中介者对象。 <em>观察者</em>的目标是在对象之间建立动态的单向连接， 使得部分对象可作为其他对象的附属发挥作用。</li>
<li>有一种流行的中介者模式实现方式依赖于<em>观察者</em>。 中介者对象担当发布者的角色， 其他组件则作为订阅者， 可以订阅中介者的事件或取消订阅。 当<em>中介者</em>以这种方式实现时， 它可能看上去与<em>观察者</em>非常相似。</li>
<li>当你感到疑惑时， 记住可以采用其他方式来实现中介者。 例如， 你可永久性地将所有组件链接到同一个中介者对象。 这种实现方式和<em>观察者</em>并不相同， 但这仍是一种中介者模式。</li>
<li>假设有一个程序， 其所有的组件都变成了发布者， 它们之间可以相互建立动态连接。 这样程序中就没有中心化的中介者对象， 而只有一些分布式的观察者。</li>
</ul>
</li>
</ul>
<h2 id="6-案例"><a class="markdownIt-Anchor" href="#6-案例"></a> 6. 案例</h2>
<p><strong>使用示例：</strong> 中介者模式在 Java 代码中最常用于帮助程序 GUI 组件之间的通信。 在 MVC 模式中， 控制器是中介者的同义词。</p>
<p>下面是核心 Java 程序库中该模式的一些示例：</p>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Timer.html" target="_blank" rel="noopener"><code>java.util.Timer</code></a> （所有 <code>schedule­XXX()</code>方法）</li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executor.html#execute-java.lang.Runnable-" target="_blank" rel="noopener"><code>java.util.concurrent.Executor#execute()</code></a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html" target="_blank" rel="noopener"><code>java.util.concurrent.ExecutorService</code></a> （ <code>invoke­XXX()</code>和 <code>submit­()</code>方法）</li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledExecutorService.html" target="_blank" rel="noopener"><code>java.util.concurrent.ScheduledExecutorService</code></a> （所有 <code>schedule­XXX()</code>方法）</li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Method.html#invoke-java.lang.Object-java.lang.Object...-" target="_blank" rel="noopener"><code>java.lang.reflect.Method#invoke()</code></a></li>
</ul>
<h2 id="7-参考资料"><a class="markdownIt-Anchor" href="#7-参考资料"></a> 7. 参考资料</h2>
<ul>
<li><a href="https://book.douban.com/subject/2243615/" target="_blank" rel="noopener">《Head First 设计模式》</a></li>
<li><a href="https://book.douban.com/subject/2334288/" target="_blank" rel="noopener">《大话设计模式》</a></li>
<li><a href="https://refactoringguru.cn/design-patterns/catalog" target="_blank" rel="noopener">设计模式教程</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/2015/01/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2015/01/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">设计模式之解释器模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-01-20 18:44:00" itemprop="dateCreated datePublished" datetime="2015-01-20T18:44:00+08:00">2015-01-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-14 16:45:53" itemprop="dateModified" datetime="2022-04-14T16:45:53+08:00">2022-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index">
                    <span itemprop="name">设计</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2015/01/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/01/20/设计模式之解释器模式/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="设计模式之解释器模式"><a class="markdownIt-Anchor" href="#设计模式之解释器模式"></a> 设计模式之解释器模式</h1>
<h2 id="1-简介"><a class="markdownIt-Anchor" href="#1-简介"></a> 1. 简介</h2>
<p><strong>解释器模式 (Interpreter)</strong> 定义一个语言，定义它的文法的一种表示。并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</p>
<p>解释器模式是一种<strong>行为型模式</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200726112138.png" alt="img" /></p>
<p><strong>Context</strong> : 包含解释器之外的一些全局信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String input;</span><br><span class="line">    <span class="keyword">private</span> String output;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInput</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.input = input;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInput</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.input;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOutput</span><span class="params">(String output)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.output = output;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getOutput</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>AbstractExpression</strong> : 声明一个抽象的解释操作，这个接口为抽象语法树中所有的节点所共享。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractExpression</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Interpret</span><span class="params">(Context context)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>TerminalExpression</strong> : 实现与文法中的终结符相关联的解释操作。实现抽象表达式中所要求的接口，主要是一个 Interprete()方法。</p>
<p>文法中的每一个终结符都有一个具体终结表达式与之对应。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TerminalExpression</span> <span class="keyword">extends</span> <span class="title">AbstractExpression</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Interpret</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        context.setOutput(<span class="string">"终端"</span> + context.getInput());</span><br><span class="line">        System.out.println(context.getInput() + <span class="string">"经过终端解释器解释为："</span> + context.getOutput());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>NonterminalExpression</strong> : 实现与文法中的非终结符相关联的解释操作。对文法中的每一条规则 R1，R2…Rn 都需要一个具体的非终结符表达式类。通过实现抽象表达式的 Interpret 方法实现解释操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonterminalExpression</span> <span class="keyword">extends</span> <span class="title">AbstractExpression</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Interpret</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        context.setOutput(<span class="string">"非终端"</span> + context.getInput());</span><br><span class="line">        System.out.println(context.getInput() + <span class="string">"经过非终端解释器解释为："</span> + context.getOutput());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterpreterPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Context context = <span class="keyword">new</span> Context();</span><br><span class="line">        context.setInput(<span class="string">"ABC"</span>);</span><br><span class="line"></span><br><span class="line">        AbstractExpression expression1 = <span class="keyword">new</span> TerminalExpression();</span><br><span class="line">        expression1.Interpret(context);</span><br><span class="line"></span><br><span class="line">        AbstractExpression expression2 = <span class="keyword">new</span> NonterminalExpression();</span><br><span class="line">        expression2.Interpret(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ABC经过终端解释器解释为：终端ABC</span><br><span class="line">ABC经过非终端解释器解释为：非终端ABC</span><br></pre></td></tr></table></figure>
<h2 id="2-实例"><a class="markdownIt-Anchor" href="#2-实例"></a> 2. 实例</h2>
<h2 id="3-场景"><a class="markdownIt-Anchor" href="#3-场景"></a> 3. 场景</h2>
<h2 id="4-参考资料"><a class="markdownIt-Anchor" href="#4-参考资料"></a> 4. 参考资料</h2>
<ul>
<li><a href="https://book.douban.com/subject/2243615/" target="_blank" rel="noopener">《Head First 设计模式》</a></li>
<li><a href="https://book.douban.com/subject/2334288/" target="_blank" rel="noopener">《大话设计模式》</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/2015/01/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2015/01/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">设计模式之观察者模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-01-20 16:09:00" itemprop="dateCreated datePublished" datetime="2015-01-20T16:09:00+08:00">2015-01-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-14 16:45:53" itemprop="dateModified" datetime="2022-04-14T16:45:53+08:00">2022-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index">
                    <span itemprop="name">设计</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2015/01/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/01/20/设计模式之观察者模式/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="设计模式之观察者模式"><a class="markdownIt-Anchor" href="#设计模式之观察者模式"></a> 设计模式之观察者模式</h1>
<h2 id="1-意图"><a class="markdownIt-Anchor" href="#1-意图"></a> 1. 意图</h2>
<p><strong>观察者模式</strong>（Observer）是一种行为设计模式， 允许你定义一种订阅机制， 可在对象事件发生时通知多个 “观察” 该对象的其他对象。</p>
<h2 id="2-适用场景"><a class="markdownIt-Anchor" href="#2-适用场景"></a> 2. 适用场景</h2>
<ul>
<li>当一个对象状态的改变需要改变其他对象， 或实际对象是事先未知的或动态变化的时， 可使用观察者模式。</li>
<li>当应用中的一些对象必须观察其他对象时， 可使用该模式。 但仅能在有限时间内或特定情况下使用。</li>
</ul>
<h2 id="3-结构"><a class="markdownIt-Anchor" href="#3-结构"></a> 3. 结构</h2>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20210519174232.png" alt="img" /></p>
<h3 id="31-结构说明"><a class="markdownIt-Anchor" href="#31-结构说明"></a> 3.1. 结构说明</h3>
<ol>
<li><strong>发布者</strong> （Publisher） 会向其他对象发送值得关注的事件。 事件会在发布者自身状态改变或执行特定行为后发生。 发布者中包含一个允许新订阅者加入和当前订阅者离开列表的订阅构架。</li>
<li>当新事件发生时， 发送者会遍历订阅列表并调用每个订阅者对象的通知方法。 该方法是在订阅者接口中声明的。</li>
<li><strong>订阅者</strong> （Subscriber） 接口声明了通知接口。 在绝大多数情况下， 该接口仅包含一个 <code>update</code>更新方法。 该方法可以拥有多个参数， 使发布者能在更新时传递事件的详细信息。</li>
<li><strong>具体订阅者</strong> （Concrete Subscribers） 可以执行一些操作来回应发布者的通知。 所有具体订阅者类都实现了同样的接口， 因此发布者不需要与具体类相耦合。</li>
<li>订阅者通常需要一些上下文信息来正确地处理更新。 因此， 发布者通常会将一些上下文数据作为通知方法的参数进行传递。 发布者也可将自身作为参数进行传递， 使订阅者直接获取所需的数据。</li>
<li><strong>客户端</strong> （Client） 会分别创建发布者和订阅者对象， 然后为订阅者注册发布者更新。</li>
</ol>
<h3 id="32-结构代码范式"><a class="markdownIt-Anchor" href="#32-结构代码范式"></a> 3.2. 结构代码范式</h3>
<p><strong>Subject</strong> : 主题类，保存所有订阅此主题的观察者，观察者的 <strong>数量是任意的</strong>。定义 <strong>添加观察者</strong> <strong>(Attach)</strong> 和 <strong>删除观察者 (Detach)</strong> 的接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> String state;</span><br><span class="line">    <span class="keyword">protected</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getState</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Notify</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Subject</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Attach</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Detach</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Observer</strong> : 观察者类，定义<strong>更新接口 (Update)</strong>，当收到 Subject 的通知时，Observer 需要同步更新信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> Subject subject;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Observer</span><span class="params">(String name, Subject subject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ConcreteSubject</strong> : 具体主题类，存储对于这个主题感兴趣的所有观察者。当内部状态发生变化时，应<strong>通知所有登记的观察者(Notify)</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> <span class="keyword">extends</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteSubject</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Notify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"======= "</span> + <span class="keyword">this</span>.name + <span class="string">"主题发布新消息 ======="</span>);</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">            observer.Update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ConcreteObserver</strong> : 具体观察者类，实现 Observer 的<strong>更新接口 (Update)</strong>，以便和 Subject 同步状态信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver</span> <span class="keyword">extends</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteObserver</span><span class="params">(String name, Subject subject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, subject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        state = subject.getState();</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name + <span class="string">"收到当前状态："</span> + state);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConcreteSubject subject = <span class="keyword">new</span> ConcreteSubject(<span class="string">"天气"</span>);</span><br><span class="line">        ConcreteObserver observer1 = <span class="keyword">new</span> ConcreteObserver(<span class="string">"张三"</span>, subject);</span><br><span class="line">        ConcreteObserver observer2 = <span class="keyword">new</span> ConcreteObserver(<span class="string">"李四"</span>, subject);</span><br><span class="line">        ConcreteObserver observer3 = <span class="keyword">new</span> ConcreteObserver(<span class="string">"王五"</span>, subject);</span><br><span class="line"></span><br><span class="line">        subject.Attach(observer1);</span><br><span class="line">        subject.Attach(observer2);</span><br><span class="line">        subject.Attach(observer3);</span><br><span class="line">        subject.setState(<span class="string">"今天下雨"</span>);</span><br><span class="line">        subject.Notify();</span><br><span class="line"></span><br><span class="line">        subject.Detach(observer2);</span><br><span class="line">        subject.setState(<span class="string">"明天天晴"</span>);</span><br><span class="line">        subject.Notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">======= 天气主题发布新消息 =======</span></span><br><span class="line">张三收到当前状态：今天下雨</span><br><span class="line">李四收到当前状态：今天下雨</span><br><span class="line">王五收到当前状态：今天下雨</span><br><span class="line"><span class="comment">======= 天气主题发布新消息 =======</span></span><br><span class="line">张三收到当前状态：明天天晴</span><br><span class="line">王五收到当前状态：明天天晴</span><br></pre></td></tr></table></figure>
<h2 id="4-伪代码"><a class="markdownIt-Anchor" href="#4-伪代码"></a> 4. 伪代码</h2>
<p>在本例中， <strong>观察者</strong>模式允许文本编辑器对象将自身的状态改变通知给其他服务对象。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20210519175224.png" alt="img" /></p>
<p>订阅者列表是动态生成的： 对象可在运行时根据程序需要开始或停止监听通知。</p>
<p>在本实现中， 编辑器类自身并不维护订阅列表。 它将工作委派给专门从事此工作的一个特殊帮手对象。 你还可将该对象升级为中心化的事件分发器， 允许任何对象成为发布者。</p>
<p>只要发布者通过同样的接口与所有订阅者进行交互， 那么在程序中新增订阅者时就无需修改已有发布者类的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发布者基类包含订阅管理代码和通知方法。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventManager</span> <span class="title">is</span></span></span><br><span class="line">    private field listeners: hash map of event types and listeners</span><br><span class="line"></span><br><span class="line">    <span class="function">method <span class="title">subscribe</span><span class="params">(eventType, listener)</span> is</span></span><br><span class="line"><span class="function">        listeners.<span class="title">add</span><span class="params">(eventType, listener)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    method <span class="title">unsubscribe</span><span class="params">(eventType, listener)</span> is</span></span><br><span class="line"><span class="function">        listeners.<span class="title">remove</span><span class="params">(eventType, listener)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    method <span class="title">notify</span><span class="params">(eventType, data)</span> is</span></span><br><span class="line"><span class="function">        <span class="title">foreach</span> <span class="params">(listener in listeners.of(eventType)</span>) <span class="keyword">do</span></span></span><br><span class="line"><span class="function">            listener.<span class="title">update</span><span class="params">(data)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 具体发布者包含一些订阅者感兴趣的实际业务逻辑。我们可以从发布者基类中扩</span></span></span><br><span class="line"><span class="function"><span class="comment">// 展出该类，但在实际情况下并不总能做到，因为具体发布者可能已经是子类了。</span></span></span><br><span class="line"><span class="function"><span class="comment">// 在这种情况下，你可用组合来修补订阅逻辑，就像我们在这里做的一样。</span></span></span><br><span class="line"><span class="function">class Editor is</span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> field events: EventManager</span></span><br><span class="line"><span class="function">    <span class="keyword">private</span> field file: File</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    constructor <span class="title">Editor</span><span class="params">()</span> is</span></span><br><span class="line"><span class="function">        events </span>= <span class="keyword">new</span> EventManager()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 业务逻辑的方法可将变化通知给订阅者。</span></span><br><span class="line">    <span class="function">method <span class="title">openFile</span><span class="params">(path)</span> is</span></span><br><span class="line"><span class="function">        <span class="keyword">this</span>.file </span>= <span class="keyword">new</span> File(path)</span><br><span class="line">        events.notify(<span class="string">"open"</span>, file.name)</span><br><span class="line"></span><br><span class="line">    <span class="function">method <span class="title">saveFile</span><span class="params">()</span> is</span></span><br><span class="line"><span class="function">        file.<span class="title">write</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        events.<span class="title">notify</span><span class="params">(<span class="string">"save"</span>, file.name)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">// ...</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 这里是订阅者接口。如果你的编程语言支持函数类型，则可用一组函数来代替整</span></span></span><br><span class="line"><span class="function"><span class="comment">// 个订阅者的层次结构。</span></span></span><br><span class="line"><span class="function">interface EventListener is</span></span><br><span class="line"><span class="function">    method <span class="title">update</span><span class="params">(filename)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 具体订阅者会对其注册的发布者所发出的更新消息做出响应。</span></span></span><br><span class="line"><span class="function">class LoggingListener implements EventListener is</span></span><br><span class="line"><span class="function">    <span class="keyword">private</span> field log: File</span></span><br><span class="line"><span class="function">    <span class="keyword">private</span> field message</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    constructor <span class="title">LoggingListener</span><span class="params">(log_filename, message)</span> is</span></span><br><span class="line"><span class="function">        <span class="keyword">this</span>.log </span>= <span class="keyword">new</span> File(log_filename)</span><br><span class="line">        <span class="keyword">this</span>.message = message</span><br><span class="line"></span><br><span class="line">    <span class="function">method <span class="title">update</span><span class="params">(filename)</span> is</span></span><br><span class="line"><span class="function">        log.<span class="title">write</span><span class="params">(replace(<span class="string">'%s'</span>,filename,message)</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">class EmailAlertsListener implements EventListener is</span></span><br><span class="line"><span class="function">    <span class="keyword">private</span> field email: string</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    constructor <span class="title">EmailAlertsListener</span><span class="params">(email, message)</span> is</span></span><br><span class="line"><span class="function">        <span class="keyword">this</span>.email </span>= email</span><br><span class="line">        <span class="keyword">this</span>.message = message</span><br><span class="line"></span><br><span class="line">    <span class="function">method <span class="title">update</span><span class="params">(filename)</span> is</span></span><br><span class="line"><span class="function">        system.<span class="title">email</span><span class="params">(email, replace(<span class="string">'%s'</span>,filename,message)</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 应用程序可在运行时配置发布者和订阅者。</span></span></span><br><span class="line"><span class="function">class Application is</span></span><br><span class="line"><span class="function">    method <span class="title">config</span><span class="params">()</span> is</span></span><br><span class="line"><span class="function">        editor </span>= <span class="keyword">new</span> Editor()</span><br><span class="line"></span><br><span class="line">        logger = <span class="keyword">new</span> LoggingListener(</span><br><span class="line">            <span class="string">"/path/to/log.txt"</span>,</span><br><span class="line">            <span class="string">"有人打开了文件：%s"</span>);</span><br><span class="line">        editor.events.subscribe(<span class="string">"open"</span>, logger)</span><br><span class="line"></span><br><span class="line">        emailAlerts = <span class="keyword">new</span> EmailAlertsListener(</span><br><span class="line">            <span class="string">"admin@example.com"</span>,</span><br><span class="line">            <span class="string">"有人更改了文件：%s"</span>)</span><br><span class="line">        editor.events.subscribe(<span class="string">"save"</span>, emailAlerts)</span><br></pre></td></tr></table></figure>
<h2 id="5-与其他模式的关系"><a class="markdownIt-Anchor" href="#5-与其他模式的关系"></a> 5. 与其他模式的关系</h2>
<ul>
<li><a href="https://refactoringguru.cn/design-patterns/chain-of-responsibility" target="_blank" rel="noopener">责任链模式</a>、 <a href="https://refactoringguru.cn/design-patterns/command" target="_blank" rel="noopener">命令模式</a>、 <a href="https://refactoringguru.cn/design-patterns/mediator" target="_blank" rel="noopener">中介者模式</a>和<a href="https://refactoringguru.cn/design-patterns/observer" target="_blank" rel="noopener">观察者模式</a>用于处理请求发送者和接收者之间的不同连接方式：
<ul>
<li><em>责任链</em>按照顺序将请求动态传递给一系列的潜在接收者， 直至其中一名接收者对请求进行处理。</li>
<li><em>命令</em>在发送者和请求者之间建立单向连接。</li>
<li><em>中介者</em>清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行间接沟通。</li>
<li><em>观察者</em>允许接收者动态地订阅或取消接收请求。</li>
</ul>
</li>
<li><a href="https://refactoringguru.cn/design-patterns/mediator" target="_blank" rel="noopener">中介者</a>和<a href="https://refactoringguru.cn/design-patterns/observer" target="_blank" rel="noopener">观察者</a>之间的区别往往很难记住。 在大部分情况下， 你可以使用其中一种模式， 而有时可以同时使用。 让我们来看看如何做到这一点。
<ul>
<li><em>中介者</em>的主要目标是消除一系列系统组件之间的相互依赖。 这些组件将依赖于同一个中介者对象。 <em>观察者</em>的目标是在对象之间建立动态的单向连接， 使得部分对象可作为其他对象的附属发挥作用。</li>
<li>有一种流行的中介者模式实现方式依赖于<em>观察者</em>。 中介者对象担当发布者的角色， 其他组件则作为订阅者， 可以订阅中介者的事件或取消订阅。 当<em>中介者</em>以这种方式实现时， 它可能看上去与<em>观察者</em>非常相似。</li>
<li>当你感到疑惑时， 记住可以采用其他方式来实现中介者。 例如， 你可永久性地将所有组件链接到同一个中介者对象。 这种实现方式和<em>观察者</em>并不相同， 但这仍是一种中介者模式。</li>
<li>假设有一个程序， 其所有的组件都变成了发布者， 它们之间可以相互建立动态连接。 这样程序中就没有中心化的中介者对象， 而只有一些分布式的观察者。</li>
</ul>
</li>
</ul>
<h2 id="6-案例"><a class="markdownIt-Anchor" href="#6-案例"></a> 6. 案例</h2>
<p><strong>使用示例：</strong> 观察者模式在 Java 代码中很常见， 特别是在 GUI 组件中。 它提供了在不与其他对象所属类耦合的情况下对其事件做出反应的方式。</p>
<p>这里是核心 Java 程序库中该模式的一些示例：</p>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Observer.html" target="_blank" rel="noopener"><code>java.util.Observer</code></a>/<a href="http://docs.oracle.com/javase/8/docs/api/java/util/Observable.html" target="_blank" rel="noopener"> <code>java.util.Observable</code></a> （极少在真实世界中使用）</li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/EventListener.html" target="_blank" rel="noopener"><code>java.util.EventListener</code></a>的所有实现 （几乎广泛存在于 Swing 组件中）</li>
<li><a href="http://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpSessionBindingListener.html" target="_blank" rel="noopener"><code>javax.servlet.http.HttpSessionBindingListener</code></a></li>
<li><a href="http://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpSessionAttributeListener.html" target="_blank" rel="noopener"><code>javax.servlet.http.HttpSessionAttributeListener</code></a></li>
<li><a href="http://docs.oracle.com/javaee/7/api/javax/faces/event/PhaseListener.html" target="_blank" rel="noopener"><code>javax.faces.event.PhaseListener</code></a></li>
</ul>
<p><strong>识别方法：</strong> 该模式可以通过将对象存储在列表中的订阅方法， 和对于面向该列表中对象的更新方法的调用来识别。</p>
<h2 id="7-参考资料"><a class="markdownIt-Anchor" href="#7-参考资料"></a> 7. 参考资料</h2>
<ul>
<li><a href="https://book.douban.com/subject/2243615/" target="_blank" rel="noopener">《Head First 设计模式》</a></li>
<li><a href="https://book.douban.com/subject/2334288/" target="_blank" rel="noopener">《大话设计模式》</a></li>
<li><a href="https://refactoringguru.cn/design-patterns/catalog" target="_blank" rel="noopener">设计模式教程</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/2015/01/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2015/01/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">设计模式之命令模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-01-19 17:20:00" itemprop="dateCreated datePublished" datetime="2015-01-19T17:20:00+08:00">2015-01-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-14 16:45:53" itemprop="dateModified" datetime="2022-04-14T16:45:53+08:00">2022-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index">
                    <span itemprop="name">设计</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2015/01/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/01/19/设计模式之命令模式/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="设计模式之命令模式"><a class="markdownIt-Anchor" href="#设计模式之命令模式"></a> 设计模式之命令模式</h1>
<h2 id="1-意图"><a class="markdownIt-Anchor" href="#1-意图"></a> 1. 意图</h2>
<p><strong>命令模式</strong>（Command） 是一种行为设计模式， 它可将请求转换为一个包含与请求相关的所有信息的独立对象。 该转换让你能根据不同的请求将方法参数化、 延迟请求执行或将其放入队列中， 且能实现可撤销操作。</p>
<h3 id="11-命令模式的交互"><a class="markdownIt-Anchor" href="#11-命令模式的交互"></a> 1.1. 命令模式的交互</h3>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200726110040.png" alt="img" /></p>
<ul>
<li>Client 创建一个 ConcreteCommand 对象并指定他的 Receiver 对象。</li>
<li>某个 Invoker 对象存储该 ConcreteCommand 对象。</li>
<li>该 Invoker 通过调用 Command 对象的 Execute 操作来提交一个请求。若该命令是可撤销的，ConcreteCommand 就在执行 Execute 操作之前存储当前状态以用于取消该命令。</li>
<li>ConcreteCommand 对象对调用它的 Receiver 的一些操作以执行该请求。</li>
</ul>
<h3 id="12-命令模式的要点"><a class="markdownIt-Anchor" href="#12-命令模式的要点"></a> 1.2. 命令模式的要点</h3>
<ul>
<li>命令模式的本质是对命令进行封装，将发出命令的责任和执行命令的责任分割开。</li>
<li>每一个命令都是一个操作：请求的一方发出请求，要求执行一个操作；接收的一方收到请求，并执行操作。</li>
<li>命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。</li>
<li>命令模式使请求本身成为一个对象，这个对象和其他对象一样可以被存储和传递。</li>
<li>命令模式的关键在于引入了抽象命令接口，且发送者针对抽象命令接口编程，只有实现了抽象命令接口的具体命令才能与接收者相关联。</li>
</ul>
<h2 id="2-适用场景"><a class="markdownIt-Anchor" href="#2-适用场景"></a> 2. 适用场景</h2>
<ul>
<li>如果你需要通过操作来参数化对象， 可使用命令模式。</li>
<li>如果你想要将操作放入队列中、 操作的执行或者远程执行操作， 可使用命令模式。</li>
<li>如果你想要实现操作回滚功能， 可使用命令模式。</li>
</ul>
<h2 id="3-结构"><a class="markdownIt-Anchor" href="#3-结构"></a> 3. 结构</h2>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20210519150619.png" alt="img" /></p>
<h3 id="31-结构说明"><a class="markdownIt-Anchor" href="#31-结构说明"></a> 3.1. 结构说明</h3>
<ol>
<li>
<p><strong>发送者</strong> （Sender）——亦称 “触发者 （Invoker）”——类负责对请求进行初始化， 其中必须包含一个成员变量来存储对于命令对象的引用。 发送者触发命令， 而不向接收者直接发送请求。 注意， 发送者并不负责创建命令对象： 它通常会通过构造函数从客户端处获得预先生成的命令。</p>
</li>
<li>
<p><strong>命令</strong> （Command） 接口通常仅声明一个执行命令的方法。</p>
</li>
<li>
<p><strong>具体命令</strong> （Concrete Commands） 会实现各种类型的请求。 具体命令自身并不完成工作， 而是会将调用委派给一个业务逻辑对象。 但为了简化代码， 这些类可以进行合并。</p>
<p>接收对象执行方法所需的参数可以声明为具体命令的成员变量。 你可以将命令对象设为不可变， 仅允许通过构造函数对这些成员变量进行初始化。</p>
</li>
<li>
<p><strong>接收者</strong> （Receiver） 类包含部分业务逻辑。 几乎任何对象都可以作为接收者。 绝大部分命令只处理如何将请求传递到接收者的细节， 接收者自己会完成实际的工作。</p>
</li>
<li>
<p><strong>客户端</strong> （Client） 会创建并配置具体命令对象。 客户端必须将包括接收者实体在内的所有请求参数传递给命令的构造函数。 此后， 生成的命令就可以与一个或多个发送者相关联了。</p>
</li>
</ol>
<h3 id="32-结构代码范式"><a class="markdownIt-Anchor" href="#32-结构代码范式"></a> 3.2. 结构代码范式</h3>
<p><strong>Command</strong> : 用来声明执行操作的接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Receiver receiver;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Command</span><span class="params">(Receiver receiver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ConcreteCommand</strong> : 将一个接收者对象绑定一个动作，调用接收者相应的操作，以实现 Execute。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommand</span> <span class="keyword">extends</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteCommand</span><span class="params">(Receiver receiver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(receiver);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        receiver.Action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Invoker</strong> : 要求该命令执行这个请求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Invoker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Command command;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Invoker</span><span class="params">(Command command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ExecuteCommand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        command.Execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Receiver</strong> : 知道如何实施与执行一个与请求相关的操作，任何类都可能作为一个接收者。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Receiver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行请求"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Client</strong> : 创建一个具体命令对象并设定它的接受者。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Receiver receiver = <span class="keyword">new</span> Receiver();</span><br><span class="line">        Command cmd = <span class="keyword">new</span> ConcreteCommand(receiver);</span><br><span class="line">        Invoker invoker = <span class="keyword">new</span> Invoker(cmd);</span><br><span class="line">        invoker.ExecuteCommand();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-伪代码"><a class="markdownIt-Anchor" href="#4-伪代码"></a> 4. 伪代码</h2>
<p>在本例中， <strong>命令</strong>模式会记录已执行操作的历史记录， 以在需要时撤销操作。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20210519151632.png" alt="img" /></p>
<p>有些命令会改变编辑器的状态 （例如剪切和粘贴）， 它们可在执行相关操作前对编辑器的状态进行备份。 命令执行后会和当前点备份的编辑器状态一起被放入命令历史 （命令对象栈）。 此后， 如果用户需要进行回滚操作， 程序可从历史记录中取出最近的命令， 读取相应的编辑器状态备份， 然后进行恢复。</p>
<p>客户端代码 （GUI 元素和命令历史等） 没有和具体命令类相耦合， 因为它通过命令接口来使用命令。 这使得你能在无需修改已有代码的情况下在程序中增加新的命令。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 命令基类会为所有具体命令定义通用接口。</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Command</span> <span class="title">is</span></span></span><br><span class="line">    protected field app: Application</span><br><span class="line">    <span class="keyword">protected</span> field editor: Editor</span><br><span class="line">    <span class="keyword">protected</span> field backup: text</span><br><span class="line"></span><br><span class="line">    <span class="function">constructor <span class="title">Command</span><span class="params">(app: Application, editor: Editor)</span> is</span></span><br><span class="line"><span class="function">        <span class="keyword">this</span>.app </span>= app</span><br><span class="line">        <span class="keyword">this</span>.editor = editor</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 备份编辑器状态。</span></span><br><span class="line">    <span class="function">method <span class="title">saveBackup</span><span class="params">()</span> is</span></span><br><span class="line"><span class="function">        backup </span>= editor.text</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复编辑器状态。</span></span><br><span class="line">    <span class="function">method <span class="title">undo</span><span class="params">()</span> is</span></span><br><span class="line"><span class="function">        editor.text </span>= backup</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行方法被声明为抽象以强制所有具体命令提供自己的实现。该方法必须根</span></span><br><span class="line">    <span class="comment">// 据命令是否更改编辑器的状态返回 true 或 false。</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> method <span class="title">execute</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 这里是具体命令。</span></span></span><br><span class="line"><span class="function">class CopyCommand extends Command is</span></span><br><span class="line"><span class="function">    <span class="comment">// 复制命令不会被保存到历史记录中，因为它没有改变编辑器的状态。</span></span></span><br><span class="line"><span class="function">    method <span class="title">execute</span><span class="params">()</span> is</span></span><br><span class="line"><span class="function">        app.clipboard </span>= editor.getSelection()</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CutCommand</span> <span class="keyword">extends</span> <span class="title">Command</span> <span class="title">is</span></span></span><br><span class="line"><span class="class">    // 剪切命令改变了编辑器的状态，因此它必须被保存到历史记录中。只要方法</span></span><br><span class="line"><span class="class">    // 返回 <span class="title">true</span>，它就会被保存。</span></span><br><span class="line"><span class="class">    <span class="title">method</span> <span class="title">execute</span>() <span class="title">is</span></span></span><br><span class="line"><span class="class">        <span class="title">saveBackup</span>()</span></span><br><span class="line"><span class="class">        <span class="title">app</span>.<span class="title">clipboard</span> </span>= editor.getSelection()</span><br><span class="line">        editor.deleteSelection()</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PasteCommand</span> <span class="keyword">extends</span> <span class="title">Command</span> <span class="title">is</span></span></span><br><span class="line"><span class="class">    <span class="title">method</span> <span class="title">execute</span>() <span class="title">is</span></span></span><br><span class="line"><span class="class">        <span class="title">saveBackup</span>()</span></span><br><span class="line"><span class="class">        <span class="title">editor</span>.<span class="title">replaceSelection</span>(<span class="title">app</span>.<span class="title">clipboard</span>)</span></span><br><span class="line"><span class="class">        <span class="title">return</span> <span class="title">true</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">// 撤销操作也是一个命令。</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">UndoCommand</span> <span class="keyword">extends</span> <span class="title">Command</span> <span class="title">is</span></span></span><br><span class="line"><span class="class">    <span class="title">method</span> <span class="title">execute</span>() <span class="title">is</span></span></span><br><span class="line"><span class="class">        <span class="title">app</span>.<span class="title">undo</span>()</span></span><br><span class="line"><span class="class">        <span class="title">return</span> <span class="title">false</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">// 全局命令历史记录就是一个堆桟。</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">CommandHistory</span> <span class="title">is</span></span></span><br><span class="line">    private field history: array of Command</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后进...</span></span><br><span class="line">    <span class="function">method <span class="title">push</span><span class="params">(c: Command)</span> is</span></span><br><span class="line"><span class="function">        <span class="comment">// 将命令压入历史记录数组的末尾。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">// ...先出</span></span></span><br><span class="line"><span class="function">    method <span class="title">pop</span><span class="params">()</span>:Command is</span></span><br><span class="line"><span class="function">        <span class="comment">// 从历史记录中取出最近的命令。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 编辑器类包含实际的文本编辑操作。它会担任接收者的角色：最后所有命令都会</span></span></span><br><span class="line"><span class="function"><span class="comment">// 将执行工作委派给编辑器的方法。</span></span></span><br><span class="line"><span class="function">class Editor is</span></span><br><span class="line"><span class="function">    field text: string</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    method <span class="title">getSelection</span><span class="params">()</span> is</span></span><br><span class="line"><span class="function">        <span class="comment">// 返回选中的文字。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    method <span class="title">deleteSelection</span><span class="params">()</span> is</span></span><br><span class="line"><span class="function">        <span class="comment">// 删除选中的文字。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    method <span class="title">replaceSelection</span><span class="params">(text)</span> is</span></span><br><span class="line"><span class="function">        <span class="comment">// 在当前位置插入剪贴板中的内容。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 应用程序类会设置对象之间的关系。它会担任发送者的角色：当需要完成某些工</span></span></span><br><span class="line"><span class="function"><span class="comment">// 作时，它会创建并执行一个命令对象。</span></span></span><br><span class="line"><span class="function">class Application is</span></span><br><span class="line"><span class="function">    field clipboard: string</span></span><br><span class="line"><span class="function">    field editors: array of Editors</span></span><br><span class="line"><span class="function">    field activeEditor: Editor</span></span><br><span class="line"><span class="function">    field history: CommandHistory</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">// 将命令分派给 UI 对象的代码可能会是这样的。</span></span></span><br><span class="line"><span class="function">    method <span class="title">createUI</span><span class="params">()</span> is</span></span><br><span class="line"><span class="function">        <span class="comment">// ...</span></span></span><br><span class="line"><span class="function">        copy </span>= function() &#123; executeCommand(</span><br><span class="line">            <span class="keyword">new</span> CopyCommand(<span class="keyword">this</span>, activeEditor)) &#125;</span><br><span class="line">        copyButton.setCommand(copy)</span><br><span class="line">        shortcuts.onKeyPress(<span class="string">"Ctrl+C"</span>, copy)</span><br><span class="line"></span><br><span class="line">        cut = function() &#123; executeCommand(</span><br><span class="line">            <span class="keyword">new</span> CutCommand(<span class="keyword">this</span>, activeEditor)) &#125;</span><br><span class="line">        cutButton.setCommand(cut)</span><br><span class="line">        shortcuts.onKeyPress(<span class="string">"Ctrl+X"</span>, cut)</span><br><span class="line"></span><br><span class="line">        paste = function() &#123; executeCommand(</span><br><span class="line">            <span class="keyword">new</span> PasteCommand(<span class="keyword">this</span>, activeEditor)) &#125;</span><br><span class="line">        pasteButton.setCommand(paste)</span><br><span class="line">        shortcuts.onKeyPress(<span class="string">"Ctrl+V"</span>, paste)</span><br><span class="line"></span><br><span class="line">        undo = function() &#123; executeCommand(</span><br><span class="line">            <span class="keyword">new</span> UndoCommand(<span class="keyword">this</span>, activeEditor)) &#125;</span><br><span class="line">        undoButton.setCommand(undo)</span><br><span class="line">        shortcuts.onKeyPress(<span class="string">"Ctrl+Z"</span>, undo)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行一个命令并检查它是否需要被添加到历史记录中。</span></span><br><span class="line">    <span class="function">method <span class="title">executeCommand</span><span class="params">(command)</span> is</span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">(command.execute)</span></span></span><br><span class="line"><span class="function">            history.<span class="title">push</span><span class="params">(command)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">// 从历史记录中取出最近的命令并运行其 undo（撤销）方法。请注意，你并</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 不知晓该命令所属的类。但是我们不需要知晓，因为命令自己知道如何撤销</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 其动作。</span></span></span><br><span class="line"><span class="function">    method <span class="title">undo</span><span class="params">()</span> is</span></span><br><span class="line"><span class="function">        command </span>= history.pop()</span><br><span class="line">        <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">            command.undo()</span><br></pre></td></tr></table></figure>
<h2 id="5-与其他模式的关系"><a class="markdownIt-Anchor" href="#5-与其他模式的关系"></a> 5. 与其他模式的关系</h2>
<ul>
<li><a href="https://refactoringguru.cn/design-patterns/chain-of-responsibility" target="_blank" rel="noopener">责任链模式</a>、 <a href="https://refactoringguru.cn/design-patterns/command" target="_blank" rel="noopener">命令模式</a>、 <a href="https://refactoringguru.cn/design-patterns/mediator" target="_blank" rel="noopener">中介者模式</a>和<a href="https://refactoringguru.cn/design-patterns/observer" target="_blank" rel="noopener">观察者模式</a>用于处理请求发送者和接收者之间的不同连接方式：
<ul>
<li><em>责任链</em>按照顺序将请求动态传递给一系列的潜在接收者， 直至其中一名接收者对请求进行处理。</li>
<li><em>命令</em>在发送者和请求者之间建立单向连接。</li>
<li><em>中介者</em>清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行间接沟通。</li>
<li><em>观察者</em>允许接收者动态地订阅或取消接收请求。</li>
</ul>
</li>
<li><a href="https://refactoringguru.cn/design-patterns/chain-of-responsibility" target="_blank" rel="noopener">责任链</a>的管理者可使用<a href="https://refactoringguru.cn/design-patterns/command" target="_blank" rel="noopener">命令模式</a>实现。 在这种情况下， 你可以对由请求代表的同一个上下文对象执行许多不同的操作。<br />
还有另外一种实现方式， 那就是请求自身就是一个<em>命令</em>对象。 在这种情况下， 你可以对由一系列不同上下文连接而成的链执行相同的操作。</li>
<li>你可以同时使用<a href="https://refactoringguru.cn/design-patterns/command" target="_blank" rel="noopener">命令</a>和<a href="https://refactoringguru.cn/design-patterns/memento" target="_blank" rel="noopener">备忘录模式</a>来实现 “撤销”。 在这种情况下， 命令用于对目标对象执行各种不同的操作， 备忘录用来保存一条命令执行前该对象的状态。</li>
<li><a href="https://refactoringguru.cn/design-patterns/command" target="_blank" rel="noopener">命令</a>和<a href="https://refactoringguru.cn/design-patterns/strategy" target="_blank" rel="noopener">策略模式</a>看上去很像， 因为两者都能通过某些行为来参数化对象。 但是， 它们的意图有非常大的不同。
<ul>
<li>你可以使用<em>命令</em>来将任何操作转换为对象。 操作的参数将成为对象的成员变量。 你可以通过转换来延迟操作的执行、 将操作放入队列、 保存历史命令或者向远程服务发送命令等。</li>
<li>另一方面， <em>策略</em>通常可用于描述完成某件事的不同方式， 让你能够在同一个上下文类中切换算法。</li>
</ul>
</li>
<li><a href="https://refactoringguru.cn/design-patterns/prototype" target="_blank" rel="noopener">原型模式</a>可用于保存<a href="https://refactoringguru.cn/design-patterns/command" target="_blank" rel="noopener">命令</a>的历史记录。</li>
<li>你可以将<a href="https://refactoringguru.cn/design-patterns/visitor" target="_blank" rel="noopener">访问者模式</a>视为<a href="https://refactoringguru.cn/design-patterns/command" target="_blank" rel="noopener">命令模式</a>的加强版本， 其对象可对不同类的多种对象执行操作。</li>
</ul>
<h2 id="6-案例"><a class="markdownIt-Anchor" href="#6-案例"></a> 6. 案例</h2>
<p><strong>使用示例</strong>：命令模式在 Java 代码中很常见。 大部分情况下， 它被用于代替包含行为的参数化 UI 元素的回调函数， 此外还被用于对任务进行排序和记录操作历史记录等。</p>
<p>以下是在核心 Java 程序库中的一些示例：</p>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html" target="_blank" rel="noopener"><code>java.lang.Runnable</code></a> 的所有实现</li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/javax/swing/Action.html" target="_blank" rel="noopener"><code>javax.swing.Action</code></a> 的所有实现</li>
</ul>
<p><strong>识别方法：</strong> 命令模式可以通过抽象或接口类型 （发送者） 中的行为方法来识别， 该类型调用另一个不同的抽象或接口类型 （接收者） 实现中的方法， 该实现则是在创建时由命令模式的实现封装。 命令类通常仅限于一些特殊行为。</p>
<h2 id="7-参考资料"><a class="markdownIt-Anchor" href="#7-参考资料"></a> 7. 参考资料</h2>
<ul>
<li><a href="https://book.douban.com/subject/2243615/" target="_blank" rel="noopener">《Head First 设计模式》</a></li>
<li><a href="https://book.douban.com/subject/2334288/" target="_blank" rel="noopener">《大话设计模式》</a></li>
<li><a href="https://refactoringguru.cn/design-patterns/catalog" target="_blank" rel="noopener">设计模式教程</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/2015/01/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2015/01/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">设计模式之迭代器模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-01-19 17:20:00" itemprop="dateCreated datePublished" datetime="2015-01-19T17:20:00+08:00">2015-01-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-14 16:45:53" itemprop="dateModified" datetime="2022-04-14T16:45:53+08:00">2022-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index">
                    <span itemprop="name">设计</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2015/01/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/01/19/设计模式之迭代器模式/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="设计模式之迭代器模式"><a class="markdownIt-Anchor" href="#设计模式之迭代器模式"></a> 设计模式之迭代器模式</h1>
<h2 id="1-意图"><a class="markdownIt-Anchor" href="#1-意图"></a> 1. 意图</h2>
<p><strong>迭代器模式</strong>（Iterator） 是一种行为设计模式， 让你能在不暴露集合底层表现形式 （列表、 栈和树等） 的情况下遍历集合中所有的元素。</p>
<h2 id="2-适用场景"><a class="markdownIt-Anchor" href="#2-适用场景"></a> 2. 适用场景</h2>
<ul>
<li>当集合背后为复杂的数据结构， 且你希望对客户端隐藏其复杂性时 （出于使用便利性或安全性的考虑）， 可以使用迭代器模式。</li>
<li>使用该模式可以减少程序中重复的遍历代码。</li>
<li>如果你希望代码能够遍历不同的甚至是无法预知的数据结构， 可以使用迭代器模式。</li>
</ul>
<h2 id="3-结构"><a class="markdownIt-Anchor" href="#3-结构"></a> 3. 结构</h2>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20210519153411.png" alt="img" /></p>
<h3 id="31-结构说明"><a class="markdownIt-Anchor" href="#31-结构说明"></a> 3.1. 结构说明</h3>
<ol>
<li><strong>迭代器</strong> （Iterator） 接口声明了遍历集合所需的操作： 获取下一个元素、 获取当前位置和重新开始迭代等。</li>
<li><strong>具体迭代器</strong> （Concrete Iterators） 实现遍历集合的一种特定算法。 迭代器对象必须跟踪自身遍历的进度。 这使得多个迭代器可以相互独立地遍历同一集合。</li>
<li><strong>集合</strong> （Collection） 接口声明一个或多个方法来获取与集合兼容的迭代器。 请注意， 返回方法的类型必须被声明为迭代器接口， 因此具体集合可以返回各种不同种类的迭代器。</li>
<li><strong>具体集合</strong> （Concrete Collections） 会在客户端请求迭代器时返回一个特定的具体迭代器类实体。 你可能会琢磨， 剩下的集合代码在什么地方呢？ 不用担心， 它也会在同一个类中。 只是这些细节对于实际模式来说并不重要， 所以我们将其省略了而已。</li>
<li><strong>客户端</strong> （Client） 通过集合和迭代器的接口与两者进行交互。 这样一来客户端无需与具体类进行耦合， 允许同一客户端代码使用各种不同的集合和迭代器。
<ul>
<li>客户端通常不会自行创建迭代器， 而是会从集合中获取。 但在特定情况下， 客户端可以直接创建一个迭代器 （例如当客户端需要自定义特殊迭代器时）。</li>
</ul>
</li>
</ol>
<h3 id="32-结构代码范式"><a class="markdownIt-Anchor" href="#32-结构代码范式"></a> 3.2. 结构代码范式</h3>
<p><strong>Iterator</strong> : 定义访问元素的接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">first</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">currentItem</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ConcreteIterator</strong> : 实现 Iterator 接口。记录当前访问的元素在集合中的位置信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> current = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> ConcreteAggregate aggregate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteIterator</span><span class="params">(ConcreteAggregate aggregate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.aggregate = aggregate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">first</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> aggregate.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        current++;</span><br><span class="line">        <span class="keyword">if</span> (current &lt; aggregate.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> aggregate.get(current);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (current &gt;= aggregate.size()) ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">currentItem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> aggregate.get(current);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Aggregate</strong> : 定义创建 Iterator 对象的接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Aggregate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">CreateIterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ConcreteAggregate</strong> : 实现 Iterator 接口，返回一个合适的 ConcreteIterator 实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteAggregate</span> <span class="keyword">implements</span> <span class="title">Aggregate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; items = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">CreateIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteIterator(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items.get(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, Object element)</span> </span>&#123;</span><br><span class="line">        items.set(index, element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object element)</span> </span>&#123;</span><br><span class="line">        items.add(element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IteratorPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConcreteAggregate aggregate = <span class="keyword">new</span> ConcreteAggregate();</span><br><span class="line">        aggregate.add(<span class="string">"张三"</span>);</span><br><span class="line">        aggregate.add(<span class="string">"李四"</span>);</span><br><span class="line">        aggregate.add(<span class="string">"王五"</span>);</span><br><span class="line">        aggregate.add(<span class="string">"赵六"</span>);</span><br><span class="line"></span><br><span class="line">        Iterator iter = <span class="keyword">new</span> ConcreteIterator(aggregate);</span><br><span class="line">        Object item = iter.first();</span><br><span class="line">        System.out.println(<span class="string">"第一个人是："</span> + item);</span><br><span class="line">        System.out.println(<span class="string">"所有人的名单是："</span>);</span><br><span class="line">        <span class="keyword">while</span> (!iter.isDone()) &#123;</span><br><span class="line">            System.out.println(iter.currentItem());</span><br><span class="line">            iter.next();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一个人是：张三</span><br><span class="line">所有人的名单是：</span><br><span class="line">张三</span><br><span class="line">李四</span><br><span class="line">王五</span><br><span class="line">赵六</span><br></pre></td></tr></table></figure>
<h2 id="4-伪代码"><a class="markdownIt-Anchor" href="#4-伪代码"></a> 4. 伪代码</h2>
<p>在本例中， <strong>迭代器</strong>模式用于遍历一个封装了访问微信好友关系功能的特殊集合。 该集合提供使用不同方式遍历档案资料的多个迭代器。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20210519153656.png" alt="img" /></p>
<p>“好友 （friends）” 迭代器可用于遍历指定档案的好友。 “同事 （colleagues）” 迭代器也提供同样的功能， 但仅包括与目标用户在同一家公司工作的好友。 这两个迭代器都实现了同一个通用接口， 客户端能在不了解认证和发送 REST 请求等实现细节的情况下获取档案。</p>
<p>客户端仅通过接口与集合和迭代器交互， 也就不会同具体类耦合。 如果你决定将应用连接到全新的社交网络， 只需提供新的集合和迭代器类即可， 无需修改现有代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 集合接口必须声明一个用于生成迭代器的工厂方法。如果程序中有不同类型的迭</span></span><br><span class="line"><span class="comment">// 代器，你也可以声明多个方法。</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SocialNetwork</span> <span class="title">is</span></span></span><br><span class="line">    method createFriendsIterator(profileId):ProfileIterator</span><br><span class="line">    <span class="function">method <span class="title">createCoworkersIterator</span><span class="params">(profileId)</span>:ProfileIterator</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 每个具体集合都与其返回的一组具体迭代器相耦合。但客户并不是这样的，因为</span></span></span><br><span class="line"><span class="function"><span class="comment">// 这些方法的签名将会返回迭代器接口。</span></span></span><br><span class="line"><span class="function">class WeChat implements SocialNetwork is</span></span><br><span class="line"><span class="function">    <span class="comment">// ...大量的集合代码应该放在这里...</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">// 迭代器创建代码。</span></span></span><br><span class="line"><span class="function">    method <span class="title">createFriendsIterator</span><span class="params">(profileId)</span> is</span></span><br><span class="line"><span class="function">        return new <span class="title">WeChatIterator</span><span class="params">(<span class="keyword">this</span>, profileId, <span class="string">"friends"</span>)</span></span></span><br><span class="line"><span class="function">    method <span class="title">createCoworkersIterator</span><span class="params">(profileId)</span> is</span></span><br><span class="line"><span class="function">        return new <span class="title">WeChatIterator</span><span class="params">(<span class="keyword">this</span>, profileId, <span class="string">"coworkers"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 所有迭代器的通用接口。</span></span></span><br><span class="line"><span class="function">interface ProfileIterator is</span></span><br><span class="line"><span class="function">    method <span class="title">getNext</span><span class="params">()</span>:Profile</span></span><br><span class="line"><span class="function">    method <span class="title">hasMore</span><span class="params">()</span>:bool</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 具体迭代器类。</span></span></span><br><span class="line"><span class="function">class WeChatIterator implements ProfileIterator is</span></span><br><span class="line"><span class="function">    <span class="comment">// 迭代器需要一个指向其遍历集合的引用。</span></span></span><br><span class="line"><span class="function">    <span class="keyword">private</span> field weChat: WeChat</span></span><br><span class="line"><span class="function">    <span class="keyword">private</span> field profileId, type: string</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">// 迭代器对象会独立于其他迭代器来对集合进行遍历。因此它必须保存迭代器</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 的状态。</span></span></span><br><span class="line"><span class="function">    <span class="keyword">private</span> field currentPosition</span></span><br><span class="line"><span class="function">    <span class="keyword">private</span> field cache: array of Profile</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    constructor <span class="title">WeChatIterator</span><span class="params">(weChat, profileId, type)</span> is</span></span><br><span class="line"><span class="function">        <span class="keyword">this</span>.weChat </span>= weChat</span><br><span class="line">        <span class="keyword">this</span>.profileId = profileId</span><br><span class="line">        <span class="keyword">this</span>.type = type</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> method <span class="title">lazyInit</span><span class="params">()</span> is</span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">(cache == <span class="keyword">null</span>)</span></span></span><br><span class="line"><span class="function">            cache </span>= weChat.socialGraphRequest(profileId, type)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每个具体迭代器类都会自行实现通用迭代器接口。</span></span><br><span class="line">    <span class="function">method <span class="title">getNext</span><span class="params">()</span> is</span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">(hasMore()</span>)</span></span><br><span class="line"><span class="function">            currentPosition++</span></span><br><span class="line"><span class="function">            return cache[currentPosition]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    method <span class="title">hasMore</span><span class="params">()</span> is</span></span><br><span class="line"><span class="function">        <span class="title">lazyInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        return currentPosition &lt; cache.length</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 这里还有一个有用的绝招：你可将迭代器传递给客户端类，无需让其拥有访问整</span></span></span><br><span class="line"><span class="function"><span class="comment">// 个集合的权限。这样一来，你就无需将集合暴露给客户端了。</span></span></span><br><span class="line"><span class="function"><span class="comment">//</span></span></span><br><span class="line"><span class="function"><span class="comment">// 还有另一个好处：你可在运行时将不同的迭代器传递给客户端，从而改变客户端</span></span></span><br><span class="line"><span class="function"><span class="comment">// 与集合互动的方式。这一方法可行的原因是客户端代码并没有和具体迭代器类相</span></span></span><br><span class="line"><span class="function"><span class="comment">// 耦合。</span></span></span><br><span class="line"><span class="function">class SocialSpammer is</span></span><br><span class="line"><span class="function">    method <span class="title">send</span><span class="params">(iterator: ProfileIterator, message: string)</span> is</span></span><br><span class="line"><span class="function">        <span class="title">while</span> <span class="params">(iterator.hasMore()</span>)</span></span><br><span class="line"><span class="function">            profile </span>= iterator.getNext()</span><br><span class="line">            System.sendEmail(profile.getEmail(), message)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用程序（Application）类可对集合和迭代器进行配置，然后将其传递给客户</span></span><br><span class="line"><span class="comment">// 端代码。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Application</span> <span class="title">is</span></span></span><br><span class="line">    field network: SocialNetwork</span><br><span class="line">    field spammer: SocialSpammer</span><br><span class="line"></span><br><span class="line">    <span class="function">method <span class="title">config</span><span class="params">()</span> is</span></span><br><span class="line"><span class="function">        <span class="keyword">if</span> working with WeChat</span></span><br><span class="line"><span class="function">            <span class="keyword">this</span>.network </span>= <span class="keyword">new</span> WeChat()</span><br><span class="line">        <span class="keyword">if</span> working with LinkedIn</span><br><span class="line">            <span class="keyword">this</span>.network = <span class="keyword">new</span> LinkedIn()</span><br><span class="line">        <span class="keyword">this</span>.spammer = <span class="keyword">new</span> SocialSpammer()</span><br><span class="line"></span><br><span class="line">    <span class="function">method <span class="title">sendSpamToFriends</span><span class="params">(profile)</span> is</span></span><br><span class="line"><span class="function">        iterator </span>= network.createFriendsIterator(profile.getId())</span><br><span class="line">        spammer.send(iterator, <span class="string">"非常重要的消息"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function">method <span class="title">sendSpamToCoworkers</span><span class="params">(profile)</span> is</span></span><br><span class="line"><span class="function">        iterator </span>= network.createCoworkersIterator(profile.getId())</span><br><span class="line">        spammer.send(iterator, <span class="string">"非常重要的消息"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="5-与其他模式的关系"><a class="markdownIt-Anchor" href="#5-与其他模式的关系"></a> 5. 与其他模式的关系</h2>
<ul>
<li>你可以使用<a href="https://refactoringguru.cn/design-patterns/iterator" target="_blank" rel="noopener">迭代器模式</a>来遍历<a href="https://refactoringguru.cn/design-patterns/composite" target="_blank" rel="noopener">组合模式</a>树。</li>
<li>你可以同时使用<a href="https://refactoringguru.cn/design-patterns/factory-method" target="_blank" rel="noopener">工厂方法模式</a>和<a href="https://refactoringguru.cn/design-patterns/iterator" target="_blank" rel="noopener">迭代器</a>来让子类集合返回不同类型的迭代器， 并使得迭代器与集合相匹配。</li>
<li>你可以同时使用<a href="https://refactoringguru.cn/design-patterns/memento" target="_blank" rel="noopener">备忘录模式</a>和<a href="https://refactoringguru.cn/design-patterns/iterator" target="_blank" rel="noopener">迭代器</a>来获取当前迭代器的状态， 并且在需要的时候进行回滚。</li>
<li>可以同时使用<a href="https://refactoringguru.cn/design-patterns/visitor" target="_blank" rel="noopener">访问者模式</a>和<a href="https://refactoringguru.cn/design-patterns/iterator" target="_blank" rel="noopener">迭代器</a>来遍历复杂数据结构， 并对其中的元素执行所需操作， 即使这些元素所属的类完全不同。</li>
</ul>
<h2 id="6-案例"><a class="markdownIt-Anchor" href="#6-案例"></a> 6. 案例</h2>
<p><strong>使用示例：</strong> 该模式在 Java 代码中很常见。 许多框架和程序库都会使用它来提供遍历其集合的标准方式。</p>
<p>下面是该模式在核心 Java 程序库中的一些示例：</p>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html" target="_blank" rel="noopener"><code>java.util.Iterator</code></a>的所有实现 （还有 <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Scanner.html" target="_blank" rel="noopener"><code>java.util.Scanner</code></a>）。</li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Enumeration.html" target="_blank" rel="noopener"><code>java.util.Enumeration</code></a>的所有实现</li>
</ul>
<p><strong>识别方法：</strong> 迭代器可以通过导航方法 （例如 <code>next</code>和 <code>previous</code>等） 来轻松识别。 使用迭代器的客户端代码可能没有其所遍历的集合的直接访问权限。</p>
<h2 id="7-参考资料"><a class="markdownIt-Anchor" href="#7-参考资料"></a> 7. 参考资料</h2>
<ul>
<li><a href="https://book.douban.com/subject/2243615/" target="_blank" rel="noopener">《Head First 设计模式》</a></li>
<li><a href="https://book.douban.com/subject/2334288/" target="_blank" rel="noopener">《大话设计模式》</a></li>
<li><a href="https://refactoringguru.cn/design-patterns/catalog" target="_blank" rel="noopener">设计模式教程</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/2015/01/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2015/01/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">设计模式之外观模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-01-19 15:15:00" itemprop="dateCreated datePublished" datetime="2015-01-19T15:15:00+08:00">2015-01-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-14 16:45:53" itemprop="dateModified" datetime="2022-04-14T16:45:53+08:00">2022-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index">
                    <span itemprop="name">设计</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2015/01/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/01/19/设计模式之外观模式/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="设计模式之外观模式"><a class="markdownIt-Anchor" href="#设计模式之外观模式"></a> 设计模式之外观模式</h1>
<h2 id="1-意图"><a class="markdownIt-Anchor" href="#1-意图"></a> 1. 意图</h2>
<p><strong>外观模式</strong> (Facade) 是一种结构型设计模式， 为子系统中的<strong>一组接口</strong>提供一个一致的界面，此模式定义了<strong>一个高层接口</strong>，这个接口使得这一子系统更加容易使用。</p>
<ul>
<li>外观模式为复杂子系统提供了一个简单接口，并不为子系统添加新的功能和行为。</li>
<li>外观模式实现了子系统与客户之间的松耦合关系。</li>
<li>外观模式没有封装子系统的类，只是提供了简单的接口。 如果应用需要，它并不限制客户使用子系统类。因此可以再系统易用性与通用性之间选择。</li>
<li>外观模式注重的是简化接口，它更多的时候是从架构的层次去看整个系统，而并非单个类的层次。</li>
</ul>
<h2 id="2-适用场景"><a class="markdownIt-Anchor" href="#2-适用场景"></a> 2. 适用场景</h2>
<ul>
<li>如果你需要一个指向复杂子系统的直接接口， 且该接口的功能有限， 则可以使用外观模式。</li>
<li>如果需要将子系统组织为多层结构， 可以使用外观。</li>
</ul>
<h2 id="3-结构"><a class="markdownIt-Anchor" href="#3-结构"></a> 3. 结构</h2>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20210430174751.png" alt="img" /></p>
<h3 id="31-结构说明"><a class="markdownIt-Anchor" href="#31-结构说明"></a> 3.1. 结构说明</h3>
<ol>
<li>
<p><strong>外观</strong> （Facade） 提供了一种访问特定子系统功能的便捷方式， 其了解如何重定向客户端请求， 知晓如何操作一切活动部件。</p>
</li>
<li>
<p>创建<strong>附加外观</strong> （Additional Facade） 类可以避免多种不相关的功能污染单一外观， 使其变成又一个复杂结构。 客户端和其他外观都可使用附加外观。</p>
</li>
<li>
<p><strong>复杂子系统</strong> （Complex Subsystem） 由数十个不同对象构成。 如果要用这些对象完成有意义的工作， 你必须深入了解子系统的实现细节， 比如按照正确顺序初始化对象和为其提供正确格式的数据。</p>
<p>子系统类不会意识到外观的存在， 它们在系统内运作并且相互之间可直接进行交互。</p>
</li>
<li>
<p><strong>客户端</strong> （Client） 使用外观代替对子系统对象的直接调用。</p>
</li>
</ol>
<h3 id="32-结构代码范式"><a class="markdownIt-Anchor" href="#32-结构代码范式"></a> 3.2. 结构代码范式</h3>
<p><strong>Facade</strong> : 了解每个子系统类的功能，负责分发客户端的请求给各个子系统去处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">op1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"方法1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">op2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"方法2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">op3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"方法3"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Subsystem Classes</strong> : 实现子系统功能。在不感知 Facade 的情况下，处理 Facade 对象分配的工作，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Facade</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Class1 one = <span class="keyword">new</span> Class1();</span><br><span class="line">    <span class="keyword">private</span> Class2 two = <span class="keyword">new</span> Class2();</span><br><span class="line">    <span class="keyword">private</span> Class3 three = <span class="keyword">new</span> Class3();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">op1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Facade op1()"</span>);</span><br><span class="line">        one.op1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">op2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Facade op2()"</span>);</span><br><span class="line">        two.op2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">op3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Facade op3()"</span>);</span><br><span class="line">        three.op3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Facade Method()"</span>);</span><br><span class="line">        three.op3();</span><br><span class="line">        two.op2();</span><br><span class="line">        one.op1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【客户端】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FacadePattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Facade facade = <span class="keyword">new</span> Facade();</span><br><span class="line">        facade.Method();</span><br><span class="line"></span><br><span class="line">        facade.op1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【输出】</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">Facade <span class="function"><span class="keyword">Method</span><span class="params">()</span></span></span><br><span class="line"><span class="function">方法3</span></span><br><span class="line"><span class="function">方法2</span></span><br><span class="line"><span class="function">方法1</span></span><br><span class="line"><span class="function"><span class="title">Facade</span> <span class="title">op1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">方法1</span></span><br></pre></td></tr></table></figure>
<h2 id="4-伪代码"><a class="markdownIt-Anchor" href="#4-伪代码"></a> 4. 伪代码</h2>
<p>在本例中， <strong>外观</strong>模式简化了客户端与复杂视频转换框架之间的交互。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20210430175224.png" alt="img" /></p>
<p>你可以创建一个封装所需功能并隐藏其他代码的外观类， 从而无需使全部代码直接与数十个框架类进行交互。 该结构还能将未来框架升级或更换所造成的影响最小化， 因为你只需修改程序中外观方法的实现即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里有复杂第三方视频转换框架中的一些类。我们不知晓其中的代码，因此无法</span></span><br><span class="line"><span class="comment">// 对其进行简化。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VideoFile</span></span></span><br><span class="line"><span class="class">// ...</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">OggCompressionCodec</span></span></span><br><span class="line"><span class="class">// ...</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">MPEG4CompressionCodec</span></span></span><br><span class="line"><span class="class">// ...</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">CodecFactory</span></span></span><br><span class="line"><span class="class">// ...</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">BitrateReader</span></span></span><br><span class="line"><span class="class">// ...</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">AudioMixer</span></span></span><br><span class="line"><span class="class">// ...</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">// 为了将框架的复杂性隐藏在一个简单接口背后，我们创建了一个外观类。它是在</span></span><br><span class="line"><span class="class">// 功能性和简洁性之间做出的权衡。</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">VideoConverter</span> <span class="title">is</span></span></span><br><span class="line">    method convert(filename, format):File is</span><br><span class="line">        file = <span class="keyword">new</span> VideoFile(filename)</span><br><span class="line">        sourceCodec = <span class="keyword">new</span> CodecFactory.extract(file)</span><br><span class="line">        <span class="keyword">if</span> (format == <span class="string">"mp4"</span>)</span><br><span class="line">            destinationCodec = <span class="keyword">new</span> MPEG4CompressionCodec()</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            destinationCodec = <span class="keyword">new</span> OggCompressionCodec()</span><br><span class="line">        buffer = BitrateReader.read(filename, sourceCodec)</span><br><span class="line">        result = BitrateReader.convert(buffer, destinationCodec)</span><br><span class="line">        result = (<span class="keyword">new</span> AudioMixer()).fix(result)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> File(result)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用程序的类并不依赖于复杂框架中成千上万的类。同样，如果你决定更换框架，</span></span><br><span class="line"><span class="comment">// 那只需重写外观类即可。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Application</span> <span class="title">is</span></span></span><br><span class="line"><span class="class">    <span class="title">method</span> <span class="title">main</span>() <span class="title">is</span></span></span><br><span class="line"><span class="class">        <span class="title">convertor</span> </span>= <span class="keyword">new</span> VideoConverter()</span><br><span class="line">        mp4 = convertor.convert(<span class="string">"funny-cats-video.ogg"</span>, <span class="string">"mp4"</span>)</span><br><span class="line">        mp4.save()</span><br></pre></td></tr></table></figure>
<h2 id="5-案例"><a class="markdownIt-Anchor" href="#5-案例"></a> 5. 案例</h2>
<p><strong>使用示例：</strong> 使用 Java 开发的程序中经常会使用外观模式。 它在与复杂程序库和 API 协作时特别有用。</p>
<p>下面是一些核心 Java 程序库中的外观示例：</p>
<ul>
<li><a href="http://docs.oracle.com/javaee/7/api/javax/faces/context/FacesContext.html" target="_blank" rel="noopener"><code>javax.faces.context.FacesContext</code></a> 在底层使用了 <a href="http://docs.oracle.com/javaee/7/api/javax/faces/lifecycle/Lifecycle.html" target="_blank" rel="noopener"><code>Life­Cycle</code></a>、 <a href="http://docs.oracle.com/javaee/7/api/javax/faces/application/ViewHandler.html" target="_blank" rel="noopener"><code>View­Handler</code></a> 和 <a href="http://docs.oracle.com/javaee/7/api/javax/faces/application/NavigationHandler.html" target="_blank" rel="noopener"><code>Navigation­Handler</code></a> 这几个类， 但绝大多数客户端不知道。</li>
<li><a href="http://docs.oracle.com/javaee/7/api/javax/faces/context/ExternalContext.html" target="_blank" rel="noopener"><code>javax.faces.context.ExternalContext</code></a> 在内部使用了 <a href="http://docs.oracle.com/javaee/7/api/javax/servlet/ServletContext.html" target="_blank" rel="noopener"><code>Servlet­Context</code></a>、 <a href="http://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpSession.html" target="_blank" rel="noopener"><code>Http­Session</code></a>、 <a href="http://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServletRequest.html" target="_blank" rel="noopener"><code>Http­Servlet­Request</code></a>、 <a href="http://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServletResponse.html" target="_blank" rel="noopener"><code>Http­Servlet­Response</code></a> 和其他一些类。</li>
</ul>
<p><strong>识别方法</strong>： 外观可以通过使用简单接口， 但将绝大部分工作委派给其他类的类来识别。 通常情况下， 外观管理着其所使用的对象的完整生命周期。</p>
<h2 id="6-与其他模式的关系"><a class="markdownIt-Anchor" href="#6-与其他模式的关系"></a> 6. 与其他模式的关系</h2>
<ul>
<li><a href="https://refactoringguru.cn/design-patterns/facade" target="_blank" rel="noopener">外观模式</a>为现有对象定义了一个新接口， <a href="https://refactoringguru.cn/design-patterns/adapter" target="_blank" rel="noopener">适配器模式</a>则会试图运用已有的接口。 <em>适配器</em>通常只封装一个对象， <em>外观</em>通常会作用于整个对象子系统上。</li>
<li>当只需对客户端代码隐藏子系统创建对象的方式时， 你可以使用<a href="https://refactoringguru.cn/design-patterns/abstract-factory" target="_blank" rel="noopener">抽象工厂模式</a>来代替<a href="https://refactoringguru.cn/design-patterns/facade" target="_blank" rel="noopener">外观</a>。</li>
<li><a href="https://refactoringguru.cn/design-patterns/flyweight" target="_blank" rel="noopener">享元模式</a>展示了如何生成大量的小型对象， <a href="https://refactoringguru.cn/design-patterns/facade" target="_blank" rel="noopener">外观</a>则展示了如何用一个对象来代表整个子系统。</li>
<li><a href="https://refactoringguru.cn/design-patterns/facade" target="_blank" rel="noopener">外观</a>和<a href="https://refactoringguru.cn/design-patterns/mediator" target="_blank" rel="noopener">中介者模式</a>的职责类似： 它们都尝试在大量紧密耦合的类中组织起合作。
<ul>
<li><em>外观</em>为子系统中的所有对象定义了一个简单接口， 但是它不提供任何新功能。 子系统本身不会意识到外观的存在。 子系统中的对象可以直接进行交流。</li>
<li><em>中介者</em>将系统中组件的沟通行为中心化。 各组件只知道中介者对象， 无法直接相互交流。</li>
</ul>
</li>
<li><a href="https://refactoringguru.cn/design-patterns/facade" target="_blank" rel="noopener">外观</a>类通常可以转换为<a href="https://refactoringguru.cn/design-patterns/singleton" target="_blank" rel="noopener">单例模式</a>类， 因为在大部分情况下一个外观对象就足够了。</li>
<li><a href="https://refactoringguru.cn/design-patterns/facade" target="_blank" rel="noopener">外观</a>与<a href="https://refactoringguru.cn/design-patterns/proxy" target="_blank" rel="noopener">代理模式</a>的相似之处在于它们都缓存了一个复杂实体并自行对其进行初始化。 <em>代理</em>与其服务对象遵循同一接口， 使得自己和服务对象可以互换， 在这一点上它与<em>外观</em>不同。</li>
</ul>
<h2 id="7-参考资料"><a class="markdownIt-Anchor" href="#7-参考资料"></a> 7. 参考资料</h2>
<ul>
<li><a href="https://book.douban.com/subject/2243615/" target="_blank" rel="noopener">《Head First 设计模式》</a></li>
<li><a href="https://book.douban.com/subject/2334288/" target="_blank" rel="noopener">《大话设计模式》</a></li>
<li><a href="https://refactoringguru.cn/design-patterns/catalog" target="_blank" rel="noopener">设计模式教程</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/2015/01/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2015/01/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">设计模式之代理模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-01-19 11:38:00" itemprop="dateCreated datePublished" datetime="2015-01-19T11:38:00+08:00">2015-01-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-14 16:45:53" itemprop="dateModified" datetime="2022-04-14T16:45:53+08:00">2022-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index">
                    <span itemprop="name">设计</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2015/01/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/01/19/设计模式之代理模式/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="设计模式之代理模式"><a class="markdownIt-Anchor" href="#设计模式之代理模式"></a> 设计模式之代理模式</h1>
<h2 id="1-意图"><a class="markdownIt-Anchor" href="#1-意图"></a> 1. 意图</h2>
<p><strong>代理模式</strong> (Proxy) 是一种结构型设计模式， 为其他对象提供一种<strong>代理</strong>以控制对这个对象的<strong>访问</strong>。</p>
<ul>
<li>代理模式介绍了一种访问对象的间接等级。</li>
<li>一个远程代理可以隐藏一个对象在不同地址空间的细节。</li>
<li>一个虚拟代理可以根据需要最优化创建对象的开销。</li>
<li>而安全代理和智能指引都允许访问对象的同时处理其他事务。</li>
</ul>
<h2 id="2-适用场景"><a class="markdownIt-Anchor" href="#2-适用场景"></a> 2. 适用场景</h2>
<ul>
<li><strong>延迟初始化 （虚拟代理）</strong>。 如果你有一个偶尔使用的重量级服务对象， 一直保持该对象运行会消耗系统资源时， 可使用代理模式。</li>
<li><strong>访问控制 （保护代理）</strong>。 如果你只希望特定客户端使用服务对象， 这里的对象可以是操作系统中非常重要的部分， 而客户端则是各种已启动的程序 （包括恶意程序）， 此时可使用代理模式。</li>
<li><strong>本地执行远程服务 （远程代理）</strong>。 适用于服务对象位于远程服务器上的情形。</li>
<li><strong>记录日志请求 （日志记录代理）</strong>。 适用于当你需要保存对于服务对象的请求历史记录时。 代理可以在向服务传递请求前进行记录。</li>
<li><strong>智能引用</strong>。 可在没有客户端使用某个重量级对象时立即销毁该对象。</li>
</ul>
<h2 id="3-结构"><a class="markdownIt-Anchor" href="#3-结构"></a> 3. 结构</h2>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20210430184301.png" alt="img" /></p>
<h3 id="31-结构说明"><a class="markdownIt-Anchor" href="#31-结构说明"></a> 3.1. 结构说明</h3>
<ol>
<li><strong>服务接口</strong> （Service Interface） 声明了服务接口。 代理必须遵循该接口才能伪装成服务对象。</li>
<li><strong>服务</strong> （Service） 类提供了一些实用的业务逻辑。</li>
<li><strong>代理</strong> （Proxy） 类包含一个指向服务对象的引用成员变量。 代理完成其任务 （例如延迟初始化、 记录日志、 访问控制和缓存等） 后会将请求传递给服务对象。 通常情况下， 代理会对其服务对象的整个生命周期进行管理。</li>
<li><strong>客户端</strong> （Client） 能通过同一接口与服务或代理进行交互， 所以你可在一切需要服务对象的代码中使用代理。</li>
</ol>
<h3 id="32-结构代码范式"><a class="markdownIt-Anchor" href="#32-结构代码范式"></a> 3.2. 结构代码范式</h3>
<p><strong>Subject</strong> : 定义了 RealSubject 和 Proxy 的公共接口，这样就在任何使用 RealSubject 的地方都可以使用 Proxy 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>RealSubject</strong> : 定义 Proxy 所代表的真实实体。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">extends</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"真实的请求"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Proxy</strong> : 保存一个引用使得代理可以访问实体，并提供一个与 Subject 的接口相同的接口，这样代理就可以用来替代实体。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">extends</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RealSubject real;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == real) &#123;</span><br><span class="line">            real = <span class="keyword">new</span> RealSubject();</span><br><span class="line">        &#125;</span><br><span class="line">        real.Request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-伪代码"><a class="markdownIt-Anchor" href="#4-伪代码"></a> 4. 伪代码</h2>
<p>本例演示如何使用<strong>代理</strong>模式在第三方腾讯视频 （TencentVideo， 代码示例中记为 TV） 程序库中添加延迟初始化和缓存。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20210430184525.png" alt="img" /></p>
<p>程序库提供了视频下载类。 但是该类的效率非常低。 如果客户端程序多次请求同一视频， 程序库会反复下载该视频， 而不会将首次下载的文件缓存下来复用。</p>
<p>代理类实现和原下载器相同的接口， 并将所有工作委派给原下载器。 不过， 代理类会保存所有的文件下载记录， 如果程序多次请求同一文件， 它会返回缓存的文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 远程服务接口。</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ThirdPartyTVLib</span> <span class="title">is</span></span></span><br><span class="line"><span class="class">    <span class="title">method</span> <span class="title">listVideos</span>()</span></span><br><span class="line"><span class="class">    <span class="title">method</span> <span class="title">getVideoInfo</span>(<span class="title">id</span>)</span></span><br><span class="line"><span class="class">    <span class="title">method</span> <span class="title">downloadVideo</span>(<span class="title">id</span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">// 服务连接器的具体实现。该类的方法可以向腾讯视频请求信息。请求速度取决于</span></span><br><span class="line"><span class="class">// 用户和腾讯视频的互联网连接情况。如果同时发送大量请求，即使所请求的信息</span></span><br><span class="line"><span class="class">// 一模一样，程序的速度依然会减慢。</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">ThirdPartyTVClass</span> <span class="keyword">implements</span> <span class="title">ThirdPartyTVLib</span> <span class="title">is</span></span></span><br><span class="line"><span class="class">    <span class="title">method</span> <span class="title">listVideos</span>() <span class="title">is</span></span></span><br><span class="line"><span class="class">        // 向腾讯视频发送一个 <span class="title">API</span> 请求。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    <span class="title">method</span> <span class="title">getVideoInfo</span>(<span class="title">id</span>) <span class="title">is</span></span></span><br><span class="line"><span class="class">        // 获取某个视频的元数据。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    <span class="title">method</span> <span class="title">downloadVideo</span>(<span class="title">id</span>) <span class="title">is</span></span></span><br><span class="line"><span class="class">        // 从腾讯视频下载一个视频文件。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">// 为了节省网络带宽，我们可以将请求结果缓存下来并保存一段时间。但你可能无</span></span><br><span class="line"><span class="class">// 法直接将这些代码放入服务类中。比如该类可能是第三方程序库的一部分或其签</span></span><br><span class="line"><span class="class">// 名是`<span class="title">final</span>（最终）`。因此我们会在一个实现了服务类接口的新代理类中放入</span></span><br><span class="line"><span class="class">// 缓存代码。当代理类接收到真实请求后，才会将其委派给服务对象。</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">CachedTVClass</span> <span class="keyword">implements</span> <span class="title">ThirdPartyTVLib</span> <span class="title">is</span></span></span><br><span class="line">    private field service: ThirdPartyTVLib</span><br><span class="line">    <span class="keyword">private</span> field listCache, videoCache</span><br><span class="line">    field needReset</span><br><span class="line"></span><br><span class="line">    <span class="function">constructor <span class="title">CachedTVClass</span><span class="params">(service: ThirdPartyTVLib)</span> is</span></span><br><span class="line"><span class="function">        <span class="keyword">this</span>.service </span>= service</span><br><span class="line"></span><br><span class="line">    <span class="function">method <span class="title">listVideos</span><span class="params">()</span> is</span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">(listCache == <span class="keyword">null</span> || needReset)</span></span></span><br><span class="line"><span class="function">            listCache </span>= service.listVideos()</span><br><span class="line">        <span class="keyword">return</span> listCache</span><br><span class="line"></span><br><span class="line">    <span class="function">method <span class="title">getVideoInfo</span><span class="params">(id)</span> is</span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">(videoCache == <span class="keyword">null</span> || needReset)</span></span></span><br><span class="line"><span class="function">            videoCache </span>= service.getVideoInfo(id)</span><br><span class="line">        <span class="keyword">return</span> videoCache</span><br><span class="line"></span><br><span class="line">    <span class="function">method <span class="title">downloadVideo</span><span class="params">(id)</span> is</span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">(!downloadExists(id)</span> || needReset)</span></span><br><span class="line"><span class="function">            service.<span class="title">downloadVideo</span><span class="params">(id)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 之前直接与服务对象交互的 GUI 类不需要改变，前提是它仅通过接口与服务对</span></span></span><br><span class="line"><span class="function"><span class="comment">// 象交互。我们可以安全地传递一个代理对象来代替真实服务对象，因为它们都实</span></span></span><br><span class="line"><span class="function"><span class="comment">// 现了相同的接口。</span></span></span><br><span class="line"><span class="function">class TVManager is</span></span><br><span class="line"><span class="function">    <span class="keyword">protected</span> field service: ThirdPartyTVLib</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    constructor <span class="title">TVManager</span><span class="params">(service: ThirdPartyTVLib)</span> is</span></span><br><span class="line"><span class="function">        <span class="keyword">this</span>.service </span>= service</span><br><span class="line"></span><br><span class="line">    <span class="function">method <span class="title">renderVideoPage</span><span class="params">(id)</span> is</span></span><br><span class="line"><span class="function">        info </span>= service.getVideoInfo(id)</span><br><span class="line">        <span class="comment">// 渲染视频页面。</span></span><br><span class="line"></span><br><span class="line">    <span class="function">method <span class="title">renderListPanel</span><span class="params">()</span> is</span></span><br><span class="line"><span class="function">        list </span>= service.listVideos()</span><br><span class="line">        <span class="comment">// 渲染视频缩略图列表。</span></span><br><span class="line"></span><br><span class="line">    <span class="function">method <span class="title">reactOnUserInput</span><span class="params">()</span> is</span></span><br><span class="line"><span class="function">        <span class="title">renderVideoPage</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        <span class="title">renderListPanel</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 程序可在运行时对代理进行配置。</span></span></span><br><span class="line"><span class="function">class Application is</span></span><br><span class="line"><span class="function">    method <span class="title">init</span><span class="params">()</span> is</span></span><br><span class="line"><span class="function">        aTVService </span>= <span class="keyword">new</span> ThirdPartyTVClass()</span><br><span class="line">        aTVProxy = <span class="keyword">new</span> CachedTVClass(aTVService)</span><br><span class="line">        manager = <span class="keyword">new</span> TVManager(aTVProxy)</span><br><span class="line">        manager.reactOnUserInput()</span><br></pre></td></tr></table></figure>
<h2 id="5-案例"><a class="markdownIt-Anchor" href="#5-案例"></a> 5. 案例</h2>
<p><strong>使用示例：</strong> 尽管代理模式在绝大多数 Java 程序中并不常见， 但它在一些特殊情况下仍然非常方便。 当你希望在无需修改客户代码的前提下于已有类的对象上增加额外行为时， 该模式是无可替代的。</p>
<p>Java 标准程序库中的一些代理模式的示例：</p>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Proxy.html" target="_blank" rel="noopener"><code>java.lang.reflect.Proxy</code></a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/rmi/package-summary.html" target="_blank" rel="noopener"><code>java.rmi.*</code></a></li>
<li><a href="http://docs.oracle.com/javaee/7/api/javax/ejb/EJB.html" target="_blank" rel="noopener"><code>javax.ejb.EJB</code></a> （<a href="http://stackoverflow.com/questions/25514361/when-using-ejb-does-each-managed-bean-get-its-own-ejb-instance" target="_blank" rel="noopener">查看评论</a>）</li>
<li><a href="http://docs.oracle.com/javaee/7/api/javax/inject/Inject.html" target="_blank" rel="noopener"><code>javax.inject.Inject</code></a> （<a href="http://stackoverflow.com/questions/29651008/field-getobj-returns-all-nulls-on-injected-cdi-managed-beans-while-manually-i/29672591#29672591" target="_blank" rel="noopener">查看评论</a>）</li>
<li><a href="http://docs.oracle.com/javaee/7/api/javax/persistence/PersistenceContext.html" target="_blank" rel="noopener"><code>javax.persistence.PersistenceContext</code></a></li>
</ul>
<p><strong>识别方法</strong>： 代理模式会将所有实际工作委派给一些其他对象。 除非代理是某个服务的子类， 否则每个代理方法最后都应该引用一个服务对象。</p>
<h3 id="51-注解反射代理消除重复代码"><a class="markdownIt-Anchor" href="#51-注解反射代理消除重复代码"></a> 5.1. 注解+反射+代理消除重复代码</h3>
<p>假设银行提供了一些 API 接口，对参数的序列化有点特殊，不使用 JSON，而是需要我们把参数依次拼在一起构成一个大字符串。</p>
<p>按照银行提供的 API 文档的顺序，把所有参数构成定长的数据，然后拼接在一起作为整个字符串。因为每一种参数都有固定长度，未达到长度时需要做填充处理：</p>
<ul>
<li>字符串类型的参数不满长度部分需要以下划线右填充，也就是字符串内容靠左；</li>
<li>数字类型的参数不满长度部分以 0 左填充，也就是实际数字靠右；</li>
<li>货币类型的表示需要把金额向下舍入 2 位到分，以分为单位，作为数字类型同样进行<br />
左填充。</li>
</ul>
<p>对所有参数做 MD5 操作作为签名（为了方便理解，Demo 中不涉及加盐处理）。</p>
<h4 id="问题版本"><a class="markdownIt-Anchor" href="#问题版本"></a> 问题版本</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.codec.digest.DigestUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.fluent.Request;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.entity.ContentType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.math.RoundingMode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BankService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createUser</span><span class="params">(String name, String identity, String mobile, <span class="keyword">int</span> age)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//字符串靠左，多余的地方_填充</span></span><br><span class="line">        stringBuilder.append(String.format(<span class="string">"%-10s"</span>, name).replace(<span class="string">' '</span>, <span class="string">'_'</span>));</span><br><span class="line">        <span class="comment">//字符串靠左，多余的地方_填充</span></span><br><span class="line">        stringBuilder.append(String.format(<span class="string">"%-18s"</span>, identity).replace(<span class="string">' '</span>, <span class="string">'_'</span>));</span><br><span class="line">        <span class="comment">//数字靠右，多余的地方用0填充</span></span><br><span class="line">        stringBuilder.append(String.format(<span class="string">"%05d"</span>, age));</span><br><span class="line">        <span class="comment">//字符串靠左，多余的地方_填充</span></span><br><span class="line">        stringBuilder.append(String.format(<span class="string">"%-11s"</span>, mobile).replace(<span class="string">' '</span>, <span class="string">'_'</span>));</span><br><span class="line">        <span class="comment">//最后加上MD5作为签名</span></span><br><span class="line">        stringBuilder.append(DigestUtils.md2Hex(stringBuilder.toString()));</span><br><span class="line">        <span class="keyword">return</span> Request.Post(<span class="string">"http://localhost:45678/reflection/bank/createUser"</span>)</span><br><span class="line">                .bodyString(stringBuilder.toString(), ContentType.APPLICATION_JSON)</span><br><span class="line">                .execute().returnContent().asString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">pay</span><span class="params">(<span class="keyword">long</span> userId, BigDecimal amount)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//数字靠右，多余的地方用0填充</span></span><br><span class="line">        stringBuilder.append(String.format(<span class="string">"%020d"</span>, userId));</span><br><span class="line">        <span class="comment">//金额向下舍入2位到分，以分为单位，作为数字靠右，多余的地方用0填充</span></span><br><span class="line">        stringBuilder.append(String.format(<span class="string">"%010d"</span>, amount.setScale(<span class="number">2</span>, RoundingMode.DOWN).multiply(<span class="keyword">new</span> BigDecimal(<span class="string">"100"</span>)).longValue()));</span><br><span class="line">        <span class="comment">//最后加上MD5作为签名</span></span><br><span class="line">        stringBuilder.append(DigestUtils.md2Hex(stringBuilder.toString()));</span><br><span class="line">        <span class="keyword">return</span> Request.Post(<span class="string">"http://localhost:45678/reflection/bank/pay"</span>)</span><br><span class="line">                .bodyString(stringBuilder.toString(), ContentType.APPLICATION_JSON)</span><br><span class="line">                .execute().returnContent().asString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在以上的代码版本中，存在以下问题：</p>
<ul>
<li>三种标准数据类型的处理逻辑有重复，稍有不慎就会出现 Bug；</li>
<li>处理流程中字符串拼接、加签和发请求的逻辑，在所有方法重复；</li>
<li>实际方法的入参的参数类型和顺序，不一定和接口要求一致，容易出错；</li>
<li>代码层面针对每一个参数硬编码，无法清晰地进行核对，如果参数达到几十个、上百个，出错的概率极大。</li>
</ul>
<h4 id="优化版本"><a class="markdownIt-Anchor" href="#优化版本"></a> 优化版本</h4>
<p>针对上面代码版本中的问题，可以使用 <strong>注解+反射+代理模式</strong> 解决重复代码。</p>
<p>【注解一】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> BankAPI &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">desc</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">url</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【注解二】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> BankAPIField &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">order</span><span class="params">()</span> <span class="keyword">default</span> -1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">default</span> -1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【抽象类】</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="symbol">AbstractAPI</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>【代理类】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BetterBankService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createUser</span><span class="params">(String name, String identity, String mobile, <span class="keyword">int</span> age)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        CreateUserAPI createUserAPI = <span class="keyword">new</span> CreateUserAPI();</span><br><span class="line">        createUserAPI.setName(name);</span><br><span class="line">        createUserAPI.setIdentity(identity);</span><br><span class="line">        createUserAPI.setAge(age);</span><br><span class="line">        createUserAPI.setMobile(mobile);</span><br><span class="line">        <span class="keyword">return</span> remoteCall(createUserAPI);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">pay</span><span class="params">(<span class="keyword">long</span> userId, BigDecimal amount)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        PayAPI payAPI = <span class="keyword">new</span> PayAPI();</span><br><span class="line">        payAPI.setUserId(userId);</span><br><span class="line">        payAPI.setAmount(amount);</span><br><span class="line">        <span class="keyword">return</span> remoteCall(payAPI);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">remoteCall</span><span class="params">(AbstractAPI api)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//从BankAPI注解获取请求地址</span></span><br><span class="line">        BankAPI bankAPI = api.getClass().getAnnotation(BankAPI<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        bankAPI.url();</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        Arrays.stream(api.getClass().getDeclaredFields()) <span class="comment">//获得所有字段</span></span><br><span class="line">            .filter(field -&gt; field.isAnnotationPresent(BankAPIField<span class="class">.<span class="keyword">class</span>)) //查找标记了注解的字段</span></span><br><span class="line"><span class="class">            .<span class="title">sorted</span>(<span class="title">Comparator</span>.<span class="title">comparingInt</span>(<span class="title">a</span> -&gt; <span class="title">a</span>.<span class="title">getAnnotation</span>(<span class="title">BankAPIField</span>.<span class="title">class</span>).<span class="title">order</span>())) //根据注解中的<span class="title">order</span>对字段排序</span></span><br><span class="line"><span class="class">            .<span class="title">peek</span>(<span class="title">field</span> -&gt; <span class="title">field</span>.<span class="title">setAccessible</span>(<span class="title">true</span>)) //设置可以访问私有字段</span></span><br><span class="line"><span class="class">            .<span class="title">forEach</span>(<span class="title">field</span> -&gt; </span>&#123;</span><br><span class="line">                <span class="comment">//获得注解</span></span><br><span class="line">                BankAPIField bankAPIField = field.getAnnotation(BankAPIField<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                Object value = <span class="string">""</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//反射获取字段值</span></span><br><span class="line">                    value = field.get(api);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//根据字段类型以正确的填充方式格式化字符串</span></span><br><span class="line">                <span class="keyword">switch</span> (bankAPIField.type()) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">"S"</span>: &#123;</span><br><span class="line">                        stringBuilder.append(</span><br><span class="line">                            String.format(<span class="string">"%-"</span> + bankAPIField.length() + <span class="string">"s"</span>, value.toString()).replace(<span class="string">' '</span>, <span class="string">'_'</span>));</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">"N"</span>: &#123;</span><br><span class="line">                        stringBuilder.append(</span><br><span class="line">                            String.format(<span class="string">"%"</span> + bankAPIField.length() + <span class="string">"s"</span>, value.toString()).replace(<span class="string">' '</span>, <span class="string">'0'</span>));</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">"M"</span>: &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!(value <span class="keyword">instanceof</span> BigDecimal)) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                                String.format(<span class="string">"&#123;&#125; 的 &#123;&#125; 必须是BigDecimal"</span>, api, field));</span><br><span class="line">                        &#125;</span><br><span class="line">                        stringBuilder.append(String.format(<span class="string">"%0"</span> + bankAPIField.length() + <span class="string">"d"</span>,</span><br><span class="line">                            ((BigDecimal) value).setScale(<span class="number">2</span>, RoundingMode.DOWN)</span><br><span class="line">                                .multiply(<span class="keyword">new</span> BigDecimal(<span class="string">"100"</span>))</span><br><span class="line">                                .longValue()));</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        <span class="comment">//签名逻辑</span></span><br><span class="line">        stringBuilder.append(DigestUtils.md2Hex(stringBuilder.toString()));</span><br><span class="line">        String param = stringBuilder.toString();</span><br><span class="line">        <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//发请求</span></span><br><span class="line">        String result = Request.Post(<span class="string">"http://localhost:45678/reflection"</span> + bankAPI.url())</span><br><span class="line">            .bodyString(param, ContentType.APPLICATION_JSON)</span><br><span class="line">            .execute().returnContent().asString();</span><br><span class="line">        log.info(<span class="string">"调用银行API &#123;&#125; url:&#123;&#125; 参数:&#123;&#125; 耗时:&#123;&#125;ms"</span>, bankAPI.desc(), bankAPI.url(), param,</span><br><span class="line">            System.currentTimeMillis() - begin);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【注解修饰的 API 接口一】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@BankAPI</span>(url = <span class="string">"/bank/createUser"</span>, desc = <span class="string">"创建用户接口"</span>)</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateUserAPI</span> <span class="keyword">extends</span> <span class="title">AbstractAPI</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BankAPIField</span>(order = <span class="number">1</span>, type = <span class="string">"S"</span>, length = <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@BankAPIField</span>(order = <span class="number">2</span>, type = <span class="string">"S"</span>, length = <span class="number">18</span>)</span><br><span class="line">    <span class="keyword">private</span> String identity;</span><br><span class="line">    <span class="meta">@BankAPIField</span>(order = <span class="number">4</span>, type = <span class="string">"S"</span>, length = <span class="number">11</span>)</span><br><span class="line">    <span class="keyword">private</span> String mobile;</span><br><span class="line">    <span class="meta">@BankAPIField</span>(order = <span class="number">3</span>, type = <span class="string">"N"</span>, length = <span class="number">5</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【注解修饰的 API 接口二】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"></span><br><span class="line"><span class="meta">@BankAPI</span>(url = <span class="string">"/bank/pay"</span>, desc = <span class="string">"支付接口"</span>)</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PayAPI</span> <span class="keyword">extends</span> <span class="title">AbstractAPI</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BankAPIField</span>(order = <span class="number">1</span>, type = <span class="string">"N"</span>, length = <span class="number">20</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> userId;</span><br><span class="line">    <span class="meta">@BankAPIField</span>(order = <span class="number">2</span>, type = <span class="string">"M"</span>, length = <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">private</span> BigDecimal amount;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-与其他模式的关系"><a class="markdownIt-Anchor" href="#6-与其他模式的关系"></a> 6. 与其他模式的关系</h2>
<ul>
<li><a href="https://refactoringguru.cn/design-patterns/adapter" target="_blank" rel="noopener">适配器模式</a>能为被封装对象提供不同的接口， <a href="https://refactoringguru.cn/design-patterns/proxy" target="_blank" rel="noopener">代理模式</a>能为对象提供相同的接口， <a href="https://refactoringguru.cn/design-patterns/decorator" target="_blank" rel="noopener">装饰模式</a>则能为对象提供加强的接口。</li>
<li><a href="https://refactoringguru.cn/design-patterns/facade" target="_blank" rel="noopener">外观模式</a>与<a href="https://refactoringguru.cn/design-patterns/proxy" target="_blank" rel="noopener">代理</a>的相似之处在于它们都缓存了一个复杂实体并自行对其进行初始化。 <em>代理</em>与其服务对象遵循同一接口， 使得自己和服务对象可以互换， 在这一点上它与<em>外观</em>不同。</li>
<li><a href="https://refactoringguru.cn/design-patterns/decorator" target="_blank" rel="noopener">装饰</a>和<a href="https://refactoringguru.cn/design-patterns/proxy" target="_blank" rel="noopener">代理</a>有着相似的结构， 但是其意图却非常不同。 这两个模式的构建都基于组合原则， 也就是说一个对象应该将部分工作委派给另一个对象。 两者之间的不同之处在于<em>代理</em>通常自行管理其服务对象的生命周期， 而<em>装饰</em>的生成则总是由客户端进行控制。</li>
</ul>
<h2 id="7-参考资料"><a class="markdownIt-Anchor" href="#7-参考资料"></a> 7. 参考资料</h2>
<ul>
<li><a href="https://book.douban.com/subject/2243615/" target="_blank" rel="noopener">《Head First 设计模式》</a></li>
<li><a href="https://book.douban.com/subject/2334288/" target="_blank" rel="noopener">《大话设计模式》</a></li>
<li><a href="https://refactoringguru.cn/design-patterns/catalog" target="_blank" rel="noopener">设计模式教程</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/2015/01/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2015/01/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">设计模式之享元模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-01-19 09:48:00" itemprop="dateCreated datePublished" datetime="2015-01-19T09:48:00+08:00">2015-01-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-14 16:45:53" itemprop="dateModified" datetime="2022-04-14T16:45:53+08:00">2022-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index">
                    <span itemprop="name">设计</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2015/01/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/01/19/设计模式之享元模式/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="设计模式之享元模式"><a class="markdownIt-Anchor" href="#设计模式之享元模式"></a> 设计模式之享元模式</h1>
<!-- TOC depthFrom:2 depthTo:3 -->
<ul>
<li><a href="#1-%E6%84%8F%E5%9B%BE">1. 意图</a></li>
<li><a href="#2-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">2. 适用场景</a></li>
<li><a href="#3-%E7%BB%93%E6%9E%84">3. 结构</a>
<ul>
<li><a href="#31-%E7%BB%93%E6%9E%84%E8%AF%B4%E6%98%8E">3.1. 结构说明</a></li>
<li><a href="#32-%E7%BB%93%E6%9E%84%E4%BB%A3%E7%A0%81%E8%8C%83%E5%BC%8F">3.2. 结构代码范式</a></li>
</ul>
</li>
<li><a href="#4-%E4%BC%AA%E4%BB%A3%E7%A0%81">4. 伪代码</a></li>
<li><a href="#5-%E6%A1%88%E4%BE%8B">5. 案例</a></li>
<li><a href="#6-%E4%B8%8E%E5%85%B6%E4%BB%96%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%B3%E7%B3%BB">6. 与其他模式的关系</a></li>
<li><a href="#7-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">7. 参考资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="1-意图"><a class="markdownIt-Anchor" href="#1-意图"></a> 1. 意图</h2>
<p><strong>享元模式</strong> (Flyweight) 是一种结构型设计模式，它摒弃了在每个对象中保存所有数据的方式， 通过共享多个对象所共有的相同状态， 让你能在有限的内存容量中载入更多对象。</p>
<h2 id="2-适用场景"><a class="markdownIt-Anchor" href="#2-适用场景"></a> 2. 适用场景</h2>
<ul>
<li>仅在程序必须支持大量对象且没有足够的内存容量时使用享元模式。</li>
</ul>
<h2 id="3-结构"><a class="markdownIt-Anchor" href="#3-结构"></a> 3. 结构</h2>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20210430182947.png" alt="img" /></p>
<h3 id="31-结构说明"><a class="markdownIt-Anchor" href="#31-结构说明"></a> 3.1. 结构说明</h3>
<ol>
<li>享元模式只是一种优化。 在应用该模式之前， 你要确定程序中存在与大量类似对象同时占用内存相关的内存消耗问题， 并且确保该问题无法使用其他更好的方式来解决。</li>
<li><strong>享元</strong> （Flyweight） 类包含原始对象中部分能在多个对象中共享的状态。 同一享元对象可在许多不同情景中使用。 享元中存储的状态被称为 “内在状态”。 传递给享元方法的状态被称为 “外在状态”。</li>
<li><strong>情景</strong> （Context） 类包含原始对象中各不相同的外在状态。 情景与享元对象组合在一起就能表示原始对象的全部状态。</li>
<li>通常情况下， 原始对象的行为会保留在享元类中。 因此调用享元方法必须提供部分外在状态作为参数。 但你也可将行为移动到情景类中， 然后将连入的享元作为单纯的数据对象。</li>
<li><strong>客户端</strong> （Client） 负责计算或存储享元的外在状态。 在客户端看来， 享元是一种可在运行时进行配置的模板对象， 具体的配置方式为向其方法中传入一些情景数据参数。</li>
<li><strong>享元工厂</strong> （Flyweight Factory） 会对已有享元的缓存池进行管理。 有了工厂后， 客户端就无需直接创建享元， 它们只需调用工厂并向其传递目标享元的一些内在状态即可。 工厂会根据参数在之前已创建的享元中进行查找， 如果找到满足条件的享元就将其返回； 如果没有找到就根据参数新建享元。</li>
</ol>
<h3 id="32-结构代码范式"><a class="markdownIt-Anchor" href="#32-结构代码范式"></a> 3.2. 结构代码范式</h3>
<p><strong>Flyweight</strong> : 它是所有具体享元类的超类或接口，通过这个接口，Flyweight 可以接受并作用于外部状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Flyweight</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">(<span class="keyword">int</span> extrinsicstates)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ConcreteFlyweight</strong> : 是继承 Flyweight 超类或实现 Flyweight 接口，并为内部状态增加存储空间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteFlyweight</span> <span class="keyword">extends</span> <span class="title">Flyweight</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">(<span class="keyword">int</span> extrinsicstates)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"共享的Flyweight : "</span> + extrinsicstates);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>UnsharedConcreteFlyweight</strong> : 指那些不需要共享的 Flyweight 子类，因为 Flyweight 接口共享成为可能，但它并不强制共享。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnsharedConcreteFlyweight</span> <span class="keyword">extends</span> <span class="title">Flyweight</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">(<span class="keyword">int</span> extrinsicstates)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"不共享的Flyweight : "</span> + extrinsicstates);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>FlywightFactory</strong> :是一个享元工厂，用来创建并管理 Flyweight 对象。它主要是用来确保合理地共享 Flyweight ，当用户请求一个 Flyweight 时， FlyweightFactory 对象提供一个已创建的实例或创建一个（如果对象不存在的话）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlywightFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Hashtable&lt;String, Flyweight&gt; flyweights = <span class="keyword">new</span> Hashtable&lt;String, Flyweight&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FlywightFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        flyweights.put(<span class="string">"X"</span>, <span class="keyword">new</span> ConcreteFlyweight());</span><br><span class="line">        flyweights.put(<span class="string">"Y"</span>, <span class="keyword">new</span> ConcreteFlyweight());</span><br><span class="line">        flyweights.put(<span class="string">"Z"</span>, <span class="keyword">new</span> ConcreteFlyweight());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Flyweight <span class="title">getFlyweight</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((Flyweight)flyweights.get(key));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyweightPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> extrinsicstates = <span class="number">1</span>;</span><br><span class="line">        FlywightFactory factory = <span class="keyword">new</span> FlywightFactory();</span><br><span class="line"></span><br><span class="line">        Flyweight fx = factory.getFlyweight(<span class="string">"X"</span>);</span><br><span class="line">        fx.operation(extrinsicstates);</span><br><span class="line"></span><br><span class="line">        Flyweight fy = factory.getFlyweight(<span class="string">"Y"</span>);</span><br><span class="line">        fy.operation(++extrinsicstates);</span><br><span class="line"></span><br><span class="line">        Flyweight fz = factory.getFlyweight(<span class="string">"Z"</span>);</span><br><span class="line">        fz.operation(++extrinsicstates);</span><br><span class="line"></span><br><span class="line">        Flyweight uf = <span class="keyword">new</span> UnsharedConcreteFlyweight();</span><br><span class="line">        uf.operation(++extrinsicstates);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">共享的Flyweight : 1</span><br><span class="line">共享的Flyweight : 2</span><br><span class="line">共享的Flyweight : 3</span><br><span class="line">不共享的Flyweight : 4</span><br></pre></td></tr></table></figure>
<h2 id="4-伪代码"><a class="markdownIt-Anchor" href="#4-伪代码"></a> 4. 伪代码</h2>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20210430183339.png" alt="img" /></p>
<p>在本例中， <strong>享元</strong>模式能有效减少在画布上渲染数百万个树状对象时所需的内存。</p>
<p>该模式从主要的 <code>树</code>Tree 类中抽取内在状态， 并将其移动到享元类 <code>树种类</code>Tree­Type 之中。</p>
<p>最初程序需要在多个对象中存储相同数据， 而现在仅需在几个享元对象中保存数据， 然后在作为情景的 <code>树</code>对象中连入享元即可。 客户端代码使用享元工厂创建树对象并封装搜索指定对象的复杂行为， 并能在需要时复用对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 享元类包含一个树的部分状态。这些成员变量保存的数值对于特定树而言是唯一</span></span><br><span class="line"><span class="comment">// 的。例如，你在这里找不到树的坐标。但这里有很多树木之间所共有的纹理和颜</span></span><br><span class="line"><span class="comment">// 色。由于这些数据的体积通常非常大，所以如果让每棵树都其进行保存的话将耗</span></span><br><span class="line"><span class="comment">// 费大量内存。因此，我们可将纹理、颜色和其他重复数据导出到一个单独的对象</span></span><br><span class="line"><span class="comment">// 中，然后让众多的单个树对象去引用它。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeType</span> <span class="title">is</span></span></span><br><span class="line"><span class="class">    <span class="title">field</span> <span class="title">name</span></span></span><br><span class="line"><span class="class">    <span class="title">field</span> <span class="title">color</span></span></span><br><span class="line"><span class="class">    <span class="title">field</span> <span class="title">texture</span></span></span><br><span class="line"><span class="class">    <span class="title">constructor</span> <span class="title">TreeType</span>(<span class="title">name</span>, <span class="title">color</span>, <span class="title">texture</span>) </span>&#123; ... &#125;</span><br><span class="line">    <span class="function">method <span class="title">draw</span><span class="params">(canvas, x, y)</span> is</span></span><br><span class="line"><span class="function">        <span class="comment">// 1. 创建特定类型、颜色和纹理的位图。</span></span></span><br><span class="line"><span class="function">        <span class="comment">// 2. 在画布坐标 (X,Y) 处绘制位图。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 享元工厂决定是否复用已有享元或者创建一个新的对象。</span></span></span><br><span class="line"><span class="function">class TreeFactory is</span></span><br><span class="line"><span class="function">    <span class="keyword">static</span> field treeTypes: collection of tree types</span></span><br><span class="line"><span class="function">    <span class="keyword">static</span> method <span class="title">getTreeType</span><span class="params">(name, color, texture)</span> is</span></span><br><span class="line"><span class="function">        type </span>= treeTypes.find(name, color, texture)</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="keyword">null</span>)</span><br><span class="line">            type = <span class="keyword">new</span> TreeType(name, color, texture)</span><br><span class="line">            treeTypes.add(type)</span><br><span class="line">        <span class="keyword">return</span> type</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情景对象包含树状态的外在部分。程序中可以创建数十亿个此类对象，因为它们</span></span><br><span class="line"><span class="comment">// 体积很小：仅有两个整型坐标和一个引用成员变量。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span> <span class="title">is</span></span></span><br><span class="line"><span class="class">    <span class="title">field</span> <span class="title">x</span>,<span class="title">y</span></span></span><br><span class="line">    field type: TreeType</span><br><span class="line">    <span class="function">constructor <span class="title">Tree</span><span class="params">(x, y, type)</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function">method <span class="title">draw</span><span class="params">(canvas)</span> is</span></span><br><span class="line"><span class="function">        type.<span class="title">draw</span><span class="params">(canvas, <span class="keyword">this</span>.x, <span class="keyword">this</span>.y)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 树（Tree）和森林（Forest）类是享元的客户端。如果不打算继续对树类进行开</span></span></span><br><span class="line"><span class="function"><span class="comment">// 发，你可以将它们合并。</span></span></span><br><span class="line"><span class="function">class Forest is</span></span><br><span class="line"><span class="function">    field trees: collection of Trees</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    method <span class="title">plantTree</span><span class="params">(x, y, name, color, texture)</span> is</span></span><br><span class="line"><span class="function">        type </span>= TreeFactory.getTreeType(name, color, texture)</span><br><span class="line">        tree = <span class="keyword">new</span> Tree(x, y, type)</span><br><span class="line">        trees.add(tree)</span><br><span class="line"></span><br><span class="line">    <span class="function">method <span class="title">draw</span><span class="params">(canvas)</span> is</span></span><br><span class="line"><span class="function">        <span class="title">foreach</span> <span class="params">(tree in trees)</span> <span class="keyword">do</span></span></span><br><span class="line"><span class="function">            tree.<span class="title">draw</span><span class="params">(canvas)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="5-案例"><a class="markdownIt-Anchor" href="#5-案例"></a> 5. 案例</h2>
<p><strong>使用示例：</strong> 享元模式只有一个目的： 将内存消耗最小化。 如果你的程序没有遇到内存容量不足的问题， 则可以暂时忽略该模式。</p>
<p>享元模式在核心 Java 程序库中的示例：</p>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#valueOf-int-" target="_blank" rel="noopener"><code>java.lang.Integer#valueOf(int)</code></a> （以及 <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Boolean.html#valueOf-boolean-" target="_blank" rel="noopener"><code>Boolean</code></a>、 <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Byte.html#valueOf-byte-" target="_blank" rel="noopener"><code>Byte</code></a>、 <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#valueOf-char-" target="_blank" rel="noopener"><code>Character</code></a>、 <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Short.html#valueOf-short-" target="_blank" rel="noopener"><code>Short</code></a>、 <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Long.html#valueOf-long-" target="_blank" rel="noopener"><code>Long</code></a> 和 <a href="https://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html#valueOf-long-int-" target="_blank" rel="noopener"><code>Big­Decimal</code></a>）</li>
</ul>
<p><strong>识别方法</strong>： 享元可以通过构建方法来识别， 它会返回缓存对象而不是创建新的对象。</p>
<h2 id="6-与其他模式的关系"><a class="markdownIt-Anchor" href="#6-与其他模式的关系"></a> 6. 与其他模式的关系</h2>
<ul>
<li>你可以使用<a href="https://refactoringguru.cn/design-patterns/flyweight" target="_blank" rel="noopener">享元模式</a>实现<a href="https://refactoringguru.cn/design-patterns/composite" target="_blank" rel="noopener">组合模式</a>树的共享叶节点以节省内存。</li>
<li><a href="https://refactoringguru.cn/design-patterns/flyweight" target="_blank" rel="noopener">享元</a>展示了如何生成大量的小型对象， <a href="https://refactoringguru.cn/design-patterns/facade" target="_blank" rel="noopener">外观模式</a>则展示了如何用一个对象来代表整个子系统。</li>
<li>如果你能将对象的所有共享状态简化为一个享元对象， 那么<a href="https://refactoringguru.cn/design-patterns/flyweight" target="_blank" rel="noopener">享元</a>就和<a href="https://refactoringguru.cn/design-patterns/singleton" target="_blank" rel="noopener">单例模式</a>类似了。 但这两个模式有两个根本性的不同。
<ol>
<li>只会有一个单例实体， 但是<em>享元</em>类可以有多个实体， 各实体的内在状态也可以不同。</li>
<li><em>单例</em>对象可以是可变的。 享元对象是不可变的。</li>
</ol>
</li>
</ul>
<h2 id="7-参考资料"><a class="markdownIt-Anchor" href="#7-参考资料"></a> 7. 参考资料</h2>
<ul>
<li><a href="https://book.douban.com/subject/2243615/" target="_blank" rel="noopener">《Head First 设计模式》</a></li>
<li><a href="https://book.douban.com/subject/2334288/" target="_blank" rel="noopener">《大话设计模式》</a></li>
<li><a href="https://refactoringguru.cn/design-patterns/catalog" target="_blank" rel="noopener">设计模式教程</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/2015/01/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2015/01/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">设计模式之桥接模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-01-16 10:32:00" itemprop="dateCreated datePublished" datetime="2015-01-16T10:32:00+08:00">2015-01-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-14 16:45:53" itemprop="dateModified" datetime="2022-04-14T16:45:53+08:00">2022-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index">
                    <span itemprop="name">设计</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2015/01/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/01/16/设计模式之桥接模式/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="设计模式之桥接模式"><a class="markdownIt-Anchor" href="#设计模式之桥接模式"></a> 设计模式之桥接模式</h1>
<h2 id="1-意图"><a class="markdownIt-Anchor" href="#1-意图"></a> 1. 意图</h2>
<p><strong>桥接模式</strong> (Bridge) 是一种结构型设计模式， 可将<strong>抽象</strong>部分与<strong>实现</strong>部分<strong>分离</strong>，使它们都可以独立的变化。</p>
<p>如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的联系。抽象化角色和具体化角色都应该可以被子类扩展。在这种情况下，桥接模式可以灵活地组合不同的抽象化角色和具体化角色，并独立化地扩展。</p>
<p>设计要求实现化角色的任何改变不应当影响客户端，或者说实现化角色的改变对客户端是完全透明的。</p>
<h2 id="2-适用场景"><a class="markdownIt-Anchor" href="#2-适用场景"></a> 2. 适用场景</h2>
<ul>
<li>如果你想要拆分或重组一个具有多重功能的庞杂类（例如能与多个数据库服务器进行交互的类），可以使用桥接模式。</li>
<li>如果你希望在几个独立维度上扩展一个类， 可使用该模式。</li>
<li>如果你需要在运行时切换不同实现方法， 可使用桥接模式。</li>
</ul>
<h2 id="3-结构"><a class="markdownIt-Anchor" href="#3-结构"></a> 3. 结构</h2>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20210430154630.png" alt="img" /></p>
<h3 id="31-结构说明"><a class="markdownIt-Anchor" href="#31-结构说明"></a> 3.1. 结构说明</h3>
<ol>
<li><strong>抽象部分</strong> （Abstraction） 提供高层控制逻辑， 依赖于完成底层实际工作的实现对象。</li>
<li><strong>实现部分</strong> （Implementation） 为所有具体实现声明通用接口。 抽象部分仅能通过在这里声明的方法与实现对象交互。
<ul>
<li>抽象部分可以列出和实现部分一样的方法， 但是抽象部分通常声明一些复杂行为， 这些行为依赖于多种由实现部分声明的原语操作。</li>
</ul>
</li>
<li><strong>具体实现</strong> （Concrete Implementations） 中包括特定于平台的代码。</li>
<li><strong>精确抽象</strong> （Refined Abstraction） 提供控制逻辑的变体。 与其父类一样， 它们通过通用实现接口与不同的实现进行交互。</li>
<li>通常情况下， <strong>客户端</strong> （Client） 仅关心如何与抽象部分合作。 但是， 客户端需要将抽象对象与一个实现对象连接起来。</li>
</ol>
<h3 id="32-结构代码范式"><a class="markdownIt-Anchor" href="#32-结构代码范式"></a> 3.2. 结构代码范式</h3>
<p>【Implementor】定义<strong>实现接口</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Implementor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实现抽象部分需要的某些具体功能</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationImpl</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【Abstraction】定义<strong>抽象接口</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Abstraction</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 持有一个 Implementor 对象，形成聚合关系</span></span><br><span class="line">    <span class="keyword">protected</span> Implementor implementor;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Abstraction</span><span class="params">(Implementor implementor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.implementor = implementor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可能需要转调实现部分的具体实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        implementor.operationImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【ConcreteImplementor】实现 <strong>Implementor</strong> 中定义的接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteImplementorA</span> <span class="keyword">implements</span> <span class="title">Implementor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 真正的实现</span></span><br><span class="line">        System.out.println(<span class="string">"具体实现A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteImplementorB</span> <span class="keyword">implements</span> <span class="title">Implementor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 真正的实现</span></span><br><span class="line">        System.out.println(<span class="string">"具体实现B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【RefinedAbstraction】扩展 <strong>Abstraction</strong> 类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RefinedAbstraction</span> <span class="keyword">extends</span> <span class="title">Abstraction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RefinedAbstraction</span><span class="params">(Implementor implementor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(implementor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">otherOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实现一定的功能，可能会使用具体实现部分的实现方法,</span></span><br><span class="line">        <span class="comment">// 但是本方法更大的可能是使用 Abstraction 中定义的方法，</span></span><br><span class="line">        <span class="comment">// 通过组合使用 Abstraction 中定义的方法来完成更多的功能。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【客户端】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BridgePattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Implementor implementor = <span class="keyword">new</span> ConcreteImplementorA();</span><br><span class="line">        RefinedAbstraction abstraction = <span class="keyword">new</span> RefinedAbstraction(implementor);</span><br><span class="line">        abstraction.operation();</span><br><span class="line">        abstraction.otherOperation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【输出】</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">具体实现<span class="keyword">A</span></span><br><span class="line">其他操作</span><br></pre></td></tr></table></figure>
<h2 id="4-伪代码"><a class="markdownIt-Anchor" href="#4-伪代码"></a> 4. 伪代码</h2>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20210430170020.png" alt="img" /></p>
<p>遥控器基类声明了一个指向设备对象的引用成员变量。 所有遥控器通过通用设备接口与设备进行交互， 使得同一个遥控器可以支持不同类型的设备。</p>
<p>你可以开发独立于设备类的遥控器类， 只需新建一个遥控器子类即可。 例如， 基础遥控器可能只有两个按钮， 但你可在其基础上扩展新功能， 比如额外的一节电池或一块触摸屏。</p>
<p>客户端代码通过遥控器构造函数将特定种类的遥控器与设备对象连接起来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// “抽象部分”定义了两个类层次结构中“控制”部分的接口。它管理着一个指向“实</span></span><br><span class="line"><span class="comment">// 现部分”层次结构中对象的引用，并会将所有真实工作委派给该对象。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RemoteControl</span> <span class="title">is</span></span></span><br><span class="line">    protected field device: Device</span><br><span class="line">    <span class="function">constructor <span class="title">RemoteControl</span><span class="params">(device: Device)</span> is</span></span><br><span class="line"><span class="function">        <span class="keyword">this</span>.device </span>= device</span><br><span class="line">    <span class="function">method <span class="title">togglePower</span><span class="params">()</span> is</span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">(device.isEnabled()</span>) then</span></span><br><span class="line"><span class="function">            device.<span class="title">disable</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        <span class="keyword">else</span></span></span><br><span class="line"><span class="function">            device.<span class="title">enable</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    method <span class="title">volumeDown</span><span class="params">()</span> is</span></span><br><span class="line"><span class="function">        device.<span class="title">setVolume</span><span class="params">(device.getVolume()</span> - 10)</span></span><br><span class="line"><span class="function">    method <span class="title">volumeUp</span><span class="params">()</span> is</span></span><br><span class="line"><span class="function">        device.<span class="title">setVolume</span><span class="params">(device.getVolume()</span> + 10)</span></span><br><span class="line"><span class="function">    method <span class="title">channelDown</span><span class="params">()</span> is</span></span><br><span class="line"><span class="function">        device.<span class="title">setChannel</span><span class="params">(device.getChannel()</span> - 1)</span></span><br><span class="line"><span class="function">    method <span class="title">channelUp</span><span class="params">()</span> is</span></span><br><span class="line"><span class="function">        device.<span class="title">setChannel</span><span class="params">(device.getChannel()</span> + 1)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 你可以独立于设备类的方式从抽象层中扩展类。</span></span></span><br><span class="line"><span class="function">class AdvancedRemoteControl extends RemoteControl is</span></span><br><span class="line"><span class="function">    method <span class="title">mute</span><span class="params">()</span> is</span></span><br><span class="line"><span class="function">        device.<span class="title">setVolume</span><span class="params">(<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// “实现部分”接口声明了在所有具体实现类中通用的方法。它不需要与抽象接口相</span></span></span><br><span class="line"><span class="function"><span class="comment">// 匹配。实际上，这两个接口可以完全不一样。通常实现接口只提供原语操作，而</span></span></span><br><span class="line"><span class="function"><span class="comment">// 抽象接口则会基于这些操作定义较高层次的操作。</span></span></span><br><span class="line"><span class="function">interface Device is</span></span><br><span class="line"><span class="function">    method <span class="title">isEnabled</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    method <span class="title">enable</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    method <span class="title">disable</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    method <span class="title">getVolume</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    method <span class="title">setVolume</span><span class="params">(percent)</span></span></span><br><span class="line"><span class="function">    method <span class="title">getChannel</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    method <span class="title">setChannel</span><span class="params">(channel)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 所有设备都遵循相同的接口。</span></span></span><br><span class="line"><span class="function">class Tv implements Device is</span></span><br><span class="line"><span class="function">    <span class="comment">// ...</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">class Radio implements Device is</span></span><br><span class="line"><span class="function">    <span class="comment">// ...</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 客户端代码中的某个位置。</span></span></span><br><span class="line"><span class="function">tv </span>= <span class="keyword">new</span> Tv()</span><br><span class="line">remote = <span class="keyword">new</span> RemoteControl(tv)</span><br><span class="line">remote.togglePower()</span><br><span class="line"></span><br><span class="line">radio = <span class="keyword">new</span> Radio()</span><br><span class="line">remote = <span class="keyword">new</span> AdvancedRemoteControl(radio)</span><br></pre></td></tr></table></figure>
<h2 id="5-案例"><a class="markdownIt-Anchor" href="#5-案例"></a> 5. 案例</h2>
<p><strong>使用示例：</strong> 桥接模式在处理跨平台应用、 支持多种类型的数据库服务器或与多个特定种类 （例如云平台和社交网络等） 的 API 供应商协作时会特别有用。</p>
<p><strong>识别方法</strong>： 桥接可以通过一些控制实体及其所依赖的多个不同平台之间的明确区别来进行识别。</p>
<p>Java 中桥接模式应用最经典的代表无疑是日志组件 slf4j 的桥接 jar 包。</p>
<p>假如，你正在开发应用程序所调用的组件当中已经使用了 common-logging，这时你需要 jcl-over-slf4j.jar 把日志信息输出重定向到 slf4j-api，slf4j-api 再去调用 slf4j 实际依赖的日志组件。这个过程称为桥接。下图是官方的 slf4j 桥接策略图：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/java/javalib/log/slf4j-bind-strategy.png" alt="img" /></p>
<h2 id="6-与其他模式的关系"><a class="markdownIt-Anchor" href="#6-与其他模式的关系"></a> 6. 与其他模式的关系</h2>
<ul>
<li><a href="https://refactoringguru.cn/design-patterns/bridge" target="_blank" rel="noopener">桥接模式</a>通常会于开发前期进行设计， 使你能够将程序的各个部分独立开来以便开发。 另一方面， <a href="https://refactoringguru.cn/design-patterns/adapter" target="_blank" rel="noopener">适配器模式</a>通常在已有程序中使用， 让相互不兼容的类能很好地合作。</li>
<li><a href="https://refactoringguru.cn/design-patterns/bridge" target="_blank" rel="noopener">桥接</a>、 <a href="https://refactoringguru.cn/design-patterns/state" target="_blank" rel="noopener">状态模式</a>和<a href="https://refactoringguru.cn/design-patterns/strategy" target="_blank" rel="noopener">策略模式</a> （在某种程度上包括<a href="https://refactoringguru.cn/design-patterns/adapter" target="_blank" rel="noopener">适配器</a>） 模式的接口非常相似。 实际上， 它们都基于<a href="https://refactoringguru.cn/design-patterns/composite" target="_blank" rel="noopener">组合模式</a>——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。</li>
<li>你可以将<a href="https://refactoringguru.cn/design-patterns/abstract-factory" target="_blank" rel="noopener">抽象工厂模式</a>和<a href="https://refactoringguru.cn/design-patterns/bridge" target="_blank" rel="noopener">桥接</a>搭配使用。 如果由<em>桥接</em>定义的抽象只能与特定实现合作， 这一模式搭配就非常有用。 在这种情况下， <em>抽象工厂</em>可以对这些关系进行封装， 并且对客户端代码隐藏其复杂性。</li>
<li>你可以结合使用<a href="https://refactoringguru.cn/design-patterns/builder" target="_blank" rel="noopener">生成器模式</a>和<a href="https://refactoringguru.cn/design-patterns/bridge" target="_blank" rel="noopener">桥接模式</a>： <em>主管</em>类负责抽象工作， 各种不同的<em>生成器</em>负责<em>实现</em>工作。</li>
</ul>
<h2 id="7-参考资料"><a class="markdownIt-Anchor" href="#7-参考资料"></a> 7. 参考资料</h2>
<ul>
<li><a href="https://book.douban.com/subject/2243615/" target="_blank" rel="noopener">《Head First 设计模式》</a></li>
<li><a href="https://book.douban.com/subject/2334288/" target="_blank" rel="noopener">《大话设计模式》</a></li>
<li><a href="https://refactoringguru.cn/design-patterns/catalog" target="_blank" rel="noopener">设计模式教程</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/2015/01/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2015/01/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">设计模式之装饰模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-01-15 15:41:00" itemprop="dateCreated datePublished" datetime="2015-01-15T15:41:00+08:00">2015-01-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-14 16:45:53" itemprop="dateModified" datetime="2022-04-14T16:45:53+08:00">2022-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index">
                    <span itemprop="name">设计</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2015/01/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/01/15/设计模式之装饰模式/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="设计模式之装饰模式"><a class="markdownIt-Anchor" href="#设计模式之装饰模式"></a> 设计模式之装饰模式</h1>
<h2 id="1-意图"><a class="markdownIt-Anchor" href="#1-意图"></a> 1. 意图</h2>
<p><strong>装饰模式</strong> (Decorator) 是一种结构型设计模式，<strong>动态</strong>地给一个对象<strong>添加</strong>一些<strong>额外的职责</strong>。就增加功能来说，Decorator 模式相比生成子类更为灵活。</p>
<ul>
<li>装饰对象和真实对象有相同的接口。这样客户端对象就能以和真实对象相同的方式和装饰对象交互。</li>
<li>装饰对象包含一个真实对象的引用（reference）。</li>
<li>装饰对象接受所有来自客户端的请求。它把这些请求转发给真实的对象。</li>
<li>装饰对象可以在转发这些请求以前或以后增加一些附加功能。这样就确保了在运行时，不用修改给定对象的结构就可以在外部增加附加的功能。在面向对象的设计中，通常是通过继承来实现对给定类的功能扩展。</li>
</ul>
<h2 id="2-适合场景"><a class="markdownIt-Anchor" href="#2-适合场景"></a> 2. 适合场景</h2>
<ul>
<li>如果你希望在无需修改代码的情况下即可使用对象， 且希望在运行时为对象新增额外的行为， 可以使用装饰模式。</li>
<li>如果用继承来扩展对象行为的方案难以实现或者根本不可行， 你可以使用该模式。</li>
</ul>
<h2 id="3-结构"><a class="markdownIt-Anchor" href="#3-结构"></a> 3. 结构</h2>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20210430172133.png" alt="img" /></p>
<h3 id="31-结构说明"><a class="markdownIt-Anchor" href="#31-结构说明"></a> 3.1. 结构说明</h3>
<ol>
<li><strong>部件</strong> （Component） 声明封装器和被封装对象的公用接口。</li>
<li><strong>具体部件</strong> （Concrete Component） 类是被封装对象所属的类。 它定义了基础行为， 但装饰类可以改变这些行为。</li>
<li><strong>基础装饰</strong> （Base Decorator） 类拥有一个指向被封装对象的引用成员变量。 该变量的类型应当被声明为通用部件接口， 这样它就可以引用具体的部件和装饰。 装饰基类会将所有操作委派给被封装的对象。</li>
<li><strong>具体装饰类</strong> （Concrete Decorators） 定义了可动态添加到部件的额外行为。 具体装饰类会重写装饰基类的方法， 并在调用父类方法之前或之后进行额外的行为。</li>
<li><strong>客户端</strong> （Client） 可以使用多层装饰来封装部件， 只要它能使用通用接口与所有对象互动即可。</li>
</ol>
<h3 id="32-结构代码范式"><a class="markdownIt-Anchor" href="#32-结构代码范式"></a> 3.2. 结构代码范式</h3>
<p><strong>Component</strong> : 定义一个对象接口，可以给这些对象动态地添加职责。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ConcreteComponent</strong> : 实现 <strong>Component</strong> 定义的接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteComponent</span> <span class="keyword">implements</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"初始行为"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Decorator</strong> : 装饰抽象类，继承了 Component， 从外类来扩展 Component 类的功能，但对于 Component 来说，是无需知道 Decorator 的存在的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">implements</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 持有一个 Component 对象，和 Component 形成聚合关系</span></span><br><span class="line">    <span class="keyword">protected</span> Component component;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传入要进一步修饰的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.component = component;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 调用要修饰对象的原方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        component.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ConcreteDecorator</strong> : 具体的装饰对象，起到给 Component 添加职责的功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecoratorA</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String addedState = <span class="string">"新属性1"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteDecoratorA</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.operation();</span><br><span class="line">        System.out.println(<span class="string">"添加属性: "</span> + addedState);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecoratorB</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteDecoratorB</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.operation();</span><br><span class="line">        AddedBehavior();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddedBehavior</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"添加行为"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【客户端】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecoratorPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Component component = <span class="keyword">new</span> ConcreteComponent();</span><br><span class="line">        component.operation();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"======================================"</span>);</span><br><span class="line">        Decorator decoratorA = <span class="keyword">new</span> ConcreteDecoratorA(component);</span><br><span class="line">        decoratorA.operation();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"======================================"</span>);</span><br><span class="line">        Decorator decoratorB = <span class="keyword">new</span> ConcreteDecoratorB(decoratorA);</span><br><span class="line">        decoratorB.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【输出】</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">初始行为</span><br><span class="line">======================================</span><br><span class="line">初始行为</span><br><span class="line">添加属性: 新属性1</span><br><span class="line">======================================</span><br><span class="line">初始行为</span><br><span class="line">添加属性: 新属性1</span><br><span class="line">添加行为</span><br></pre></td></tr></table></figure>
<h2 id="4-伪代码"><a class="markdownIt-Anchor" href="#4-伪代码"></a> 4. 伪代码</h2>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20210430172723.png" alt="img" /></p>
<p>在本例中， 装饰模式能够对敏感数据进行压缩和加密， 从而将数据从使用数据的代码中独立出来。</p>
<p>程序使用一对装饰来封装数据源对象。 这两个封装器都改变了从磁盘读写数据的方式：</p>
<ul>
<li>当数据即将被<strong>写入磁盘</strong>前， 装饰对数据进行加密和压缩。 在原始类对改变毫无察觉的情况下， 将加密后的受保护数据写入文件。</li>
<li>当数据刚<strong>从磁盘读出</strong>后， 同样通过装饰对数据进行解压和解密。 装饰和数据源类实现同一接口， 从而能在客户端代码中相互替换。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 装饰可以改变组件接口所定义的操作。</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">DataSource</span> <span class="title">is</span></span></span><br><span class="line"><span class="class">    <span class="title">method</span> <span class="title">writeData</span>(<span class="title">data</span>)</span></span><br><span class="line">    method readData():data</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体组件提供操作的默认实现。这些类在程序中可能会有几个变体。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileDataSource</span> <span class="keyword">implements</span> <span class="title">DataSource</span> <span class="title">is</span></span></span><br><span class="line"><span class="class">    <span class="title">constructor</span> <span class="title">FileDataSource</span>(<span class="title">filename</span>) </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">method <span class="title">writeData</span><span class="params">(data)</span> is</span></span><br><span class="line"><span class="function">        <span class="comment">// 将数据写入文件。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    method <span class="title">readData</span><span class="params">()</span>:data is</span></span><br><span class="line"><span class="function">        <span class="comment">// 从文件读取数据。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 装饰基类和其他组件遵循相同的接口。该类的主要任务是定义所有具体装饰的封</span></span></span><br><span class="line"><span class="function"><span class="comment">// 装接口。封装的默认实现代码中可能会包含一个保存被封装组件的成员变量，并</span></span></span><br><span class="line"><span class="function"><span class="comment">// 且负责对其进行初始化。</span></span></span><br><span class="line"><span class="function">class DataSourceDecorator implements DataSource is</span></span><br><span class="line"><span class="function">    <span class="keyword">protected</span> field wrappee: DataSource</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    constructor <span class="title">DataSourceDecorator</span><span class="params">(source: DataSource)</span> is</span></span><br><span class="line"><span class="function">        wrappee </span>= source</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 装饰基类会直接将所有工作分派给被封装组件。具体装饰中则可以新增一些</span></span><br><span class="line">    <span class="comment">// 额外的行为。</span></span><br><span class="line">    <span class="function">method <span class="title">writeData</span><span class="params">(data)</span> is</span></span><br><span class="line"><span class="function">        wrappee.<span class="title">writeData</span><span class="params">(data)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">// 具体装饰可调用其父类的操作实现，而不是直接调用被封装对象。这种方式</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 可简化装饰类的扩展工作。</span></span></span><br><span class="line"><span class="function">    method <span class="title">readData</span><span class="params">()</span>:data is</span></span><br><span class="line"><span class="function">        return wrappee.<span class="title">readData</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 具体装饰必须在被封装对象上调用方法，不过也可以自行在结果中添加一些内容。</span></span></span><br><span class="line"><span class="function"><span class="comment">// 装饰必须在调用封装对象之前或之后执行额外的行为。</span></span></span><br><span class="line"><span class="function">class EncryptionDecorator extends DataSourceDecorator is</span></span><br><span class="line"><span class="function">    method <span class="title">writeData</span><span class="params">(data)</span> is</span></span><br><span class="line"><span class="function">        <span class="comment">// 1. 对传递数据进行加密。</span></span></span><br><span class="line"><span class="function">        <span class="comment">// 2. 将加密后数据传递给被封装对象 writeData（写入数据）方法。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    method <span class="title">readData</span><span class="params">()</span>:data is</span></span><br><span class="line"><span class="function">        <span class="comment">// 1. 通过被封装对象的 readData（读取数据）方法获取数据。</span></span></span><br><span class="line"><span class="function">        <span class="comment">// 2. 如果数据被加密就尝试解密。</span></span></span><br><span class="line"><span class="function">        <span class="comment">// 3. 返回结果。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 你可以将对象封装在多层装饰中。</span></span></span><br><span class="line"><span class="function">class CompressionDecorator extends DataSourceDecorator is</span></span><br><span class="line"><span class="function">    method <span class="title">writeData</span><span class="params">(data)</span> is</span></span><br><span class="line"><span class="function">        <span class="comment">// 1. 压缩传递数据。</span></span></span><br><span class="line"><span class="function">        <span class="comment">// 2. 将压缩后数据传递给被封装对象 writeData（写入数据）方法。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    method <span class="title">readData</span><span class="params">()</span>:data is</span></span><br><span class="line"><span class="function">        <span class="comment">// 1. 通过被封装对象的 readData（读取数据）方法获取数据。</span></span></span><br><span class="line"><span class="function">        <span class="comment">// 2. 如果数据被压缩就尝试解压。</span></span></span><br><span class="line"><span class="function">        <span class="comment">// 3. 返回结果。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 选项 1：装饰组件的简单示例</span></span></span><br><span class="line"><span class="function">class Application is</span></span><br><span class="line"><span class="function">    method <span class="title">dumbUsageExample</span><span class="params">()</span> is</span></span><br><span class="line"><span class="function">        source </span>= <span class="keyword">new</span> FileDataSource(<span class="string">"somefile.dat"</span>)</span><br><span class="line">        source.writeData(salaryRecords)</span><br><span class="line">        <span class="comment">// 已将明码数据写入目标文件。</span></span><br><span class="line"></span><br><span class="line">        source = <span class="keyword">new</span> CompressionDecorator(source)</span><br><span class="line">        source.writeData(salaryRecords)</span><br><span class="line">        <span class="comment">// 已将压缩数据写入目标文件。</span></span><br><span class="line"></span><br><span class="line">        source = <span class="keyword">new</span> EncryptionDecorator(source)</span><br><span class="line">        <span class="comment">// 源变量中现在包含：</span></span><br><span class="line">        <span class="comment">// Encryption &gt; Compression &gt; FileDataSource</span></span><br><span class="line">        source.writeData(salaryRecords)</span><br><span class="line">        <span class="comment">// 已将压缩且加密的数据写入目标文件。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 选项 2：客户端使用外部数据源。SalaryManager（工资管理器）对象并不关心</span></span><br><span class="line"><span class="comment">// 数据如何存储。它们会与提前配置好的数据源进行交互，数据源则是通过程序配</span></span><br><span class="line"><span class="comment">// 置器获取的。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SalaryManager</span> <span class="title">is</span></span></span><br><span class="line">    field source: DataSource</span><br><span class="line"></span><br><span class="line">    <span class="function">constructor <span class="title">SalaryManager</span><span class="params">(source: DataSource)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">method <span class="title">load</span><span class="params">()</span> is</span></span><br><span class="line"><span class="function">        return source.<span class="title">readData</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    method <span class="title">save</span><span class="params">()</span> is</span></span><br><span class="line"><span class="function">        source.<span class="title">writeData</span><span class="params">(salaryRecords)</span></span></span><br><span class="line"><span class="function">    <span class="comment">// ...其他有用的方法...</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 程序可在运行时根据配置或环境组装不同的装饰堆桟。</span></span></span><br><span class="line"><span class="function">class ApplicationConfigurator is</span></span><br><span class="line"><span class="function">    method <span class="title">configurationExample</span><span class="params">()</span> is</span></span><br><span class="line"><span class="function">        source </span>= <span class="keyword">new</span> FileDataSource(<span class="string">"salary.dat"</span>)</span><br><span class="line">        <span class="keyword">if</span> (enabledEncryption)</span><br><span class="line">            source = <span class="keyword">new</span> EncryptionDecorator(source)</span><br><span class="line">        <span class="keyword">if</span> (enabledCompression)</span><br><span class="line">            source = <span class="keyword">new</span> CompressionDecorator(source)</span><br><span class="line"></span><br><span class="line">        logger = <span class="keyword">new</span> SalaryManager(source)</span><br><span class="line">        salary = logger.load()</span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<h2 id="5-案例"><a class="markdownIt-Anchor" href="#5-案例"></a> 5. 案例</h2>
<p><strong>使用示例：</strong> 装饰模式在 Java 代码中可谓是标准配置， 尤其是在与流式加载相关的代码中。</p>
<p>Java 核心程序库中有一些关于装饰的示例：</p>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/io/InputStream.html" target="_blank" rel="noopener"><code>java.io.InputStream</code></a>、 <a href="http://docs.oracle.com/javase/8/docs/api/java/io/OutputStream.html" target="_blank" rel="noopener"><code>Output­Stream</code></a>、 <a href="http://docs.oracle.com/javase/8/docs/api/java/io/Reader.html" target="_blank" rel="noopener"><code>Reader</code></a> 和 <a href="http://docs.oracle.com/javase/8/docs/api/java/io/Writer.html" target="_blank" rel="noopener"><code>Writer</code></a> 的所有代码都有以自身类型的对象作为参数的构造函数。</li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html" target="_blank" rel="noopener"><code>java.util.Collections</code></a>； <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#checkedCollection-java.util.Collection-java.lang.Class-" target="_blank" rel="noopener"><code>checked­XXX()</code></a>、 <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#synchronizedCollection-java.util.Collection-" target="_blank" rel="noopener"><code>synchronized­XXX()</code></a> 和 <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#unmodifiableCollection-java.util.Collection-" target="_blank" rel="noopener"><code>unmodifiable­XXX()</code></a> 方法。</li>
<li><a href="http://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServletRequestWrapper.html" target="_blank" rel="noopener"><code>javax.servlet.http.HttpServletRequestWrapper</code></a> 和 <a href="http://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServletResponseWrapper.html" target="_blank" rel="noopener"><code>Http­Servlet­Response­Wrapper</code></a></li>
</ul>
<p><strong>识别方法</strong>： 装饰可通过以当前类或对象为参数的创建方法或构造函数来识别。</p>
<h2 id="6-与其他模式的关系"><a class="markdownIt-Anchor" href="#6-与其他模式的关系"></a> 6. 与其他模式的关系</h2>
<ul>
<li><a href="https://refactoringguru.cn/design-patterns/adapter" target="_blank" rel="noopener">适配器模式</a>可以对已有对象的接口进行修改， <a href="https://refactoringguru.cn/design-patterns/decorator" target="_blank" rel="noopener">装饰模式</a>则能在不改变对象接口的前提下强化对象功能。 此外， <em>装饰</em>还支持递归组合， <em>适配器</em>则无法实现。</li>
<li><a href="https://refactoringguru.cn/design-patterns/adapter" target="_blank" rel="noopener">适配器</a>能为被封装对象提供不同的接口， <a href="https://refactoringguru.cn/design-patterns/proxy" target="_blank" rel="noopener">代理模式</a>能为对象提供相同的接口， <a href="https://refactoringguru.cn/design-patterns/decorator" target="_blank" rel="noopener">装饰</a>则能为对象提供加强的接口。</li>
<li><a href="https://refactoringguru.cn/design-patterns/chain-of-responsibility" target="_blank" rel="noopener">责任链模式</a>和<a href="https://refactoringguru.cn/design-patterns/decorator" target="_blank" rel="noopener">装饰模式</a>的类结构非常相似。 两者都依赖递归组合将需要执行的操作传递给一系列对象。 但是， 两者有几点重要的不同之处。
<ul>
<li><a href="https://refactoringguru.cn/design-patterns/chain-of-responsibility" target="_blank" rel="noopener">责任链</a>的管理者可以相互独立地执行一切操作， 还可以随时停止传递请求。 另一方面， 各种<em>装饰</em>可以在遵循基本接口的情况下扩展对象的行为。 此外， 装饰无法中断请求的传递。</li>
</ul>
</li>
<li><a href="https://refactoringguru.cn/design-patterns/composite" target="_blank" rel="noopener">组合模式</a>和<a href="https://refactoringguru.cn/design-patterns/decorator" target="_blank" rel="noopener">装饰</a>的结构图很相似， 因为两者都依赖递归组合来组织无限数量的对象。
<ul>
<li><em>装饰</em>类似于<em>组合</em>， 但其只有一个子组件。 此外还有一个明显不同： <em>装饰</em>为被封装对象添加了额外的职责， <em>组合</em>仅对其子节点的结果进行了 “求和”。</li>
<li>但是， 模式也可以相互合作： 你可以使用<em>装饰</em>来扩展<em>组合</em>树中特定对象的行为。</li>
</ul>
</li>
<li>大量使用<a href="https://refactoringguru.cn/design-patterns/composite" target="_blank" rel="noopener">组合</a>和<a href="https://refactoringguru.cn/design-patterns/decorator" target="_blank" rel="noopener">装饰</a>的设计通常可从对于<a href="https://refactoringguru.cn/design-patterns/prototype" target="_blank" rel="noopener">原型模式</a>的使用中获益。 你可以通过该模式来复制复杂结构， 而非从零开始重新构造。</li>
<li><a href="https://refactoringguru.cn/design-patterns/decorator" target="_blank" rel="noopener">装饰</a>可让你更改对象的外表， <a href="https://refactoringguru.cn/design-patterns/strategy" target="_blank" rel="noopener">策略模式</a>则让你能够改变其本质。</li>
<li><a href="https://refactoringguru.cn/design-patterns/decorator" target="_blank" rel="noopener">装饰</a>和<a href="https://refactoringguru.cn/design-patterns/proxy" target="_blank" rel="noopener">代理</a>有着相似的结构， 但是其意图却非常不同。 这两个模式的构建都基于组合原则， 也就是说一个对象应该将部分工作委派给另一个对象。 两者之间的不同之处在于<em>代理</em>通常自行管理其服务对象的生命周期， 而<em>装饰</em>的生成则总是由客户端进行控制。</li>
</ul>
<h2 id="7-参考资料"><a class="markdownIt-Anchor" href="#7-参考资料"></a> 7. 参考资料</h2>
<ul>
<li><a href="https://book.douban.com/subject/2243615/" target="_blank" rel="noopener">《Head First 设计模式》</a></li>
<li><a href="https://book.douban.com/subject/2334288/" target="_blank" rel="noopener">《大话设计模式》</a></li>
<li><a href="https://refactoringguru.cn/design-patterns/catalog" target="_blank" rel="noopener">设计模式教程</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blog/page/16/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/16/">16</a><span class="page-number current">17</span><a class="page-number" href="/blog/page/18/">18</a><a class="extend next" rel="next" href="/blog/page/18/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="Zhang Peng"
    src="/blog/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Zhang Peng</p>
  <div class="site-description" itemprop="description">Dunwu's Blog</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">173</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">102</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/dunwu" title="GitHub &amp;rarr; https:&#x2F;&#x2F;github.com&#x2F;dunwu" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:forbreak@163.com" title="E-Mail &amp;rarr; mailto:forbreak@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/blog/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-paper-plane"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhang Peng</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">976k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">14:48</span>
</div>

        












        
      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1/canvas-nest.min.js"></script>
  <script src="/blog/lib/anime.min.js"></script>
  <script src="/blog/lib/velocity/velocity.min.js"></script>
  <script src="/blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/pisces.js"></script>


<script src="/blog/js/next-boot.js"></script>

<script src="/blog/js/bookmark.js"></script>




  




  
<script src="/blog/js/local-search.js"></script>














  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://blog-ajay4qmfci.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>

</body>
</html>
