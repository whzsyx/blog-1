<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon.ico">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/themes/blue/pace-theme-minimal.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/pace.min.js"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/blog/',
    scheme: 'Pisces',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":true},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":true,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="Dunwu&#39;s Blog">
<meta property="og:type" content="website">
<meta property="og:title" content="Dunwu">
<meta property="og:url" content="https://dunwu.github.io/blog/page/10/index.html">
<meta property="og:site_name" content="Dunwu">
<meta property="og:description" content="Dunwu&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Zhang Peng">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://dunwu.github.io/blog/page/10/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Dunwu</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/blog/atom.xml" title="Dunwu" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/blog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Dunwu</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <h1 class="site-subtitle" itemprop="description">大道至简，知易行难</h1>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/blog/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">102</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">37</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">173</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/dunwu" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/2020/06/03/mysql-%E4%BA%8B%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2020/06/03/mysql-%E4%BA%8B%E5%8A%A1/" class="post-title-link" itemprop="url">Mysql 事务</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-03 19:32:09" itemprop="dateCreated datePublished" datetime="2020-06-03T19:32:09+08:00">2020-06-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-14 16:45:53" itemprop="dateModified" datetime="2022-04-14T16:45:53+08:00">2022-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">关系型数据库</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/" itemprop="url" rel="index">
                    <span itemprop="name">Mysql</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2020/06/03/mysql-%E4%BA%8B%E5%8A%A1/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/06/03/mysql-事务/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="mysql-事务"><a class="markdownIt-Anchor" href="#mysql-事务"></a> Mysql 事务</h1>
<blockquote>
<p>不是所有的 Mysql 存储引擎都实现了事务处理。支持事务的存储引擎有：<code>InnoDB</code> 和 <code>NDB Cluster</code>。不支持事务的存储引擎，代表有：<code>MyISAM</code>。</p>
<p>用户可以根据业务是否需要事务处理（事务处理可以保证数据安全，但会增加系统开销），选择合适的存储引擎。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200716074533.png" alt="img" /></p>
<h2 id="1-事务简介"><a class="markdownIt-Anchor" href="#1-事务简介"></a> 1. 事务简介</h2>
<blockquote>
<p>事务简单来说：<strong>一个 Session 中所进行所有的操作，要么同时成功，要么同时失败</strong>。进一步说，事务指的是满足 ACID 特性的一组操作，可以通过 <code>Commit</code> 提交一个事务，也可以使用 <code>Rollback</code> 进行回滚。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/database/RDB/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1.png" alt="img" /></p>
<p><strong>事务就是一组原子性的 SQL 语句</strong>。具体来说，事务指的是满足 ACID 特性的一组操作。</p>
<p><strong>事务内的 SQL 语句，要么全执行成功，要么全执行失败</strong>。</p>
<p><strong>通过加锁的方式，可以实现不同的事务隔离机制</strong>。</p>
<p>想象一下，如果没有事务，在并发环境下，就可能出现丢失修改的问题。</p>
<p>T<sub>1</sub> 和 T<sub>2</sub> 两个线程都对一个数据进行修改，T<sub>1</sub> 先修改，T<sub>2</sub> 随后修改，T<sub>2</sub> 的修改覆盖了 T<sub>1</sub> 的修改。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/database/RDB/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E5%8F%91%E4%B8%80%E8%87%B4%E6%80%A7-%E4%B8%A2%E5%A4%B1%E4%BF%AE%E6%94%B9.png" alt="img" /></p>
<h2 id="2-事务用法"><a class="markdownIt-Anchor" href="#2-事务用法"></a> 2. 事务用法</h2>
<h3 id="21-事务处理指令"><a class="markdownIt-Anchor" href="#21-事务处理指令"></a> 2.1. 事务处理指令</h3>
<p>Mysql 中，使用 <code>START TRANSACTION</code> 语句开始一个事务；使用 <code>COMMIT</code> 语句提交所有的修改；使用 <code>ROLLBACK</code> 语句撤销所有的修改。不能回退 <code>SELECT</code> 语句，回退 <code>SELECT</code> 语句也没意义；也不能回退 <code>CREATE</code> 和 <code>DROP</code> 语句。</p>
<ul>
<li><code>START TRANSACTION</code> - 指令用于标记事务的起始点。</li>
<li><code>SAVEPOINT</code> - 指令用于创建保留点。</li>
<li><code>ROLLBACK TO</code> - 指令用于回滚到指定的保留点；如果没有设置保留点，则回退到 <code>START TRANSACTION</code> 语句处。</li>
<li><code>COMMIT</code> - 提交事务。</li>
</ul>
<p>事务处理示例：</p>
<p>（1）创建一张示例表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 撤销表 user</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="keyword">user</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建表 user</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> (</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'Id'</span>,</span><br><span class="line">  username <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'default'</span> <span class="keyword">COMMENT</span> <span class="string">'用户名'</span>,</span><br><span class="line">  <span class="keyword">password</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'default'</span> <span class="keyword">COMMENT</span> <span class="string">'密码'</span>,</span><br><span class="line">  email <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'default'</span> <span class="keyword">COMMENT</span> <span class="string">'邮箱'</span></span><br><span class="line">) <span class="keyword">COMMENT</span>=<span class="string">'用户表'</span>;</span><br></pre></td></tr></table></figure>
<p>（2）执行事务操作</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 开始事务</span></span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入操作 A</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`user`</span></span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">'root1'</span>, <span class="string">'root1'</span>, <span class="string">'xxxx@163.com'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建保留点 updateA</span></span><br><span class="line"><span class="keyword">SAVEPOINT</span> updateA;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入操作 B</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`user`</span></span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">'root2'</span>, <span class="string">'root2'</span>, <span class="string">'xxxx@163.com'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 回滚到保留点 updateA</span></span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> updateA;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 提交事务，只有操作 A 生效</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>
<p>（3）执行结果</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>	root1	root1	<span class="symbol">xxxx@</span><span class="number">163.</span>com</span><br></pre></td></tr></table></figure>
<h3 id="22-autocommit"><a class="markdownIt-Anchor" href="#22-autocommit"></a> 2.2. AUTOCOMMIT</h3>
<p><strong>MySQL 默认采用隐式提交策略（<code>autocommit</code>）</strong>。每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 <code>START TRANSACTION</code> 语句时，会关闭隐式提交；当 <code>COMMIT</code> 或 <code>ROLLBACK</code> 语句执行后，事务会自动关闭，重新恢复隐式提交。</p>
<p>通过 <code>set autocommit=0</code> 可以取消自动提交，直到 <code>set autocommit=1</code> 才会提交；<code>autocommit</code> 标记是针对每个连接而不是针对服务器的。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看 AUTOCOMMIT</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'AUTOCOMMIT'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 关闭 AUTOCOMMIT</span></span><br><span class="line"><span class="keyword">SET</span> autocommit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 开启 AUTOCOMMIT</span></span><br><span class="line"><span class="keyword">SET</span> autocommit = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h2 id="3-acid"><a class="markdownIt-Anchor" href="#3-acid"></a> 3. ACID</h2>
<p>ACID 是数据库事务正确执行的四个基本要素。</p>
<ul>
<li><strong>原子性（Atomicity）</strong>
<ul>
<li>事务被视为不可分割的最小单元，事务中的所有操作要么全部提交成功，要么全部失败回滚。</li>
<li>回滚可以用日志来实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</li>
</ul>
</li>
<li><strong>一致性（Consistency）</strong>
<ul>
<li>数据库在事务执行前后都保持一致性状态。</li>
<li>在一致性状态下，所有事务对一个数据的读取结果都是相同的。</li>
</ul>
</li>
<li><strong>隔离性（Isolation）</strong>
<ul>
<li>一个事务所做的修改在最终提交以前，对其它事务是不可见的。</li>
</ul>
</li>
<li><strong>持久性（Durability）</strong>
<ul>
<li>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。</li>
<li>可以通过数据库备份和恢复来实现，在系统发生奔溃时，使用备份的数据库进行数据恢复。</li>
</ul>
</li>
</ul>
<p><strong>一个支持事务（Transaction）中的数据库系统，必需要具有这四种特性，否则在事务过程（Transaction processing）当中无法保证数据的正确性，交易过程极可能达不到交易。</strong></p>
<ul>
<li>只有满足一致性，事务的执行结果才是正确的。</li>
<li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。</li>
<li>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li>
<li>事务满足持久化是为了能应对系统崩溃的情况。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/database/RDB/%E6%95%B0%E6%8D%AE%E5%BA%93ACID.png" alt="img" /></p>
<blockquote>
<p>MySQL 默认采用自动提交模式（<code>AUTO COMMIT</code>）。也就是说，如果不显式使用 <code>START TRANSACTION</code> 语句来开始一个事务，那么每个查询操作都会被当做一个事务并自动提交。</p>
</blockquote>
<h2 id="4-事务隔离级别"><a class="markdownIt-Anchor" href="#4-事务隔离级别"></a> 4. 事务隔离级别</h2>
<h3 id="41-事务隔离简介"><a class="markdownIt-Anchor" href="#41-事务隔离简介"></a> 4.1. 事务隔离简介</h3>
<p>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题：</p>
<ul>
<li><strong>丢失修改</strong></li>
<li><strong>脏读</strong></li>
<li><strong>不可重复读</strong></li>
<li><strong>幻读</strong></li>
</ul>
<p>在 SQL 标准中，定义了四种事务隔离级别（级别由低到高）：</p>
<ul>
<li><strong>未提交读</strong></li>
<li><strong>提交读</strong></li>
<li><strong>可重复读</strong></li>
<li><strong>串行化</strong></li>
</ul>
<p>Mysql 中查看和设置事务隔离级别：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看事务隔离级别</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'transaction_isolation'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置事务隔离级别为 READ UNCOMMITTED</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">SESSION</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> <span class="keyword">READ</span> UNCOMMITTED;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置事务隔离级别为 READ COMMITTED</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">SESSION</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> <span class="keyword">READ</span> COMMITTED;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置事务隔离级别为 REPEATABLE READ</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">SESSION</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> REPEATABLE <span class="keyword">READ</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置事务隔离级别为 SERIALIZABLE</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">SESSION</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> <span class="keyword">SERIALIZABLE</span>;</span><br></pre></td></tr></table></figure>
<h3 id="42-未提交读"><a class="markdownIt-Anchor" href="#42-未提交读"></a> 4.2. 未提交读</h3>
<p><strong><code>未提交读（READ UNCOMMITTED）</code> 是指：事务中的修改，即使没有提交，对其它事务也是可见的</strong>。</p>
<p>未提交读的问题：事务可以读取未提交的数据，也被称为 <strong>脏读（Dirty Read）</strong>。</p>
<p>T<sub>1</sub> 修改一个数据，T<sub>2</sub> 随后读取这个数据。如果 T<sub>1</sub> 撤销了这次修改，那么 T<sub>2</sub> 读取的数据是脏数据。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/database/RDB/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E5%8F%91%E4%B8%80%E8%87%B4%E6%80%A7-%E8%84%8F%E6%95%B0%E6%8D%AE.png" alt="img" /></p>
<h3 id="43-提交读"><a class="markdownIt-Anchor" href="#43-提交读"></a> 4.3. 提交读</h3>
<p><strong><code>提交读（READ COMMITTED）</code> 是指：事务提交后，其他事务才能看到它的修改</strong>。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。提交读解决了脏读的问题。</p>
<p>提交读是大多数数据库的默认事务隔离级别。</p>
<p>提交读有时也叫不可重复读，它的问题是：执行两次相同的查询，得到的结果可能不一致。</p>
<p>T<sub>2</sub> 读取一个数据，T<sub>1</sub> 对该数据做了修改。如果 T<sub>2</sub> 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/database/RDB/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E5%8F%91%E4%B8%80%E8%87%B4%E6%80%A7-%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB.png" alt="img" /></p>
<h3 id="44-可重复读"><a class="markdownIt-Anchor" href="#44-可重复读"></a> 4.4. 可重复读</h3>
<p><strong><code>可重复读（REPEATABLE READ）</code> 是指：保证在同一个事务中多次读取同样数据的结果是一样的</strong>。可重复读解决了不可重复读问题。</p>
<p>可重复读是 Mysql 的默认事务隔离级别。</p>
<p>可重复读的问题：当某个事务读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务又再次读取该范围的记录时，会产生 <strong>幻读（Phantom Read）</strong>。</p>
<p>T<sub>1</sub> 读取某个范围的数据，T<sub>2</sub> 在这个范围内插入新的数据，T<sub>1</sub> 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/database/RDB/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E5%8F%91%E4%B8%80%E8%87%B4%E6%80%A7-%E5%B9%BB%E8%AF%BB.png" alt="img" /></p>
<h3 id="45-串行化"><a class="markdownIt-Anchor" href="#45-串行化"></a> 4.5. 串行化</h3>
<p><strong><code>串行化（SERIALIXABLE）</code> 是指：强制事务串行执行</strong>。</p>
<p>强制事务串行执行，则避免了所有的并发问题。串行化策略会在读取的每一行数据上都加锁，这可能导致大量的超时和锁竞争。这对于高并发应用基本上是不可接受的，所以一般不会采用这个级别。</p>
<h3 id="46-隔离级别小结"><a class="markdownIt-Anchor" href="#46-隔离级别小结"></a> 4.6. 隔离级别小结</h3>
<ul>
<li><strong><code>未提交读（READ UNCOMMITTED）</code></strong> - 事务中的修改，即使没有提交，对其它事务也是可见的。</li>
<li><strong><code>提交读（READ COMMITTED）</code></strong> - 一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。</li>
<li><strong><code>重复读（REPEATABLE READ）</code></strong> - 保证在同一个事务中多次读取同样数据的结果是一样的。</li>
<li><strong><code>串行化（SERIALIXABLE）</code></strong> - 强制事务串行执行。</li>
</ul>
<p>数据库隔离级别解决的问题：</p>
<table>
<thead>
<tr>
<th style="text-align:center">隔离级别</th>
<th style="text-align:center">丢失修改</th>
<th style="text-align:center">脏读</th>
<th style="text-align:center">不可重复读</th>
<th style="text-align:center">幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">未提交读</td>
<td style="text-align:center">✔️</td>
<td style="text-align:center">❌</td>
<td style="text-align:center">❌</td>
<td style="text-align:center">❌</td>
</tr>
<tr>
<td style="text-align:center">提交读</td>
<td style="text-align:center">✔️</td>
<td style="text-align:center">✔️</td>
<td style="text-align:center">❌</td>
<td style="text-align:center">❌</td>
</tr>
<tr>
<td style="text-align:center">可重复读</td>
<td style="text-align:center">✔️</td>
<td style="text-align:center">✔️</td>
<td style="text-align:center">✔️</td>
<td style="text-align:center">❌</td>
</tr>
<tr>
<td style="text-align:center">可串行化</td>
<td style="text-align:center">✔️</td>
<td style="text-align:center">✔️</td>
<td style="text-align:center">✔️</td>
<td style="text-align:center">✔️</td>
</tr>
</tbody>
</table>
<h2 id="5-死锁"><a class="markdownIt-Anchor" href="#5-死锁"></a> 5. 死锁</h2>
<p><strong>死锁是指两个或多个事务竞争同一资源，并请求锁定对方占用的资源，从而导致恶性循环的现象</strong>。</p>
<p>产生死锁的场景：</p>
<ul>
<li>
<p>当多个事务试图以不同的顺序锁定资源时，就可能会产生死锁。</p>
</li>
<li>
<p>多个事务同时锁定同一个资源时，也会产生死锁。</p>
</li>
</ul>
<h3 id="51-死锁的原因"><a class="markdownIt-Anchor" href="#51-死锁的原因"></a> 5.1. 死锁的原因</h3>
<p>行锁的具体实现算法有三种：record lock、gap lock 以及 next-key lock。record lock 是专门对索引项加锁；gap lock 是对索引项之间的间隙加锁；next-key lock 则是前面两种的组合，对索引项以其之间的间隙加锁。</p>
<p>只在可重复读或以上隔离级别下的特定操作才会取得 gap lock 或 next-key lock，在 Select、Update 和 Delete 时，除了基于唯一索引的查询之外，其它索引查询时都会获取 gap lock 或 next-key lock，即锁住其扫描的范围。主键索引也属于唯一索引，所以主键索引是不会使用 gap lock 或 next-key lock。</p>
<p>在 MySQL 中，gap lock 默认是开启的，即 innodb_locks_unsafe_for_binlog 参数值是 disable 的，且 MySQL 中默认的是 RR 事务隔离级别。</p>
<p>当我们执行以下查询 SQL 时，由于 order_no 列为非唯一索引，此时又是 RR 事务隔离级别，所以 SELECT 的加锁类型为 gap lock，这里的 gap 范围是 (4,+∞）。</p>
<blockquote>
<p>SELECT id FROM <code>demo</code>.<code>order_record</code> where <code>order_no</code> = 4 for update;</p>
</blockquote>
<p>执行查询 SQL 语句获取的 gap lock 并不会导致阻塞，而当我们执行以下插入 SQL 时，会在插入间隙上再次获取插入意向锁。插入意向锁其实也是一种 gap 锁，它与 gap lock 是冲突的，所以当其它事务持有该间隙的 gap lock 时，需要等待其它事务释放 gap lock 之后，才能获取到插入意向锁。</p>
<p>以上事务 A 和事务 B 都持有间隙 (4,+∞）的 gap 锁，而接下来的插入操作为了获取到插入意向锁，都在等待对方事务的 gap 锁释放，于是就造成了循环等待，导致死锁。</p>
<blockquote>
<p>INSERT INTO <code>demo</code>.<code>order_record</code>(<code>order_no</code>, <code>status</code>, <code>create_date</code>) VALUES (5, 1, ‘2019-07-13 10:57:03’);</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200630153139.png" alt="img" /></p>
<p><strong>另一个死锁场景</strong></p>
<p>InnoDB 存储引擎的主键索引为聚簇索引，其它索引为辅助索引。如果使用辅助索引来更新数据库，就需要使用聚簇索引来更新数据库字段。如果两个更新事务使用了不同的辅助索引，或一个使用了辅助索引，一个使用了聚簇索引，就都有可能导致锁资源的循环等待。由于本身两个事务是互斥，也就构成了以上死锁的四个必要条件了。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200630154606.png" alt="img" /></p>
<p>出现死锁的步骤：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200630154619.png" alt="img" /></p>
<p>综上可知，在更新操作时，我们应该尽量使用主键来更新表字段，这样可以有效避免一些不必要的死锁发生。</p>
<h3 id="52-避免死锁"><a class="markdownIt-Anchor" href="#52-避免死锁"></a> 5.2. 避免死锁</h3>
<p>预防死锁的注意事项：</p>
<ul>
<li>在编程中尽量按照固定的顺序来处理数据库记录，假设有两个更新操作，分别更新两条相同的记录，但更新顺序不一样，有可能导致死锁；</li>
<li>在允许幻读和不可重复读的情况下，尽量使用 RC 事务隔离级别，可以避免 gap lock 导致的死锁问题；</li>
<li>更新表时，<strong>尽量使用主键更新</strong>；</li>
<li>避免长事务，<strong>尽量将长事务拆解</strong>，可以降低与其它事务发生冲突的概率；</li>
<li><strong>设置合理的锁等待超时参数</strong>，我们可以通过 <code>innodb_lock_wait_timeout</code> 设置合理的等待超时阈值，特别是在一些高并发的业务中，我们可以尽量将该值设置得小一些，避免大量事务等待，占用系统资源，造成严重的性能开销。</li>
</ul>
<p>另外，我们还可以将 order_no 列设置为唯一索引列。虽然不能防止幻读，但我们可以利用它的唯一性来保证订单记录不重复创建，这种方式唯一的缺点就是当遇到重复创建订单时会抛出异常。</p>
<p>我们还可以使用其它的方式来代替数据库实现幂等性校验。例如，使用 Redis 以及 ZooKeeper 来实现，运行效率比数据库更佳。</p>
<h3 id="53-解决死锁"><a class="markdownIt-Anchor" href="#53-解决死锁"></a> 5.3. 解决死锁</h3>
<p>当出现死锁以后，有两种策略：</p>
<ul>
<li>一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数 <code>innodb_lock_wait_timeout</code> 来设置。</li>
<li>另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 <code>innodb_deadlock_detect</code> 设置为 on，表示开启这个逻辑。</li>
</ul>
<p>在 InnoDB 中，innodb_lock_wait_timeout 的默认值是 50s，意味着如果采用第一个策略，当出现死锁以后，第一个被锁住的线程要过 50s 才会超时退出，然后其他线程才有可能继续执行。对于在线服务来说，这个等待时间往往是无法接受的。</p>
<p>但是，我们又不可能直接把这个时间设置成一个很小的值，比如 1s。这样当出现死锁的时候，确实很快就可以解开，但如果不是死锁，而是简单的锁等待呢？所以，超时时间设置太短的话，会出现很多误伤。</p>
<p>所以，正常情况下我们还是要采用第二种策略，即：主动死锁检测，而且 <code>innodb_deadlock_detect</code> 的默认值本身就是 on。为了解决死锁问题，不同数据库实现了各自的死锁检测和超时机制。InnoDB 的处理策略是：<strong>将持有最少行级排它锁的事务进行回滚</strong>。</p>
<p>主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也是有额外负担的。你可以想象一下这个过程：每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。</p>
<h2 id="6-分布式事务"><a class="markdownIt-Anchor" href="#6-分布式事务"></a> 6. 分布式事务</h2>
<p>在单一数据节点中，事务仅限于对单一数据库资源的访问控制，称之为 <strong>本地事务</strong>。几乎所有的成熟的关系型数据库都提供了对本地事务的原生支持。</p>
<p><strong>分布式事务指的是事务操作跨越多个节点，并且要求满足事务的 ACID 特性。</strong></p>
<p>分布式事务的常见方案如下：</p>
<ul>
<li><strong>两阶段提交（2PC）</strong> - 将事务的提交过程分为两个阶段来进行处理：准备阶段和提交阶段。参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。</li>
<li><strong>三阶段提交（3PC）</strong> - 与二阶段提交不同的是，引入超时机制。同时在协调者和参与者中都引入超时机制。将二阶段的准备阶段拆分为 2 个阶段，插入了一个 preCommit 阶段，使得原先在二阶段提交中，参与者在准备之后，由于协调者发生崩溃或错误，而导致参与者处于无法知晓是否提交或者中止的“不确定状态”所产生的可能相当长的延时的问题得以解决。</li>
<li><strong>补偿事务（TCC）</strong>
<ul>
<li><strong>Try</strong> - 操作作为一阶段，负责资源的检查和预留。</li>
<li><strong>Confirm</strong> - 操作作为二阶段提交操作，执行真正的业务。</li>
<li><strong>Cancel</strong> - 是预留资源的取消。</li>
</ul>
</li>
<li><strong>本地消息表</strong> - 在事务主动发起方额外新建事务消息表，事务发起方处理业务和记录事务消息在本地事务中完成，轮询事务消息表的数据发送事务消息，事务被动方基于消息中间件消费事务消息表中的事务。</li>
<li><strong>MQ 事务</strong> - 基于 MQ 的分布式事务方案其实是对本地消息表的封装。</li>
<li><strong>SAGA</strong> - Saga 事务核心思想是将长事务拆分为多个本地短事务，由 Saga 事务协调器协调，如果正常结束那就正常完成，如果某个步骤失败，则根据相反顺序一次调用补偿操作。</li>
</ul>
<p>分布式事务方案分析：</p>
<ul>
<li>2PC/3PC 依赖于数据库，能够很好的提供强一致性和强事务性，但相对来说延迟比较高，比较适合传统的单体应用，在同一个方法中存在跨库操作的情况，不适合高并发和高性能要求的场景。</li>
<li>TCC 适用于执行时间确定且较短，实时性要求高，对数据一致性要求高，比如互联网金融企业最核心的三个服务：交易、支付、账务。</li>
<li>本地消息表/MQ 事务 都适用于事务中参与方支持操作幂等，对一致性要求不高，业务上能容忍数据不一致到一个人工检查周期，事务涉及的参与方、参与环节较少，业务上有对账/校验系统兜底。</li>
<li>Saga 事务 由于 Saga 事务不能保证隔离性，需要在业务层控制并发，适合于业务场景事务并发操作同一资源较少的情况。 Saga 相比缺少预提交动作，导致补偿动作的实现比较麻烦，例如业务是发送短信，补偿动作则得再发送一次短信说明撤销，用户体验比较差。Saga 事务较适用于补偿动作容易处理的场景。</li>
</ul>
<blockquote>
<p>分布式事务详细说明、分析请参考：<a href="https://github.com/dunwu/blog/blob/master/source/_posts/theory/distributed-transaction.md" target="_blank" rel="noopener">分布式事务基本原理</a></p>
</blockquote>
<h2 id="7-事务最佳实践"><a class="markdownIt-Anchor" href="#7-事务最佳实践"></a> 7. 事务最佳实践</h2>
<p>高并发场景下的事务到底该如何调优？</p>
<h3 id="71-尽量使用低级别事务隔离"><a class="markdownIt-Anchor" href="#71-尽量使用低级别事务隔离"></a> 7.1. 尽量使用低级别事务隔离</h3>
<p>结合业务场景，尽量使用低级别事务隔离</p>
<h3 id="72-避免行锁升级表锁"><a class="markdownIt-Anchor" href="#72-避免行锁升级表锁"></a> 7.2. 避免行锁升级表锁</h3>
<p>在 InnoDB 中，行锁是通过索引实现的，如果不通过索引条件检索数据，行锁将会升级到表锁。我们知道，表锁是会严重影响到整张表的操作性能的，所以应该尽力避免。</p>
<h3 id="73-缩小事务范围"><a class="markdownIt-Anchor" href="#73-缩小事务范围"></a> 7.3. 缩小事务范围</h3>
<p>有时候，数据库并发访问量太大，会出现以下异常：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">MySQLQueryInterruptedException: Query execution was <span class="built_in">int</span>errupted</span><br></pre></td></tr></table></figure>
<p>高并发时对一条记录进行更新的情况下，由于更新记录所在的事务还可能存在其他操作，导致一个事务比较长，当有大量请求进入时，就可能导致一些请求同时进入到事务中。</p>
<p>又因为锁的竞争是不公平的，当多个事务同时对一条记录进行更新时，极端情况下，一个更新操作进去排队系统后，可能会一直拿不到锁，最后因超时被系统打断踢出。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200630112600.png" alt="img" /></p>
<p>如上图中的操作，虽然都是在一个事务中，但锁的申请在不同时间，只有当其他操作都执行完，才会释放所有锁。因为扣除库存是更新操作，属于行锁，这将会影响到其他操作该数据的事务，所以我们应该尽量避免长时间地持有该锁，尽快释放该锁。又因为先新建订单和先扣除库存都不会影响业务，所以我们可以将扣除库存操作放到最后，也就是使用执行顺序 1，以此尽量减小锁的持有时间。</p>
<p><strong>在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。</strong></p>
<p>知道了这个设定，对我们使用事务有什么帮助呢？那就是，如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。</p>
<h2 id="8-参考资料"><a class="markdownIt-Anchor" href="#8-参考资料"></a> 8. 参考资料</h2>
<ul>
<li><a href="https://book.douban.com/subject/23008813/" target="_blank" rel="noopener">《高性能 MySQL》</a></li>
<li><a href="https://time.geekbang.org/column/intro/100028001" target="_blank" rel="noopener">《Java 性能调优实战》</a></li>
<li><a href="https://shardingsphere.apache.org/document/current/cn/features/transaction/" target="_blank" rel="noopener">ShardingSphere 分布式事务</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/2020/02/29/mysql-%E9%85%8D%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2020/02/29/mysql-%E9%85%8D%E7%BD%AE/" class="post-title-link" itemprop="url">Mysql 配置</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-29 22:32:57" itemprop="dateCreated datePublished" datetime="2020-02-29T22:32:57+08:00">2020-02-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-14 16:45:53" itemprop="dateModified" datetime="2022-04-14T16:45:53+08:00">2022-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">关系型数据库</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/" itemprop="url" rel="index">
                    <span itemprop="name">Mysql</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2020/02/29/mysql-%E9%85%8D%E7%BD%AE/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/02/29/mysql-配置/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="mysql-配置"><a class="markdownIt-Anchor" href="#mysql-配置"></a> Mysql 配置</h1>
<blockquote>
<p>版本：<img src="https://img.shields.io/badge/mysql-8.0-blue" alt="mysql" /></p>
</blockquote>
<h2 id="1-基本配置"><a class="markdownIt-Anchor" href="#1-基本配置"></a> 1. 基本配置</h2>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="comment"># GENERAL</span></span><br><span class="line"><span class="comment"># -------------------------------------------------------------------------------</span></span><br><span class="line"><span class="attr">datadir</span> = /var/lib/mysql</span><br><span class="line"><span class="attr">socket</span>  = /var/lib/mysql/mysql.sock</span><br><span class="line"><span class="attr">pid_file</span> = /var/lib/mysql/mysql.pid</span><br><span class="line"><span class="attr">user</span> = mysql</span><br><span class="line"><span class="attr">port</span> = <span class="number">3306</span></span><br><span class="line"><span class="attr">default_storage_engine</span> = InnoDB</span><br><span class="line"><span class="attr">default_time_zone</span> = <span class="string">'+8：00'</span></span><br><span class="line"><span class="attr">character_set_server</span> = utf8mb4</span><br><span class="line"><span class="attr">collation_server</span> = utf8mb<span class="number">4_0900_</span>ai_ci</span><br><span class="line"></span><br><span class="line"><span class="comment"># LOG</span></span><br><span class="line"><span class="comment"># -------------------------------------------------------------------------------</span></span><br><span class="line"><span class="attr">log_error</span> = /var/log/mysql/mysql-error.log</span><br><span class="line"><span class="attr">slow_query_log</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">slow_query_log_file</span> = /var/log/mysql/mysql-slow.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># InnoDB</span></span><br><span class="line"><span class="comment"># -------------------------------------------------------------------------------</span></span><br><span class="line"><span class="attr">innodb_buffer_pool_size</span> = &lt;value&gt;</span><br><span class="line"><span class="attr">innodb_log_file_size</span> = &lt;value&gt;</span><br><span class="line"><span class="attr">innodb_file_per_table</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">innodb_flush_method</span> = O_DIRECT</span><br><span class="line"></span><br><span class="line"><span class="comment"># MyIsam</span></span><br><span class="line"><span class="comment"># -------------------------------------------------------------------------------</span></span><br><span class="line"><span class="attr">key_buffer_size</span> = &lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># OTHER</span></span><br><span class="line"><span class="comment"># -------------------------------------------------------------------------------</span></span><br><span class="line"><span class="attr">tmp_table_size</span> = <span class="number">32</span>M</span><br><span class="line"><span class="attr">max_heap_table_size</span> = <span class="number">32</span>M</span><br><span class="line"><span class="attr">max_connections</span> = &lt;value&gt;</span><br><span class="line"><span class="attr">open_files_limit</span> = <span class="number">65535</span></span><br><span class="line"></span><br><span class="line"><span class="section">[client]</span></span><br><span class="line"><span class="attr">socket</span>  = /var/lib/mysql/mysql.sock</span><br><span class="line"><span class="attr">port</span> = <span class="number">3306</span></span><br></pre></td></tr></table></figure>
<h2 id="2-配置项说明"><a class="markdownIt-Anchor" href="#2-配置项说明"></a> 2. 配置项说明</h2>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[client]</span></span><br><span class="line"><span class="comment"># 服务端口号，默认 3306</span></span><br><span class="line"><span class="attr">port</span> = <span class="number">3306</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># socket 文件</span></span><br><span class="line"><span class="attr">socket</span> = /var/lib/mysql/mysql.sock</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># GENERAL</span></span><br><span class="line"><span class="comment"># -------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># socket 文件</span></span><br><span class="line"><span class="attr">socket</span> = /var/lib/mysql/mysql.sock</span><br><span class="line"></span><br><span class="line"><span class="comment"># PID 文件</span></span><br><span class="line"><span class="attr">pid_file</span> = /var/lib/mysql/mysql.pid</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 mysql 服务进程的用户</span></span><br><span class="line"><span class="attr">user</span> = mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务端口号，默认 3306</span></span><br><span class="line"><span class="attr">port</span> = <span class="number">3306</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认时区</span></span><br><span class="line"><span class="attr">default_time_zone</span> = <span class="string">'+8：00'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Mysql 服务 ID，单点服务时没必要设置</span></span><br><span class="line"><span class="attr">server-id</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 事务隔离级别，默认为可重复读（REPEATABLE-READ）。（此级别下可能参数很多间隙锁，影响性能，但是修改又影响主从复制及灾难恢复，建议还是修改代码逻辑吧）</span></span><br><span class="line"><span class="comment"># 隔离级别可选项目：READ-UNCOMMITTED READ-COMMITTED REPEATABLE-READ SERIALIZABLE</span></span><br><span class="line"><span class="attr">transaction_isolation</span> = REPEATABLE-READ</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目录配置</span></span><br><span class="line"><span class="comment"># -------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># mysql 安装根目录</span></span><br><span class="line"><span class="attr">basedir</span> = /usr/local/mysql-<span class="number">5.7</span>.<span class="number">21</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># mysql 数据文件所在目录</span></span><br><span class="line"><span class="attr">datadir</span> = /var/lib/mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 临时目录 比如 load data infile 会用到，一般都是使用/tmp</span></span><br><span class="line"><span class="attr">tmpdir</span> = /tmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据库引擎配置</span></span><br><span class="line"><span class="comment"># -------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># mysql 5.1 之后，默认引擎是 InnoDB</span></span><br><span class="line"><span class="attr">default_storage_engine</span> = InnoDB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 内存临时表默认引擎，默认 InnoDB</span></span><br><span class="line"><span class="attr">default_tmp_storage_engine</span> = InnoDB</span><br><span class="line"></span><br><span class="line"><span class="comment"># mysql 5.7 新增特性，磁盘临时表默认引擎，默认 InnoDB</span></span><br><span class="line"><span class="attr">internal_tmp_disk_storage_engine</span> = InnoDB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符集配置</span></span><br><span class="line"><span class="comment"># -------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据库默认字符集，主流字符集支持一些特殊表情符号（特殊表情符占用 4 个字节）</span></span><br><span class="line"><span class="attr">character_set_server</span> = utf8mb4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据库字符集对应一些排序等规则，注意要和 character_set_server 对应</span></span><br><span class="line"><span class="attr">collation-server</span> = utf8mb<span class="number">4_0900_</span>ai_ci</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 client 连接 mysql 时的字符集，防止乱码</span></span><br><span class="line"><span class="comment"># init_connect='SET NAMES utf8'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否对 sql 语句大小写敏感，默认值为 0，1 表示不敏感</span></span><br><span class="line"><span class="attr">lower_case_table_names</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据库连接配置</span></span><br><span class="line"><span class="comment"># -------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最大连接数，可设最大值 16384，一般考虑根据同时在线人数设置一个比较综合的数字，鉴于该数值增大并不太消耗系统资源，建议直接设 10000</span></span><br><span class="line"><span class="comment"># 如果在访问时经常出现 Too Many Connections 的错误提示，则需要增大该参数值</span></span><br><span class="line"><span class="attr">max_connections</span> = <span class="number">10000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认值 100，最大错误连接数，如果有超出该参数值个数的中断错误连接，则该主机将被禁止连接。如需对该主机进行解禁，执行：FLUSH HOST</span></span><br><span class="line"><span class="comment"># 考虑高并发场景下的容错，建议加大。</span></span><br><span class="line"><span class="attr">max_connect_errors</span> = <span class="number">10000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># MySQL 打开的文件描述符限制，默认最小 1024;</span></span><br><span class="line"><span class="comment"># 当 open_files_limit 没有被配置的时候，比较 max_connections\*5 和 ulimit -n 的值，哪个大用哪个，</span></span><br><span class="line"><span class="comment"># 当 open_file_limit 被配置的时候，比较 open_files_limit 和 max_connections\*5 的值，哪个大用哪个。</span></span><br><span class="line"><span class="comment"># 注意：仍然可能出现报错信息 Can't create a new thread；此时观察系统 cat /proc/mysql 进程号/limits，观察进程 ulimit 限制情况</span></span><br><span class="line"><span class="comment"># 过小的话，考虑修改系统配置表，/etc/security/limits.conf 和 /etc/security/limits.d/90-nproc.conf</span></span><br><span class="line"><span class="attr">open_files_limit</span> = <span class="number">65535</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 超时配置</span></span><br><span class="line"><span class="comment"># -------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># MySQL 默认的 wait_timeout 值为 8 个小时，interactive_timeout 参数需要同时配置才能生效</span></span><br><span class="line"><span class="comment"># MySQL 连接闲置超过一定时间后(单位：秒，此处为 1800 秒)将会被强行关闭</span></span><br><span class="line"><span class="attr">interactive_timeout</span> = <span class="number">1800</span></span><br><span class="line"><span class="attr">wait_timeout</span> = <span class="number">1800</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 MySQL 暂时停止响应新请求之前的短时间内多少个请求可以被存在堆栈中</span></span><br><span class="line"><span class="comment"># 官方建议 back_log = 50 + (max_connections / 5)，封顶数为 900</span></span><br><span class="line"><span class="attr">back_log</span> = <span class="number">900</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据库数据交换配置</span></span><br><span class="line"><span class="comment"># -------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># 该参数限制服务器端，接受的数据包大小，如果有 BLOB 子段，建议增大此值，避免写入或者更新出错。有 BLOB 子段，建议改为 1024M</span></span><br><span class="line"><span class="attr">max_allowed_packet</span> = <span class="number">128</span>M</span><br><span class="line"></span><br><span class="line"><span class="comment"># 内存、cache 与 buffer 设置</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 内存临时表的最大值，默认 16M，此处设置成 64M</span></span><br><span class="line"><span class="attr">tmp_table_size</span> = <span class="number">64</span>M</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用户创建的内存表的大小，默认 16M，往往和 tmp_table_size 一起设置，限制用户临时表大小。</span></span><br><span class="line"><span class="comment"># 超限的话，MySQL 就会自动地把它转化为基于磁盘的 MyISAM 表，存储在指定的 tmpdir 目录下，增大 IO 压力，建议内存大，增大该数值。</span></span><br><span class="line"><span class="attr">max_heap_table_size</span> = <span class="number">64</span>M</span><br><span class="line"></span><br><span class="line"><span class="comment"># 表示这个 mysql 版本是否支持查询缓存。ps：SHOW STATUS LIKE 'qcache%'，与缓存相关的状态变量。</span></span><br><span class="line"><span class="comment"># have_query_cache</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个系统变量控制着查询缓存功能的开启和关闭，0 表示关闭，1 表示打开，2 表示只要 select 中明确指定 SQL_CACHE 才缓存。</span></span><br><span class="line"><span class="comment"># 看业务场景决定是否使用缓存，不使用，下面就不用配置了。</span></span><br><span class="line"><span class="comment"># Mysql8 不支持</span></span><br><span class="line"><span class="attr">query_cache_type</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认值 1M，优点是查询缓存可以极大的提高服务器速度，如果你有大量的相同的查询并且很少修改表。</span></span><br><span class="line"><span class="comment"># 缺点：在你表经常变化的情况下或者如果你的查询原文每次都不同，查询缓存也许引起性能下降而不是性能提升。</span></span><br><span class="line"><span class="comment"># Mysql8 不支持</span></span><br><span class="line"><span class="attr">query_cache_size</span> = <span class="number">64</span>M</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只有小于此设定值的结果才会被缓冲，保护查询缓冲，防止一个极大的结果集将其他所有的查询结果都覆盖。</span></span><br><span class="line"><span class="attr">query_cache_limit</span> = <span class="number">2</span>M</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个被缓存的结果集要占用的最小内存，默认值 4kb，一般不怎么调整。</span></span><br><span class="line"><span class="comment"># 如果 Qcache_free_blocks 值过大，可能是 query_cache_min_res_unit 值过大，应该调小些</span></span><br><span class="line"><span class="comment"># query_cache_min_res_unit 的估计值：(query_cache_size - Qcache_free_memory) / Qcache_queries_in_cache</span></span><br><span class="line"><span class="attr">query_cache_min_res_unit</span> = <span class="number">4</span>kb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在一个事务中 binlog 为了记录 SQL 状态所持有的 cache 大小</span></span><br><span class="line"><span class="comment"># 如果你经常使用大的、多声明的事务，你可以增加此值来获取更大的性能。</span></span><br><span class="line"><span class="comment"># 所有从事务来的状态都将被缓冲在 binlog 缓冲中然后在提交后一次性写入到 binlog 中</span></span><br><span class="line"><span class="comment"># 如果事务比此值大，会使用磁盘上的临时文件来替代。</span></span><br><span class="line"><span class="comment"># 此缓冲在每个连接的事务第一次更新状态时被创建</span></span><br><span class="line"><span class="attr">binlog_cache_size</span> = <span class="number">1</span>M</span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志配置</span></span><br><span class="line"><span class="comment"># -------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志文件相关设置，一般只开启三种日志，错误日志，慢查询日志，二进制日志。普通查询日志不开启。</span></span><br><span class="line"><span class="comment"># 普通查询日志，默认值 off，不开启</span></span><br><span class="line"><span class="attr">general_log</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 普通查询日志存放地址</span></span><br><span class="line"><span class="attr">general_log_file</span> = /usr/local/mysql-<span class="number">5.7</span>.<span class="number">21</span>/log/mysql-general.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全局动态变量，默认 3，范围：1 ～ 3</span></span><br><span class="line"><span class="comment"># 表示错误日志记录的信息，1：只记录 error 信息；2：记录 error 和 warnings 信息；3：记录 error、warnings 和普通的 notes 信息。</span></span><br><span class="line"><span class="attr">log_error_verbosity</span> = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 错误日志文件地址</span></span><br><span class="line"><span class="attr">log_error</span> = /usr/local/mysql-<span class="number">5.7</span>.<span class="number">21</span>/log/mysql-error.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启慢查询</span></span><br><span class="line"><span class="attr">slow_query_log</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启慢查询时间，此处为 1 秒，达到此值才记录数据</span></span><br><span class="line"><span class="attr">long_query_time</span> = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检索行数达到此数值，才记录慢查询日志中</span></span><br><span class="line"><span class="attr">min_examined_row_limit</span> = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># mysql 5.6.5 新增，用来表示每分钟允许记录到 slow log 的且未使用索引的 SQL 语句次数，默认值为 0，不限制。</span></span><br><span class="line"><span class="attr">log_throttle_queries_not_using_indexes</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 慢查询日志文件地址</span></span><br><span class="line"><span class="attr">slow_query_log_file</span> = /var/log/mysql/mysql-slow.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启记录没有使用索引查询语句</span></span><br><span class="line"><span class="attr">log-queries-not-using-indexes</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启二进制日志</span></span><br><span class="line"><span class="attr">log_bin</span> = /usr/local/mysql-<span class="number">5.7</span>.<span class="number">21</span>/log/mysql-bin.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># mysql 清除过期日志的时间，默认值 0，不自动清理，而是使用滚动循环的方式。</span></span><br><span class="line"><span class="attr">expire_logs_days</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果二进制日志写入的内容超出给定值，日志就会发生滚动。你不能将该变量设置为大于 1GB 或小于 4096 字节。 默认值是 1GB。</span></span><br><span class="line"><span class="attr">max_binlog_size</span> = <span class="number">1000</span>M</span><br><span class="line"></span><br><span class="line"><span class="comment"># binlog 的格式也有三种：STATEMENT，ROW，MIXED。mysql 5.7.7 后，默认值从 MIXED 改为 ROW</span></span><br><span class="line"><span class="comment"># 关于 binlog 日志格式问题，请查阅网络资料</span></span><br><span class="line"><span class="attr">binlog_format</span> = row</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认值 N=1，使 binlog 在每 N 次 binlog 写入后与硬盘同步，ps：1 最慢</span></span><br><span class="line"><span class="comment"># sync_binlog = 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># MyISAM 引擎配置</span></span><br><span class="line"><span class="comment"># -------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定索引缓冲区的大小，为 MYISAM 数据表开启供线程共享的索引缓存，对 INNODB 引擎无效。相当影响 MyISAM 的性能。</span></span><br><span class="line"><span class="comment"># 不要将其设置大于你可用内存的 30%，因为一部分内存同样被 OS 用来缓冲行数据</span></span><br><span class="line"><span class="comment"># 甚至在你并不使用 MyISAM 表的情况下，你也需要仍旧设置起 8-64M 内存由于它同样会被内部临时磁盘表使用。</span></span><br><span class="line"><span class="comment"># 默认值 8M，建议值：对于内存在 4GB 左右的服务器该参数可设置为 256M 或 384M。注意：该参数值设置的过大反而会是服务器整体效率降低！</span></span><br><span class="line"><span class="attr">key_buffer_size</span> = <span class="number">64</span>M</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为每个扫描 MyISAM 的线程分配参数设置的内存大小缓冲区。</span></span><br><span class="line"><span class="comment"># 默认值 128kb，建议值：16G 内存建议 1M，4G：128kb 或者 256kb 吧</span></span><br><span class="line"><span class="comment"># 注意，该缓冲区是每个连接独占的，所以总缓冲区大小为 128kb*连接数；极端情况 128kb*maxconnectiosns，会超级大，所以要考虑日常平均连接数。</span></span><br><span class="line"><span class="comment"># 一般不需要太关心该数值，稍微增大就可以了，</span></span><br><span class="line"><span class="attr">read_buffer_size</span> = <span class="number">262144</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 支持任何存储引擎</span></span><br><span class="line"><span class="comment"># MySQL 的随机读缓冲区大小，适当增大，可以提高性能。</span></span><br><span class="line"><span class="comment"># 默认值 256kb；建议值：得参考连接数，16G 内存，有人推荐 8M</span></span><br><span class="line"><span class="comment"># 注意，该缓冲区是每个连接独占的，所以总缓冲区大小为 128kb*连接数；极端情况 128kb*maxconnectiosns，会超级大，所以要考虑日常平均连接数。</span></span><br><span class="line"><span class="attr">read_rnd_buffer_size</span> = <span class="number">1</span>M</span><br><span class="line"></span><br><span class="line"><span class="comment"># order by 或 group by 时用到</span></span><br><span class="line"><span class="comment"># 支持所有引擎，innodb 和 myisam 有自己的 innodb_sort_buffer_size 和 myisam_sort_buffer_size 设置</span></span><br><span class="line"><span class="comment"># 默认值 256kb；建议值：得参考连接数，16G 内存，有人推荐 8M。</span></span><br><span class="line"><span class="comment"># 注意，该缓冲区是每个连接独占的，所以总缓冲区大小为 1M*连接数；极端情况 1M*maxconnectiosns，会超级大。所以要考虑日常平均连接数。</span></span><br><span class="line"><span class="attr">sort_buffer_size</span> = <span class="number">1</span>M</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此缓冲被使用来优化全联合(full JOINs 不带索引的联合)</span></span><br><span class="line"><span class="comment"># 类似的联合在极大多数情况下有非常糟糕的性能表现，但是将此值设大能够减轻性能影响。</span></span><br><span class="line"><span class="comment"># 通过 “Select_full_join” 状态变量查看全联合的数量</span></span><br><span class="line"><span class="comment"># 注意，该缓冲区是每个连接独占的，所以总缓冲区大小为 1M*连接数；极端情况 1M*maxconnectiosns，会超级大。所以要考虑日常平均连接数。</span></span><br><span class="line"><span class="comment"># 默认值 256kb;建议值：16G 内存，设置 8M。</span></span><br><span class="line"><span class="attr">join_buffer_size</span> = <span class="number">1</span>M</span><br><span class="line"></span><br><span class="line"><span class="comment"># 缓存 linux 文件描述符信息，加快数据文件打开速度</span></span><br><span class="line"><span class="comment"># 它影响 myisam 表的打开关闭，但是不影响 innodb 表的打开关闭。</span></span><br><span class="line"><span class="comment"># 默认值 2000，建议值：根据状态变量 Opened_tables 去设定</span></span><br><span class="line"><span class="attr">table_open_cache</span> = <span class="number">2000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 缓存表定义的相关信息，加快读取表信息速度</span></span><br><span class="line"><span class="comment"># 默认值 1400，最大值 2000，建议值：基本不改。</span></span><br><span class="line"><span class="attr">table_definition_cache</span> = <span class="number">1400</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 该参数是 myssql 5.6 后引入的，目的是提高并发。</span></span><br><span class="line"><span class="comment"># 默认值 1，建议值：cpu 核数，并且&lt;=16</span></span><br><span class="line"><span class="attr">table_open_cache_instances</span> = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当客户端断开之后，服务器处理此客户的线程将会缓存起来以响应下一个客户而不是销毁。可重用，减小了系统开销。</span></span><br><span class="line"><span class="comment"># 默认值为 9，建议值：两种取值方式，方式一，根据物理内存，1G —&gt; 8；2G —&gt; 16； 3G —&gt; 32； &gt;3G —&gt; 64；</span></span><br><span class="line"><span class="comment"># 方式二，根据 show status like 'threads%'，查看 Threads_connected 值。</span></span><br><span class="line"><span class="attr">thread_cache_size</span> = <span class="number">16</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认值 256k，建议值：16/32G 内存，512kb，其他一般不改变，如果报错：Thread stack overrun，就增大看看，</span></span><br><span class="line"><span class="comment"># 注意，每个线程分配内存空间，所以总内存空间。。。你懂得。</span></span><br><span class="line"><span class="attr">thread_stack</span> = <span class="number">512</span>k</span><br><span class="line"></span><br><span class="line"><span class="comment"># InnoDB 引擎配置</span></span><br><span class="line"><span class="comment"># -------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明：该参数可以提升扩展性和刷脏页性能。</span></span><br><span class="line"><span class="comment"># 默认值 1，建议值：4-8；并且必须小于 innodb_buffer_pool_instances</span></span><br><span class="line"><span class="attr">innodb_page_cleaners</span> = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明：一般 8k 和 16k 中选择，8k 的话，cpu 消耗小些，selcet 效率高一点，一般不用改</span></span><br><span class="line"><span class="comment"># 默认值：16k；建议值：不改，</span></span><br><span class="line"><span class="attr">innodb_page_size</span> = <span class="number">16384</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明：InnoDB 使用一个缓冲池来保存索引和原始数据，不像 MyISAM。这里你设置越大，你在存取表里面数据时所需要的磁盘 I/O 越少。</span></span><br><span class="line"><span class="comment"># 在一个独立使用的数据库服务器上，你可以设置这个变量到服务器物理内存大小的 60%-80%</span></span><br><span class="line"><span class="comment"># 注意别设置的过大，会导致 system 的 swap 空间被占用，导致操作系统变慢，从而减低 sql 查询的效率</span></span><br><span class="line"><span class="comment"># 默认值：128M，建议值：物理内存的 60%-80%</span></span><br><span class="line"><span class="attr">innodb_buffer_pool_size</span> = <span class="number">512</span>M</span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明：只有当设置 innodb_buffer_pool_size 值大于 1G 时才有意义，小于 1G，instances 默认为 1，大于 1G，instances 默认为 8</span></span><br><span class="line"><span class="comment"># 但是网络上有评价，最佳性能，每个实例至少 1G 大小。</span></span><br><span class="line"><span class="comment"># 默认值：1 或 8，建议值：innodb_buffer_pool_size/innodb_buffer_pool_instances &gt;= 1G</span></span><br><span class="line"><span class="attr">innodb_buffer_pool_instances</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明：mysql 5.7 新特性，defines the chunk size for online InnoDB buffer pool resizing operations。</span></span><br><span class="line"><span class="comment"># 实际缓冲区大小必须为 innodb_buffer_pool_chunk_size*innodb_buffer_pool_instances*倍数，取略大于 innodb_buffer_pool_size</span></span><br><span class="line"><span class="comment"># 默认值 128M，建议值：默认值就好，乱改反而容易出问题，它会影响实际 buffer pool 大小。</span></span><br><span class="line"><span class="attr">innodb_buffer_pool_chunk_size</span> = <span class="number">128</span>M</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在启动时把热数据加载到内存。默认值为 on，不修改</span></span><br><span class="line"><span class="attr">innodb_buffer_pool_load_at_startup</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在关闭时把热数据 dump 到本地磁盘。默认值为 on，不修改</span></span><br><span class="line"><span class="attr">innodb_buffer_pool_dump_at_shutdown</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明：影响 Innodb 缓冲区的刷新算法，建议从小到大配置，直到 zero free pages；innodb_lru_scan_depth \* innodb_buffer_pool_instances defines the amount of work performed by the page cleaner thread each second。</span></span><br><span class="line"><span class="comment"># 默认值 1024，建议值： 未知</span></span><br><span class="line"><span class="attr">innodb_lru_scan_depth</span> = <span class="number">1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明：事务等待获取资源等待的最长时间，单位为秒，看具体业务情况，一般默认值就好</span></span><br><span class="line"><span class="comment"># 默认值：50，建议值：看业务。</span></span><br><span class="line"><span class="attr">innodb_lock_wait_timeout</span> = <span class="number">60</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明：设置了 Mysql 后台任务（例如页刷新和 merge dadta from buffer pool）每秒 io 操作的上限。</span></span><br><span class="line"><span class="comment"># 默认值：200，建议值：方法一，单盘 sata 设 100，sas10，raid10 设 200，ssd 设 2000，fushion-io 设 50000；方法二，通过测试工具获得磁盘 io 性能后，设置 IOPS 数值/2。</span></span><br><span class="line"><span class="attr">innodb_io_capacity</span> = <span class="number">2000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明：该参数是所有缓冲区线程 io 操作的总上限。</span></span><br><span class="line"><span class="comment"># 默认值：innodb_io_capacity 的两倍。建议值：例如用 iometer 测试后的 iops 数值就好</span></span><br><span class="line"><span class="attr">innodb_io_capacity_max</span> = <span class="number">4000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明：控制着 innodb 数据文件及 redo log 的打开、刷写模式，三种模式：fdatasync(默认)，O_DSYNC，O_DIRECT</span></span><br><span class="line"><span class="comment"># fdatasync：数据文件，buffer pool-&gt;os buffer-&gt;磁盘；日志文件，buffer pool-&gt;os buffer-&gt;磁盘；</span></span><br><span class="line"><span class="comment"># O_DSYNC： 数据文件，buffer pool-&gt;os buffer-&gt;磁盘；日志文件，buffer pool-&gt;磁盘；</span></span><br><span class="line"><span class="comment"># O_DIRECT： 数据文件，buffer pool-&gt;磁盘； 日志文件，buffer pool-&gt;os buffer-&gt;磁盘；</span></span><br><span class="line"><span class="comment"># 默认值为空，建议值：使用 SAN 或者 raid，建议用 O_DIRECT，不懂测试的话，默认生产上使用 O_DIRECT</span></span><br><span class="line"><span class="attr">innodb_flush_method</span> = O_DIRECT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明：mysql5.7 之后默认开启，意思是，每张表一个独立表空间。</span></span><br><span class="line"><span class="comment"># 默认值 1，开启</span></span><br><span class="line"><span class="attr">innodb_file_per_table</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明：The path where InnoDB creates undo tablespaces。通常等于 undo log 文件的存放目录。</span></span><br><span class="line"><span class="comment"># 默认值 ./;自行设置</span></span><br><span class="line"><span class="attr">innodb_undo_directory</span> = /usr/local/mysql-<span class="number">5.7</span>.<span class="number">21</span>/log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明：The number of undo tablespaces used by InnoDB 等于 undo log 文件数量。5.7.21 后开始弃用</span></span><br><span class="line"><span class="comment"># 默认值为 0，建议默认值就好，不用调整了。</span></span><br><span class="line"><span class="attr">innodb_undo_tablespaces</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明：定义 undo 使用的回滚段数量。5.7.19 后弃用</span></span><br><span class="line"><span class="comment"># 默认值 128，建议不动，以后弃用了。</span></span><br><span class="line"><span class="attr">innodb_undo_logs</span> = <span class="number">128</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明：5.7.5 后开始使用，在线收缩 undo log 使用的空间。</span></span><br><span class="line"><span class="comment"># 默认值：关闭，建议值：开启</span></span><br><span class="line"><span class="attr">innodb_undo_log_truncate</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明：结合 innodb_undo_log_truncate，实现 undo 空间收缩功能</span></span><br><span class="line"><span class="comment"># 默认值：1G，建议值，不改。</span></span><br><span class="line"><span class="attr">innodb_max_undo_log_size</span> = <span class="number">1</span>G</span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明：重作日志文件的存放目录</span></span><br><span class="line"><span class="attr">innodb_log_group_home_dir</span> = /usr/local/mysql-<span class="number">5.7</span>.<span class="number">21</span>/log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明：日志文件的大小</span></span><br><span class="line"><span class="comment"># 默认值：48M，建议值：根据你系统的磁盘空间和日志增长情况调整大小</span></span><br><span class="line"><span class="attr">innodb_log_file_size</span> = <span class="number">128</span>M</span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明：日志组中的文件数量，mysql 以循环方式写入日志</span></span><br><span class="line"><span class="comment"># 默认值 2，建议值：根据你系统的磁盘空间和日志增长情况调整大小</span></span><br><span class="line"><span class="attr">innodb_log_files_in_group</span> = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此参数确定些日志文件所用的内存大小，以 M 为单位。缓冲区更大能提高性能，但意外的故障将会丢失数据。MySQL 开发人员建议设置为 1－8M 之间</span></span><br><span class="line"><span class="attr">innodb_log_buffer_size</span> = <span class="number">16</span>M</span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明：可以控制 log 从系统 buffer 刷入磁盘文件的刷新频率，增大可减轻系统负荷</span></span><br><span class="line"><span class="comment"># 默认值是 1；建议值不改。系统性能一般够用。</span></span><br><span class="line"><span class="attr">innodb_flush_log_at_timeout</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明：参数可设为 0，1，2；</span></span><br><span class="line"><span class="comment"># 参数 0：表示每秒将 log buffer 内容刷新到系统 buffer 中，再调用系统 flush 操作写入磁盘文件。</span></span><br><span class="line"><span class="comment"># 参数 1：表示每次事物提交，将 log buffer 内容刷新到系统 buffer 中，再调用系统 flush 操作写入磁盘文件。</span></span><br><span class="line"><span class="comment"># 参数 2：表示每次事物提交，将 log buffer 内容刷新到系统 buffer 中，隔 1 秒后再调用系统 flush 操作写入磁盘文件。</span></span><br><span class="line"><span class="attr">innodb_flush_log_at_trx_commit</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明：限制 Innodb 能打开的表的数据，如果库里的表特别多的情况，请增加这个。</span></span><br><span class="line"><span class="comment"># 值默认是 2000，建议值：参考数据库表总数再进行调整，一般够用不用调整。</span></span><br><span class="line"><span class="attr">innodb_open_files</span> = <span class="number">8192</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># innodb 处理 io 读写的后台并发线程数量，根据 cpu 核来确认，取值范围：1-64</span></span><br><span class="line"><span class="comment"># 默认值：4，建议值：与逻辑 cpu 数量的一半保持一致。</span></span><br><span class="line"><span class="attr">innodb_read_io_threads</span> = <span class="number">4</span></span><br><span class="line"><span class="attr">innodb_write_io_threads</span> = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认设置为 0，表示不限制并发数，这里推荐设置为 0，更好去发挥 CPU 多核处理能力，提高并发量</span></span><br><span class="line"><span class="attr">innodb_thread_concurrency</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认值为 4，建议不变。InnoDB 中的清除操作是一类定期回收无用数据的操作。mysql 5.5 之后，支持多线程清除操作。</span></span><br><span class="line"><span class="attr">innodb_purge_threads</span> = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明：mysql 缓冲区分为 new blocks 和 old blocks；此参数表示 old blocks 占比；</span></span><br><span class="line"><span class="comment"># 默认值：37，建议值，一般不动</span></span><br><span class="line"><span class="attr">innodb_old_blocks_pct</span> = <span class="number">37</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明：新数据被载入缓冲池，进入 old pages 链区，当 1 秒后再次访问，则提升进入 new pages 链区。</span></span><br><span class="line"><span class="comment"># 默认值：1000</span></span><br><span class="line"><span class="attr">innodb_old_blocks_time</span>=<span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明：开启异步 io，可以提高并发性，默认开启。</span></span><br><span class="line"><span class="comment"># 默认值为 1，建议不动</span></span><br><span class="line"><span class="attr">innodb_use_native_aio</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明：默认为空，使用 data 目录，一般不改。</span></span><br><span class="line"><span class="attr">innodb_data_home_dir</span>=/usr/local/mysql-<span class="number">5.7</span>.<span class="number">21</span>/data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明：Defines the name，size，and attributes of InnoDB system tablespace data files。</span></span><br><span class="line"><span class="comment"># 默认值，不指定，默认为 ibdata1：12M：autoextend</span></span><br><span class="line"><span class="attr">innodb_data_file_path</span> = ibdata1：<span class="number">12</span>M：autoextend</span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明：设置了 InnoDB 存储引擎用来存放数据字典信息以及一些内部数据结构的内存空间大小，除非你的数据对象及其多，否则一般默认不改。</span></span><br><span class="line"><span class="comment"># innodb_additional_mem_pool_size = 16M</span></span><br><span class="line"><span class="comment"># 说明：The crash recovery mode。只有紧急情况需要恢复数据的时候，才改为大于 1-6 之间数值，含义查下官网。</span></span><br><span class="line"><span class="comment"># 默认值为 0；</span></span><br><span class="line"><span class="comment">#innodb_force_recovery = 0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">[mysqldump]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># quick 选项强制 mysqldump 从服务器查询取得记录直接输出而不是取得所有记录后将它们缓存到内存中</span></span><br><span class="line">quick</span><br><span class="line"></span><br><span class="line"><span class="attr">max_allowed_packet</span> = <span class="number">16</span>M</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">[mysql]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># mysql 命令行工具不使用自动补全功能，建议还是改为</span></span><br><span class="line"><span class="comment"># no-auto-rehash</span></span><br><span class="line">auto-rehash</span><br><span class="line"></span><br><span class="line"><span class="comment"># socket 文件</span></span><br><span class="line"><span class="attr">socket</span> = /var/lib/mysql/mysql.sock</span><br></pre></td></tr></table></figure>
<h2 id="3-参考资料"><a class="markdownIt-Anchor" href="#3-参考资料"></a> 3. 参考资料</h2>
<ul>
<li><a href="https://item.jd.com/11220393.html" target="_blank" rel="noopener">《高性能 MySQL》</a></li>
<li><a href="https://www.jianshu.com/p/5f39c486561b" target="_blank" rel="noopener">Mysql 配置文件/etc/my.cnf 解析</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/2020/02/10/%E6%95%88%E7%8E%87%E6%8F%90%E5%8D%87%E6%96%B9%E6%B3%95%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2020/02/10/%E6%95%88%E7%8E%87%E6%8F%90%E5%8D%87%E6%96%B9%E6%B3%95%E8%AE%BA/" class="post-title-link" itemprop="url">效率提升方法论</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-10 16:00:00" itemprop="dateCreated datePublished" datetime="2020-02-10T16:00:00+08:00">2020-02-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-14 16:45:53" itemprop="dateModified" datetime="2022-04-14T16:45:53+08:00">2022-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%95%88%E7%8E%87%E6%8F%90%E5%8D%87/" itemprop="url" rel="index">
                    <span itemprop="name">效率提升</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%95%88%E7%8E%87%E6%8F%90%E5%8D%87/%E6%96%B9%E6%B3%95%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">方法论</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2020/02/10/%E6%95%88%E7%8E%87%E6%8F%90%E5%8D%87%E6%96%B9%E6%B3%95%E8%AE%BA/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/02/10/效率提升方法论/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="效率提升方法论"><a class="markdownIt-Anchor" href="#效率提升方法论"></a> 效率提升方法论</h1>
<p>在智力水平相当的前提下，常常会发现：有些人做事，事倍功半；有些人做事，事半功倍。</p>
<p>做任何事，如果有了清晰的思路，正确的指导方针，肯定是比毫无头绪要高效很多。所以，现实中，常常会看到这样一种现象，优秀的人，往往全面优秀，干什么都出彩；而平庸的人，做什么都出不了成绩。</p>
<p>大多数人不是天才，想要变得优秀，唯一的途径就是：按照正确的习惯（方式方法），坚持不懈的努力进步（自律）。</p>
<blockquote>
<p>我们日复一日做的事情，决定了我们是怎样的人。因此<strong>所谓卓越，并非指行为，而是习惯</strong>。</p>
<p>We are what we repeatedly do. Excellence, then, is not an act, but a habit.</p>
<p>——莎士比亚</p>
</blockquote>
<h2 id="5w2h"><a class="markdownIt-Anchor" href="#5w2h"></a> 5W2H</h2>
<p><strong>5W2H 分析法是一种思考问题的启发式思维方式</strong>。5W2H 分析法用五个以 <code>W</code> 开头的英语单词和两个以 <code>H</code> 开头的英语单词进行设问，得到关键性问题的答案，最后总结归纳出问题的目标、解决思路、处理方法等，这就叫做 5W2H 法。</p>
<p>5W2H 分析法又叫七问分析法，是二战中美国陆军兵器修理部首创。这种分析法广泛用于企业管理和技术活动，对于决策和执行性的活动措施也非常有帮助，也有助于弥补考虑问题的疏漏。</p>
<p>5W2H 分析法的意义在于：避免遇到一个问题后，不知从何入手。通过设问方式，由点成线，由线成面，把问题的关键点串联起来，整理出问题的解决思路。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200210161837.png" alt="5W2H" /></p>
<ul>
<li>
<p><strong>why</strong> - 为什么？为什么要这么做？理由何在？原因是什么？</p>
</li>
<li>
<p><strong>what</strong> - 是什么？目的是什么？作什么工作？</p>
</li>
<li>
<p><strong>where</strong> - 何处？在哪里做？从哪里入手？</p>
</li>
<li>
<p><strong>when</strong> - 何时？什么时间完成？什么时机最适宜？</p>
</li>
<li>
<p><strong>who</strong> - 谁？有谁来承担？谁来完成？谁负责？</p>
</li>
<li>
<p><strong>how</strong> - 怎么做？如何提高效率？如何实施？方法怎么样？</p>
</li>
<li>
<p><strong>how much</strong> - 多少？做到什么程度？数量如何？质量水平如何？费用产出如何？</p>
</li>
</ul>
<h2 id="四象限原则"><a class="markdownIt-Anchor" href="#四象限原则"></a> 四象限原则</h2>
<p><strong>四象限原则是一种时间管理方式</strong>。</p>
<p>有首歌唱出了大多数职场人的心声：时间都去哪儿了？</p>
<p>事情、任务太多，时间太少，分身乏术。</p>
<p>时间管理四象限法则是美国的管理学家科维提出的一个时间管理的理论，按处理顺序划分为：紧急又重要、重要不紧急、紧急不重要、不紧急不重要。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200210173335.png" alt="img" /></p>
<ul>
<li>
<p><strong>第一象限（重要而紧急</strong>）</p>
<ul>
<li>案例：应付难缠的客户、准时完成工作、住院开刀等等。</li>
<li>这是考验我们的经验、判断力的时刻，也是可以用心耕耘的园地。如果荒废了，我们很会可能变成行尸走肉。但我们也不能忘记，很多重要的事都是因为一拖再拖或事前准备不足，而变成迫在眉睫。</li>
<li>该象限的本质是缺乏有效的工作计划导致本处于“重要但不紧急”第二象限的事情转变过来的，这也是传统思维状态下的管理者的通常状况，就是“忙”。</li>
</ul>
</li>
<li>
<p><strong>第二象限（重要但不紧急）</strong></p>
<ul>
<li>案例：学习新技能、建立人际关系、保持身体健康、长期的规划、问题的发掘与预防、参加培训、向上级提出问题处理的建议等等事项。</li>
<li>荒废这个领域将使第一象限日益扩大，使我们陷入更大的压力，在危机中疲于应付。反之，多投入一些时间在这个领域有利于提高实践能力，缩小第一象限的范围。做好事先的规划、准备与预防措施，很多急事将无从产生。这个领域的事情不会对我们造成催促力量，所以必须主动去做，这是发挥个人领导力的领域。</li>
<li>这更是传统低效管理者与高效卓越管理者的重要区别标志，建议管理者要把 80%的精力投入到该象限的工作，以使第一象限的“急”事无限变少，不再瞎“忙”。</li>
</ul>
</li>
<li>
<p><strong>第三象限（紧急但不重要）</strong></p>
<ul>
<li>案例：电话、会议、突发的访客都属于这一类。</li>
<li>表面看似第一象限，因为迫切的呼声会让我们产生“这件事很重要”的错觉——实际上就算重要也是对别人而言。我们花很多时间在这个里面打转，自以为是在第一象限，其实不过是在满足别人的期望与标准。</li>
</ul>
</li>
<li>
<p><strong>第四象限（不紧急也不重要）</strong></p>
<ul>
<li>案例：阅读无聊小说、看毫无内容的电视节目、办公室聊天、刷微博、刷朋友圈等。</li>
<li>简而言之就是浪费生命，所以根本不值得花半点时间在这个象限。但我们往往在一、三象限来回奔走，忙得焦头烂额，不得不到第四象限去疗养一番再出发。这部分范围倒不见得都是休闲活动，因为真正有创造意义的休闲活动是很有价值的。然而像阅读令人上瘾的无聊小说、毫无内容的电视节目、办公室聊天等。这样的休息不但不是为了走更长的路，反而是对身心的毁损，刚开始时也许有滋有味，到后来你就会发现其实是很空虚的。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/2020/02/10/hbase/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2020/02/10/hbase/" class="post-title-link" itemprop="url">Hbase</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-10 14:27:39" itemprop="dateCreated datePublished" datetime="2020-02-10T14:27:39+08:00">2020-02-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-14 16:45:53" itemprop="dateModified" datetime="2022-04-14T16:45:53+08:00">2022-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%88%97%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">列式数据库</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2020/02/10/hbase/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/02/10/hbase/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="hbase"><a class="markdownIt-Anchor" href="#hbase"></a> HBase</h1>
<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2>
<p>HBase 是建立在 HDFS 基础上的面向列的分布式数据库。</p>
<ul>
<li>HBase 参考了谷歌的 BigTable 建模，实现的编程语言为 Java。</li>
<li>它是 Hadoop 项目的子项目，运行于 HDFS 文件系统之上。</li>
</ul>
<p>HBase 适用场景：实时地随机访问超大数据集。</p>
<p>在 <a href="https://zh.wikipedia.org/wiki/CAP%E5%AE%9A%E7%90%86" target="_blank" rel="noopener">CAP 理论</a>中，HBase 属于 CP 类型的系统。</p>
<h2 id="基础"><a class="markdownIt-Anchor" href="#基础"></a> 基础</h2>
<p><a href="HBase%E8%BF%90%E7%BB%B4.md">HBase 维护</a></p>
<h2 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h2>
<h3 id="数据模型"><a class="markdownIt-Anchor" href="#数据模型"></a> 数据模型</h3>
<p>HBase 是一个面向列的数据库，在表中它由行排序。</p>
<p>HBase 表模型结构为：</p>
<ul>
<li>表（table）是行的集合。</li>
<li>行（row）是列族的集合。</li>
<li>列族（column family）是列的集合。</li>
<li>列（row）是键值对的集合。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/bigdata/hbase/1551164163369.png" alt="img" /></p>
<p>HBase 表的单元格（cell）由行和列的坐标交叉决定，是有版本的。默认情况下，版本号是自动分配的，为 HBase 插入单元格时的时间戳。单元格的内容是未解释的字节数组。</p>
<p>行的键也是未解释的字节数组，所以理论上，任何数据都可以通过序列化表示成字符串或二进制，从而存为 HBase 的键值。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/bigdata/hbase/1551164224778.png" alt="img" /></p>
<h3 id="hbase-架构"><a class="markdownIt-Anchor" href="#hbase-架构"></a> HBase 架构</h3>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/bigdata/hbase/1551164744748.png" alt="img" /></p>
<p>和 HDFS、YARN 一样，HBase 也采用 master / slave 架构：</p>
<ul>
<li>HBase 有一个 master 节点。master 节点负责将区域（region）分配给 region 节点；恢复 region 节点的故障。</li>
<li>HBase 有多个 region 节点。region 节点负责零个或多个区域（region）的管理并相应客户端的读写请求。region 节点还负责区域的划分并通知 master 节点有了新的子区域。</li>
</ul>
<p>HBase 依赖 ZooKeeper 来实现故障恢复。</p>
<h4 id="regin"><a class="markdownIt-Anchor" href="#regin"></a> Regin</h4>
<p>HBase 表按行键范围水平自动划分为区域（region）。每个区域由表中行的子集构成。每个区域由它所属的表、它所含的第一行及最后一行来表示。</p>
<p><strong>区域只不过是表被拆分，并分布在区域服务器。</strong></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/bigdata/hbase/1551165887616.png" alt="img" /></p>
<h4 id="master-服务器"><a class="markdownIt-Anchor" href="#master-服务器"></a> Master 服务器</h4>
<p>区域分配、DDL(create、delete)操作由 HBase master 服务器处理。</p>
<ul>
<li>master 服务器负责协调 region 服务器
<ul>
<li>协助区域启动，出现故障恢复或负载均衡情况时，重新分配 region 服务器</li>
<li>监控集群中的所有 region 服务器</li>
</ul>
</li>
<li>支持 DDL 接口（创建、删除、更新表）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/bigdata/hbase/1551166513572.png" alt="img" /></p>
<h4 id="regin-服务器"><a class="markdownIt-Anchor" href="#regin-服务器"></a> Regin 服务器</h4>
<p>区域服务器运行在 HDFS 数据节点上，具有以下组件</p>
<ul>
<li>
<p><code>WAL</code> - Write Ahead Log 是 HDFS 上的文件。WAL 存储尚未持久存储到永久存储的新数据，它用于在发生故障时进行恢复。</p>
</li>
<li>
<p><code>BlockCache</code> - 是读缓存。它将频繁读取的数据存储在内存中。至少最近使用的数据在完整时被逐出。</p>
</li>
<li>
<p><code>MemStore</code> - 是写缓存。它存储尚未写入磁盘的新数据。在写入磁盘之前对其进行排序。每个区域每个列族有一个 MemStore。</p>
</li>
<li>
<p><code>Hfiles</code> - 将行存储为磁盘上的排序键值对。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/bigdata/hbase/1551166602999.png" alt="img" /></p>
<h4 id="zookeeper"><a class="markdownIt-Anchor" href="#zookeeper"></a> ZooKeeper</h4>
<p>HBase 使用 ZooKeeper 作为分布式协调服务来维护集群中的服务器状态。Zookeeper 维护哪些服务器是活动的和可用的，并提供服务器故障通知。集群至少应该有 3 个节点。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/bigdata/hbase/1551166447147.png" alt="img" /></p>
<h2 id="hbase-和-rdbms"><a class="markdownIt-Anchor" href="#hbase-和-rdbms"></a> HBase 和 RDBMS</h2>
<table>
<thead>
<tr>
<th>HBase</th>
<th>RDBMS</th>
</tr>
</thead>
<tbody>
<tr>
<td>HBase 无模式，它不具有固定列模式的概念;仅定义列族。</td>
<td>RDBMS 有它的模式，描述表的整体结构的约束。</td>
</tr>
<tr>
<td>它专门创建为宽表。 HBase 是横向扩展。</td>
<td>这些都是细而专为小表。很难形成规模。</td>
</tr>
<tr>
<td>没有任何事务存在于 HBase。</td>
<td>RDBMS 是事务性的。</td>
</tr>
<tr>
<td>它反规范化的数据。</td>
<td>它具有规范化的数据。</td>
</tr>
<tr>
<td>它用于半结构以及结构化数据是非常好的。</td>
<td>用于结构化数据非常好。</td>
</tr>
</tbody>
</table>
<h2 id="api"><a class="markdownIt-Anchor" href="#api"></a> API</h2>
<p>Java API 归纳总结在这里：<a href="hbase-api-java.md">HBase 应用</a></p>
<h2 id="附录"><a class="markdownIt-Anchor" href="#附录"></a> 附录</h2>
<h3 id="命令行"><a class="markdownIt-Anchor" href="#命令行"></a> 命令行</h3>
<p>HBase 命令行可以参考这里：<a href="HBase%E5%91%BD%E4%BB%A4.md">HBase 命令行</a></p>
<h2 id="更多内容"><a class="markdownIt-Anchor" href="#更多内容"></a> 更多内容</h2>
<h3 id="扩展阅读"><a class="markdownIt-Anchor" href="#扩展阅读"></a> 扩展阅读</h3>
<ul>
<li><a href="HBase%E5%91%BD%E4%BB%A4.md">HBase 命令</a></li>
<li><a href="HBase%E8%BF%90%E7%BB%B4.md">HBase 运维</a></li>
</ul>
<h3 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h3>
<h4 id="官方"><a class="markdownIt-Anchor" href="#官方"></a> 官方</h4>
<ul>
<li><a href="http://hbase.apache.org/" target="_blank" rel="noopener">HBase 官网</a></li>
<li><a href="https://hbase.apache.org/book.html" target="_blank" rel="noopener">HBase 官方文档</a></li>
<li><a href="http://abloz.com/hbase/book.html" target="_blank" rel="noopener">HBase 官方文档中文版</a></li>
<li><a href="https://hbase.apache.org/apidocs/index.html" target="_blank" rel="noopener">HBase API</a></li>
</ul>
<h4 id="文章"><a class="markdownIt-Anchor" href="#文章"></a> 文章</h4>
<ul>
<li><a href="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/bigtable-osdi06.pdf" target="_blank" rel="noopener">Bigtable: A Distributed Storage System for Structured Data</a></li>
<li><a href="https://mapr.com/blog/in-depth-look-hbase-architecture" target="_blank" rel="noopener">An In-Depth Look at the HBase Architecture</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/2020/02/10/mysql-%E6%95%99%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2020/02/10/mysql-%E6%95%99%E7%A8%8B/" class="post-title-link" itemprop="url">Mysql 教程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-10 14:27:39" itemprop="dateCreated datePublished" datetime="2020-02-10T14:27:39+08:00">2020-02-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-14 16:45:53" itemprop="dateModified" datetime="2022-04-14T16:45:53+08:00">2022-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">关系型数据库</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/" itemprop="url" rel="index">
                    <span itemprop="name">Mysql</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2020/02/10/mysql-%E6%95%99%E7%A8%8B/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/02/10/mysql-教程/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>388</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="mysql-教程"><a class="markdownIt-Anchor" href="#mysql-教程"></a> Mysql 教程</h1>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200716103611.png" alt="img" /></p>
<h2 id="内容"><a class="markdownIt-Anchor" href="#内容"></a> 📖 内容</h2>
<h3 id="mysql-应用指南"><a class="markdownIt-Anchor" href="#mysql-应用指南"></a> <a href="01.Mysql%E5%BA%94%E7%94%A8%E6%8C%87%E5%8D%97.md">Mysql 应用指南</a></h3>
<h3 id="mysql-工作流"><a class="markdownIt-Anchor" href="#mysql-工作流"></a> <a href="02.MySQL%E5%B7%A5%E4%BD%9C%E6%B5%81.md">Mysql 工作流</a></h3>
<h3 id="mysql-事务"><a class="markdownIt-Anchor" href="#mysql-事务"></a> <a href="03.Mysql%E4%BA%8B%E5%8A%A1.md">Mysql 事务</a></h3>
<blockquote>
<p>关键词：<code>ACID</code>、<code>AUTOCOMMIT</code>、<code>事务隔离级别</code>、<code>死锁</code>、<code>分布式事务</code></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200716074533.png" alt="img" /></p>
<h3 id="mysql-锁"><a class="markdownIt-Anchor" href="#mysql-锁"></a> <a href="04.Mysql%E9%94%81.md">Mysql 锁</a></h3>
<blockquote>
<p>关键词：<code>乐观锁</code>、<code>表级锁</code>、<code>行级锁</code>、<code>意向锁</code>、<code>MVCC</code>、<code>Next-key 锁</code></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200716064947.png" alt="img" /></p>
<h3 id="mysql-索引"><a class="markdownIt-Anchor" href="#mysql-索引"></a> <a href="05.Mysql%E7%B4%A2%E5%BC%95.md">Mysql 索引</a></h3>
<blockquote>
<p>关键词：<code>Hash</code>、<code>B 树</code>、<code>聚簇索引</code>、<code>回表</code></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200715172009.png" alt="img" /></p>
<h3 id="mysql-性能优化"><a class="markdownIt-Anchor" href="#mysql-性能优化"></a> <a href="06.Mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.md">Mysql 性能优化</a></h3>
<h3 id="mysql-运维"><a class="markdownIt-Anchor" href="#mysql-运维"></a> <a href="20.Mysql%E8%BF%90%E7%BB%B4.md">Mysql 运维</a> 🔨</h3>
<h3 id="mysql-配置"><a class="markdownIt-Anchor" href="#mysql-配置"></a> <a href="21.Mysql%E9%85%8D%E7%BD%AE.md">Mysql 配置</a> 🔨</h3>
<h3 id="mysql-常见问题"><a class="markdownIt-Anchor" href="#mysql-常见问题"></a> <a href="99.Mysql%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98">Mysql 常见问题</a></h3>
<hr />
<p>相关扩展知识：</p>
<ul>
<li><a href="https://github.com/dunwu/db-tutorial/blob/master/docs/sql/sql-interview.md" target="_blank" rel="noopener">关系型数据库面试总结</a> 💯</li>
<li><a href="https://github.com/dunwu/db-tutorial/blob/master/docs/sql/sql-cheat-sheet.md" target="_blank" rel="noopener">SQL Cheat Sheet</a></li>
<li><a href="https://github.com/dunwu/blog/blob/master/source/_posts/theory/distributed-transaction.md" target="_blank" rel="noopener">分布式事务基本原理</a></li>
</ul>
<h2 id="资料"><a class="markdownIt-Anchor" href="#资料"></a> 📚 资料</h2>
<ul>
<li><strong>官方</strong>
<ul>
<li><a href="https://www.mysql.com/" target="_blank" rel="noopener">Mysql 官网</a></li>
<li><a href="https://dev.mysql.com/doc/" target="_blank" rel="noopener">Mysql 官方文档</a></li>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/mysql.html" target="_blank" rel="noopener">Mysql 官方文档之命令行客户端</a></li>
</ul>
</li>
<li><strong>书籍</strong>
<ul>
<li><a href="https://book.douban.com/subject/23008813/" target="_blank" rel="noopener">《高性能 MySQL》</a> - 经典，适合 DBA 或作为开发者的参考手册</li>
<li><a href="https://book.douban.com/subject/3354490/" target="_blank" rel="noopener">《MySQL 必知必会》</a> - 适合入门者</li>
</ul>
</li>
<li><strong>教程</strong>
<ul>
<li><a href="https://time.geekbang.org/column/intro/139" target="_blank" rel="noopener">MySQL 实战 45 讲</a></li>
<li><a href="http://www.runoob.com/mysql/mysql-tutorial.html" target="_blank" rel="noopener">runoob.com MySQL 教程</a></li>
<li><a href="https://github.com/jaywcjlove/mysql-tutorial" target="_blank" rel="noopener">mysql-tutorial</a></li>
</ul>
</li>
<li><strong>更多资源</strong>
<ul>
<li><a href="https://github.com/jobbole/awesome-mysql-cn" target="_blank" rel="noopener">awesome-mysql</a></li>
</ul>
</li>
</ul>
<h2 id="传送"><a class="markdownIt-Anchor" href="#传送"></a> 🚪 传送</h2>
<p>◾ 🏠 <a href="https://github.com/dunwu/db-tutorial" target="_blank" rel="noopener">DB-TUTORIAL 首页</a> ◾ 🎯 <a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">我的博客</a> ◾</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/2020/02/10/redis-%E6%95%99%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2020/02/10/redis-%E6%95%99%E7%A8%8B/" class="post-title-link" itemprop="url">Redis 教程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-10 14:27:39" itemprop="dateCreated datePublished" datetime="2020-02-10T14:27:39+08:00">2020-02-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-14 16:45:53" itemprop="dateModified" datetime="2022-04-14T16:45:53+08:00">2022-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">KV数据库</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2020/02/10/redis-%E6%95%99%E7%A8%8B/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/02/10/redis-教程/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>837</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="redis-教程"><a class="markdownIt-Anchor" href="#redis-教程"></a> Redis 教程</h1>
<blockquote>
<p>Redis 最典型的应用场景是作为分布式缓存。</p>
<p>学习 Redis，有必要深入理解缓存的原理，以及 Redis 作为一种缓存方案，在系统应用中的定位。</p>
<p>参考：<a href="https://dunwu.github.io/design/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98.html">缓存基本原理</a>，有助于理解缓存的特性、原理，使用缓存常见的问题及解决方案。</p>
</blockquote>
<h2 id="内容"><a class="markdownIt-Anchor" href="#内容"></a> 📖 内容</h2>
<h3 id="redis-面试总结"><a class="markdownIt-Anchor" href="#redis-面试总结"></a> <a href="01.Redis%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93.md">Redis 面试总结 💯</a></h3>
<h3 id="redis-应用指南"><a class="markdownIt-Anchor" href="#redis-应用指南"></a> <a href="02.Redis%E5%BA%94%E7%94%A8%E6%8C%87%E5%8D%97.md">Redis 应用指南 ⚡</a></h3>
<blockquote>
<p>关键词：<code>内存淘汰</code>、<code>事件</code>、<code>事务</code>、<code>管道</code>、<code>发布与订阅</code></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200713105627.png" alt="img" /></p>
<h3 id="redis-数据类型和应用"><a class="markdownIt-Anchor" href="#redis-数据类型和应用"></a> <a href="03.Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BA%94%E7%94%A8.md">Redis 数据类型和应用</a></h3>
<blockquote>
<p>关键词：<code>STRING</code>、<code>HASH</code>、<code>LIST</code>、<code>SET</code>、<code>ZSET</code>、<code>BitMap</code>、<code>HyperLogLog</code>、<code>Geo</code></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200226113813.png" alt="Redis 数据类型" /></p>
<h3 id="redis-持久化"><a class="markdownIt-Anchor" href="#redis-持久化"></a> <a href="04.Redis%E6%8C%81%E4%B9%85%E5%8C%96.md">Redis 持久化</a></h3>
<blockquote>
<p>关键词：<code>RDB</code>、<code>AOF</code>、<code>SAVE</code>、<code>BGSAVE</code>、<code>appendfsync</code></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200224214047.png" alt="img" /></p>
<h3 id="redis-复制"><a class="markdownIt-Anchor" href="#redis-复制"></a> <a href="05.Redis%E5%A4%8D%E5%88%B6.md">Redis 复制</a></h3>
<blockquote>
<p>关键词：<code>SLAVEOF</code>、<code>SYNC</code>、<code>PSYNC</code>、<code>REPLCONF ACK</code></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200712182603.png" alt="img" /></p>
<h3 id="redis-哨兵"><a class="markdownIt-Anchor" href="#redis-哨兵"></a> <a href="06.Redis%E5%93%A8%E5%85%B5.md">Redis 哨兵</a></h3>
<blockquote>
<p>Redis 哨兵（Sentinel）是 Redis 的高可用性（Hight Availability）解决方案。</p>
<p>Redis 哨兵是 Raft 算法 的具体实现。</p>
<p>关键词：<code>Sentinel</code>、<code>PING</code>、<code>INFO</code>、<code>Raft</code></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200713072747.png" alt="img" /></p>
<h3 id="redis-集群"><a class="markdownIt-Anchor" href="#redis-集群"></a> <a href="07.Redis%E9%9B%86%E7%BE%A4.md">Redis 集群</a></h3>
<blockquote>
<p>关键词：<code>CLUSTER MEET</code>、<code>Hash slot</code>、<code>MOVED</code>、<code>ASK</code>、<code>SLAVEOF no one</code>、<code>redis-trib</code></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200713100613.png" alt="img" /></p>
<h3 id="redis-实战"><a class="markdownIt-Anchor" href="#redis-实战"></a> <a href="08.Redis%E5%AE%9E%E6%88%98.md">Redis 实战</a></h3>
<blockquote>
<p>关键词：<code>缓存</code>、<code>分布式锁</code>、<code>布隆过滤器</code></p>
</blockquote>
<h3 id="redis-运维"><a class="markdownIt-Anchor" href="#redis-运维"></a> <a href="20.Redis%E8%BF%90%E7%BB%B4.md">Redis 运维 🔨</a></h3>
<blockquote>
<p>关键词：<code>安装</code>、<code>命令</code>、<code>集群</code>、<code>客户端</code></p>
</blockquote>
<h2 id="资料"><a class="markdownIt-Anchor" href="#资料"></a> 📚 资料</h2>
<ul>
<li><strong>官网</strong>
<ul>
<li><a href="https://redis.io/" target="_blank" rel="noopener">Redis 官网</a></li>
<li><a href="https://github.com/antirez/redis" target="_blank" rel="noopener">Redis github</a></li>
<li><a href="http://redis.cn/" target="_blank" rel="noopener">Redis 官方文档中文版</a></li>
</ul>
</li>
<li><strong>书籍</strong>
<ul>
<li><a href="https://item.jd.com/11791607.html" target="_blank" rel="noopener">《Redis 实战》</a></li>
<li><a href="https://item.jd.com/11486101.html" target="_blank" rel="noopener">《Redis 设计与实现》</a></li>
</ul>
</li>
<li><strong>教程</strong>
<ul>
<li><a href="http://redisdoc.com/" target="_blank" rel="noopener">Redis 命令参考</a></li>
</ul>
</li>
<li><strong>文章</strong>
<ul>
<li><a href="https://www.slideshare.net/dvirsky/introduction-to-redis" target="_blank" rel="noopener">Introduction to Redis</a></li>
<li><a href="https://juejin.im/post/5db66ed9e51d452a2f15d833" target="_blank" rel="noopener">《我们一起进大厂》系列- Redis 基础</a></li>
</ul>
</li>
<li><strong>源码</strong>
<ul>
<li><a href="https://github.com/josiahcarlson/redis-in-action" target="_blank" rel="noopener">《Redis 实战》配套 Python 源码</a></li>
</ul>
</li>
<li><strong>资源汇总</strong>
<ul>
<li><a href="https://github.com/JamzyWang/awesome-redis" target="_blank" rel="noopener">awesome-redis</a></li>
</ul>
</li>
<li><strong>Redis Client</strong>
<ul>
<li><a href="https://docs.spring.io/spring-data/redis/docs/1.8.13.RELEASE/reference/html/" target="_blank" rel="noopener">spring-data-redis 官方文档</a></li>
<li><a href="https://github.com/redisson/redisson/wiki/%E7%9B%AE%E5%BD%95" target="_blank" rel="noopener">redisson 官方文档(中文,略有滞后)</a></li>
<li><a href="https://github.com/redisson/redisson/wiki/Table-of-Content" target="_blank" rel="noopener">redisson 官方文档(英文)</a></li>
<li><a href="https://www.jianshu.com/p/82f0d5abb002" target="_blank" rel="noopener">CRUG | Redisson PRO vs. Jedis: Which Is Faster? 翻译</a></li>
<li><a href="https://blog.csdn.net/everlasting_188/article/details/51073505" target="_blank" rel="noopener">redis 分布锁 Redisson 性能测试</a></li>
</ul>
</li>
</ul>
<h2 id="传送"><a class="markdownIt-Anchor" href="#传送"></a> 🚪 传送</h2>
<p>◾ 🏠 <a href="https://github.com/dunwu/db-tutorial" target="_blank" rel="noopener">DB-TUTORIAL 首页</a> ◾ 🎯 <a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">我的博客</a> ◾</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/2020/02/09/nosql%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2020/02/09/nosql%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/" class="post-title-link" itemprop="url">Nosql技术选型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-09 02:18:58" itemprop="dateCreated datePublished" datetime="2020-02-09T02:18:58+08:00">2020-02-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-14 16:45:53" itemprop="dateModified" datetime="2022-04-14T16:45:53+08:00">2022-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%BC%E5%90%88/" itemprop="url" rel="index">
                    <span itemprop="name">数据库综合</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2020/02/09/nosql%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/02/09/nosql技术选型/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="nosql-技术选型"><a class="markdownIt-Anchor" href="#nosql-技术选型"></a> Nosql 技术选型</h1>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200209020702.png" alt="img" /></p>
<h2 id="一-nosql-简介"><a class="markdownIt-Anchor" href="#一-nosql-简介"></a> 一、Nosql 简介</h2>
<p>传统的关系型数据库存在以下缺点：</p>
<ul>
<li><strong>大数据场景下 I/O 较高</strong> - 因为数据是按行存储，即使只针对其中某一列进行运算，关系型数据库也会将整行数据从存储设备中读入内存，导致 I/O 较高。</li>
<li>存储的是行记录，<strong>无法存储数据结构</strong>。</li>
<li><strong>表结构 schema 扩展不方便</strong> - 如要需要修改表结构，需要执行执行 DDL(data definition language)，语句修改，修改期间会导致锁表，部分服务不可用。</li>
<li><strong>全文搜索功能较弱</strong> - 关系型数据库下只能够进行子字符串的匹配查询，当表的数据逐渐变大的时候，<code>LIKE</code> 查询的匹配会非常慢，即使在有索引的情况下。况且关系型数据库也不应该对文本字段进行索引。</li>
<li><strong>存储和处理复杂关系型数据功能较弱</strong> - 许多应用程序需要了解和导航高度连接数据之间的关系，才能启用社交应用程序、推荐引擎、欺诈检测、知识图谱、生命科学和 IT/网络等用例。然而传统的关系数据库并不善于处理数据点之间的关系。它们的表格数据模型和严格的模式使它们很难添加新的或不同种类的关联信息。</li>
</ul>
<p>随着大数据时代的到来，越来越多的网站、应用系统需要支撑海量数据存储，高并发请求、高可用、高可扩展性等特性要求。传统的关系型数据库在应付这些调整已经显得力不从心，暴露了许多能以克服的问题。由此，各种各样的 NoSQL（Not Only SQL）数据库作为传统关系型数据的一个有力补充得到迅猛发展。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200209005228.png" alt="nosql-history" /></p>
<p><strong>NoSQL，泛指非关系型的数据库</strong>，可以理解为 SQL 的一个有力补充。</p>
<p>在 NoSQL 许多方面性能大大优于非关系型数据库的同时，往往也伴随一些特性的缺失，比较常见的，是事务库事务功能的缺失。 数据库事务正确执行的四个基本要素：ACID 如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">名称</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">A</td>
<td style="text-align:center">Atomicity (原子性)</td>
<td style="text-align:center">一个事务中的所有操作，要么全部完成，要么全部不完成，不会在中间某个环节结束。 事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样。</td>
</tr>
<tr>
<td style="text-align:center">C</td>
<td style="text-align:center">Consistency 一致性</td>
<td style="text-align:center">在事务开始之前和事务结束以后，数据的数据的一致性约束没有被破坏。</td>
</tr>
<tr>
<td style="text-align:center">I</td>
<td style="text-align:center">Isolation 隔离性</td>
<td style="text-align:center">数据库允许多个并发事务同时对数据进行读写和修改的能力。隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。</td>
</tr>
<tr>
<td style="text-align:center">D</td>
<td style="text-align:center">Durability 持久性</td>
<td style="text-align:center">事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</td>
</tr>
</tbody>
</table>
<p>下面介绍 5 大类 NoSQL 数据针对传统关系型数据库的缺点提供的解决方案：</p>
<h2 id="二-列式数据库"><a class="markdownIt-Anchor" href="#二-列式数据库"></a> 二、列式数据库</h2>
<p>列式数据库是以列相关存储架构进行数据存储的数据库，主要<strong>适合于批量数据处理和即时查询</strong>。</p>
<p>相对应的是行式数据库，数据以行相关的存储体系架构进行空间分配，主要适合于小批量的数据处理，常用于联机事务型数据处理。</p>
<p>基于列式数据库的列列存储特性，可以<strong>解决某些特定场景下关系型数据库 I/O 较高的问题</strong>。</p>
<h3 id="列式数据库原理"><a class="markdownIt-Anchor" href="#列式数据库原理"></a> 列式数据库原理</h3>
<p>传统关系型数据库是按照行来存储数据库，称为“行式数据库”，而列式数据库是按照列来存储数据。</p>
<p>将表放入存储系统中有两种方法，而我们绝大部分是采用行存储的。 行存储法是将各行放入连续的物理位置，这很像传统的记录和文件系统。 列存储法是将数据按照列存储到数据库中，与行存储类似，下图是两种存储方法的图形化解释：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200209005316.png" alt="按行存储和按列存储模式" /></p>
<h3 id="列式数据库产品"><a class="markdownIt-Anchor" href="#列式数据库产品"></a> 列式数据库产品</h3>
<ul>
<li>
<p>HBase</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/10/165234a1e88bddc0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="HBase" /></p>
<p>HBase 是一个开源的非关系型分布式数据库（NoSQL），它参考了谷歌的 BigTable 建模，实现的编程语言为 Java。它是 Apache 软件基金会的 Hadoop 项目的一部分，运行于 HDFS 文件系统之上，为 Hadoop 提供类似于 BigTable 规模的服务。因此，它可以容错地存储海量稀疏的数据。</p>
</li>
<li>
<p>BigTable</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/10/165234a1e9147edf?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" /></p>
<p>BigTable 是一种压缩的、高性能的、高可扩展性的，基于 Google 文件系统（Google File System，GFS）的数据存储系统，用于存储大规模结构化数据，适用于云端计算。</p>
</li>
</ul>
<h3 id="列式数据库特性"><a class="markdownIt-Anchor" href="#列式数据库特性"></a> 列式数据库特性</h3>
<p>优点如下：</p>
<ul>
<li><strong>高效的储存空间利用率</strong></li>
</ul>
<p>列式数据库由于其针对不同列的数据特征而发明的不同算法，使其<strong>往往有比行式数据库高的多的压缩率</strong>，普通的行式数据库一般压缩率在 3：1 到 5：1 左右，而列式数据库的压缩率一般在 8：1 到 30：1 左右。 比较常见的，通过字典表压缩数据： 下面中才是那张表本来的样子。经过字典表进行数据压缩后，表中的字符串才都变成数字了。正因为每个字符串在字典表里只出现一次了，所以达到了压缩的目的(有点像规范化和非规范化 Normalize 和 Denomalize)</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200209005406.png" alt="通过字典表压缩数据" /></p>
<ul>
<li><strong>查询效率高</strong></li>
</ul>
<p>读取多条数据的同一列效率高，因为这些列都是存储在一起的，一次磁盘操作可以数据的指定列全部读取到内存中。 下图通过一条查询的执行过程说明列式存储(以及数据压缩)的优点</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200209005611.png" alt="img" /></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">执行步骤如下：</span><br><span class="line">i. 去字典表里找到字符串对应数字(只进行一次字符串比较)。</span><br><span class="line">ii. 用数字去列表里匹配，匹配上的位置设为<span class="number">1</span>。</span><br><span class="line">iii. 把不同列的匹配结果进行位运算得到符合所有条件的记录下标。</span><br><span class="line">iv. 使用这个下标组装出最终的结果集。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>适合做聚合操作</strong></li>
<li><strong>适合大量的数据而不是小数据</strong></li>
</ul>
<p>缺点如下：</p>
<ul>
<li>不适合扫描小量数据</li>
<li>不适合随机的更新</li>
<li>不适合做含有删除和更新的实时操作</li>
<li>单行的数据是 ACID 的，多行的事务时，不支持事务的正常回滚，支持 I(Isolation)隔离性(事务串行提交)，D(Durability)持久性，不能保证 A(Atomicity)原子性， C(Consistency)一致性</li>
</ul>
<h3 id="列式数据库使用场景"><a class="markdownIt-Anchor" href="#列式数据库使用场景"></a> 列式数据库使用场景</h3>
<p>以 HBase 为例说明：</p>
<ul>
<li><strong>大数据量</strong> （100s TB 级数据） 且有快速随机访问的需求。增长量无法预估的应用，需要进行优雅的数据扩展的 HBase 支持在线扩展，即使在一段时间内数据量呈井喷式增长，也可以通过 HBase 横向扩展来满足功能。</li>
<li><strong>写密集型</strong>应用，每天写入量巨大，而相对读数量较小的应用 比如 IM 的历史消息，游戏的日志等等</li>
<li><strong>不需要复杂查询条件</strong>来查询数据的应用 HBase 只支持基于 rowkey 的查询，对于 HBase 来说，单条记录或者小范围的查询是可以接受的，大范围的查询由于分布式的原因，可能在性能上有点影响，HBase 不适用于有 join，多级索引，表关系复杂的数据模型。</li>
<li><strong>对性能和可靠性要求非常高</strong>的应用，由于 HBase 本身没有单点故障，可用性非常高。</li>
<li><strong>存储结构化和半结构化的数据</strong>。</li>
</ul>
<h2 id="三-k-v-数据库"><a class="markdownIt-Anchor" href="#三-k-v-数据库"></a> 三、K-V 数据库</h2>
<p><strong>K-V 数据库指的是使用键值(key-value)存储的数据库，其数据按照键值对的形式进行组织、索引和存储</strong>。</p>
<p>KV 存储非常适合存储<strong>不涉及过多数据关系业务关系的数据</strong>，同时能有效减少读写磁盘的次数，比 SQL 数据库存储拥有更好的读写性能，能够<strong>解决关系型数据库无法存储数据结构的问题</strong>。</p>
<h3 id="k-v-数据库产品"><a class="markdownIt-Anchor" href="#k-v-数据库产品"></a> K-V 数据库产品</h3>
<ul>
<li>
<p>Redis</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200209010410.png" alt="img" /></p>
<p>Redis 是一个使用 ANSI C 编写的开源、支持网络、基于内存、可选持久性的键值对存储数据库。从 2015 年 6 月开始，Redis 的开发由 Redis Labs 赞助，而 2013 年 5 月至 2015 年 6 月期间，其开发由 Pivotal 赞助。在 2013 年 5 月之前，其开发由 VMware 赞助。根据月度排行网站 <a href="http://DB-Engines.com" target="_blank" rel="noopener">DB-Engines.com</a> 的数据显示，Redis 是最流行的键值对存储数据库。</p>
</li>
<li>
<p>Cassandra</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200209010451.png" alt="img" /></p>
<p>Apache Cassandra（社区内一般简称为 C*）是一套开源分布式 NoSQL 数据库系统。它最初由 Facebook 开发，用于储存收件箱等简单格式数据，集 Google BigTable 的数据模型与 Amazon Dynamo 的完全分布式架构于一身。Facebook 于 2008 将 Cassandra 开源，此后，由于 Cassandra 良好的可扩展性和性能，被 Apple, Comcast,Instagram, Spotify, eBay, Rackspace, Netflix 等知名网站所采用，成为了一种流行的分布式结构化数据存储方案。</p>
</li>
<li>
<p>LevelDB</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200209011140.png" alt="img" /></p>
<p>LevelDB 是一个由 Google 公司所研发的键／值对（Key/Value Pair）嵌入式数据库管理系统编程库， 以开源的 BSD 许可证发布。</p>
</li>
</ul>
<h3 id="k-v-数据库特性"><a class="markdownIt-Anchor" href="#k-v-数据库特性"></a> K-V 数据库特性</h3>
<p>以 Redis 为例：</p>
<p>优点如下：</p>
<ul>
<li><strong>性能极高</strong> - Redis 能支持超过 10W 的 TPS。</li>
<li><strong>丰富的数据类型</strong> - Redis 支持包括 String，Hash，List，Set，Sorted Set，Bitmap 和 hyperloglog。</li>
<li><strong>丰富的特性</strong> - Redis 还支持 publish/subscribe、通知、key 过期等等特性。</li>
</ul>
<p>缺点如下： 针对 ACID，Redis 事务不能支持原子性和持久性(A 和 D)，只支持隔离性和一致性(I 和 C) 特别说明一下，这里所说的无法保证原子性，是针对 Redis 的事务操作，因为事务是不支持回滚（roll back），而因为 Redis 的单线程模型，<strong>Redis 的普通操作是原子性的</strong>。</p>
<p>大部分业务不需要严格遵循 ACID 原则，例如游戏实时排行榜，粉丝关注等场景，即使部分数据持久化失败，其实业务影响也非常小。因此在设计方案时，需要根据业务特征和要求来做选择</p>
<h3 id="k-v-数据库使用场景"><a class="markdownIt-Anchor" href="#k-v-数据库使用场景"></a> K-V 数据库使用场景</h3>
<ul>
<li>
<p><strong>适用场景</strong> - 储存用户信息(比如会话)、配置文件、参数、购物车等等。这些信息一般都和 ID（键）挂钩。</p>
</li>
<li>
<p><strong>不适用场景</strong></p>
<ul>
<li>需要通过值来查询，而不是键来查询。Key-Value 数据库中根本没有通过值查询的途径。</li>
<li>需要储存数据之间的关系。在 Key-Value 数据库中不能通过两个或以上的键来关联数据</li>
<li>需要事务的支持。在 Key-Value 数据库中故障产生时不可以进行回滚。</li>
</ul>
</li>
</ul>
<h2 id="四-文档数据库"><a class="markdownIt-Anchor" href="#四-文档数据库"></a> 四、文档数据库</h2>
<p>文档数据库（也称为文档型数据库）是<strong>旨在将半结构化数据存储为文档的一种数据库，它可以解决关系型数据库表结构 schema 扩展不方便的问题</strong>。文档数据库<strong>通常以 JSON 或 XML 格式存储数据</strong>。</p>
<p>由于文档数据库的 no-schema 特性，可以存储和读取任意数据。由于使用的数据格式是 JSON 或者 XML，无需在使用前定义字段，读取一个 JSON 中不存在的字段也不会导致 SQL 那样的语法错误。</p>
<h3 id="文档数据库产品"><a class="markdownIt-Anchor" href="#文档数据库产品"></a> 文档数据库产品</h3>
<ul>
<li>
<p>MongoDB</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200209012320.png" alt="img" /></p>
<p><strong>MongoDB</strong>是一种面向文档的数据库管理系统，由 C++ 撰写而成，以此来解决应用程序开发社区中的大量现实问题。2007 年 10 月，MongoDB 由 10gen 团队所发展。2009 年 2 月首度推出。</p>
</li>
<li>
<p>CouchDB</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200209012418.png" alt="img" /></p>
<p>Apache CouchDB 是一个开源数据库，专注于易用性和成为&quot;<strong>完全拥抱 web 的数据库</strong>&quot;。它是一个使用 JSON 作为存储格式，JavaScript 作为查询语言，MapReduce 和 HTTP 作为 API 的 NoSQL 数据库。其中一个显著的功能就是多主复制。CouchDB 的第一个版本发布在 2005 年，在 2008 年成为了 Apache 的项目。</p>
</li>
</ul>
<h3 id="文档数据库特性"><a class="markdownIt-Anchor" href="#文档数据库特性"></a> 文档数据库特性</h3>
<p>以 MongoDB 为例进行说明</p>
<p>优点如下：</p>
<ul>
<li><strong>容易存储复杂数据结构</strong> - JSON 是一种强大的描述语言，能够描述复杂的数据结构。</li>
<li><strong>容易变更数据结构</strong> - 无需像关系型数据库一样先执行 DDL 语句修改表结构，程序代码直接读写即可。</li>
<li><strong>容易兼容历史数据</strong> - 对于历史数据，即使没有新增的字段，也不会导致错误，只会返回空值，此时代码兼容处理即可。</li>
</ul>
<p>缺点如下：</p>
<ul>
<li><strong>部分支持事务</strong>
<ul>
<li>Atomicity(原子性) 仅支持单行/文档级原子性，不支持多行、多文档、多语句原子性。</li>
<li>Isolation(隔离性) 隔离级别仅支持已提交读（Read committed）级别，可能导致不可重复读，幻读的问题。</li>
</ul>
</li>
<li><strong>不支持复杂查询</strong> - 例如 join 查询，如果需要 join 查询，需要多次操作数据库。</li>
</ul>
<p>MongonDB 还是支持多文档事务的 Consistency(一致性)和 Durability(持久性)</p>
<p>虽然官方宣布 MongoDB 将在 4.0 版本中正式推出多文档 ACID 事务支持，最后落地情况还有待见证。</p>
<h3 id="文档数据库使用场景"><a class="markdownIt-Anchor" href="#文档数据库使用场景"></a> 文档数据库使用场景</h3>
<p><strong>适用场景</strong>：</p>
<ul>
<li><strong>大数据量，且未来数据增长很快</strong></li>
<li><strong>表结构不明确，且字段在不断增加</strong>，例如内容管理系统，信息管理系统</li>
</ul>
<p><strong>不适用场景</strong>：</p>
<ul>
<li><strong>支持事务</strong> - 在不同的文档上需要添加事务。Document-Oriented 数据库并不支持文档间的事务</li>
<li><strong>支持复杂查询</strong> - 多个文档直接需要复杂查询，例如 join</li>
</ul>
<h2 id="五-全文搜索引擎"><a class="markdownIt-Anchor" href="#五-全文搜索引擎"></a> 五、全文搜索引擎</h2>
<p>传统关系型数据库主要通过索引来达到快速查询的目的，在全文搜索的业务下，索引也无能为力，主要体现在：</p>
<ul>
<li>全文搜索的条件可以随意排列组合，如果通过索引来满足，则索引的数量非常多</li>
<li>全文搜索的模糊匹配方式，索引无法满足，只能用 <code>LIKE</code> 查询，而 <code>LIKE</code> 查询是整表扫描，效率非常低</li>
</ul>
<p>而全文搜索引擎的出现，正是<strong>解决关系型数据库全文搜索功能较弱的问题</strong>。</p>
<h3 id="搜索引擎原理"><a class="markdownIt-Anchor" href="#搜索引擎原理"></a> 搜索引擎原理</h3>
<p>全文搜索引擎的技术原理称为 <strong><code>倒排索引（inverted index）</code></strong>，是一种索引方法，其基本原理是建立单词到文档的索引。与之相对是，是“正排索引”，其基本原理是建立文档到单词的索引。</p>
<p>现在有如下文档集合：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200209014530.png" alt="img" /></p>
<p>正排索引得到索引如下：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200209014723.png" alt="img" /></p>
<p>可见，正排索引适用于根据文档名称查询文档内容</p>
<p>简单的倒排索引如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/10/165234a2750634bc?imageslim" alt="img" /></p>
<p>带有单词频率信息的倒排索引如下：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200209014842.png" alt="img" /></p>
<p>可见，倒排索引适用于根据关键词来查询文档内容</p>
<h3 id="搜索引擎产品"><a class="markdownIt-Anchor" href="#搜索引擎产品"></a> 搜索引擎产品</h3>
<ul>
<li>
<p>Elasticsearch</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/10/165234a27ea53fae?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" /></p>
<p>Elasticsearch 是一个基于 Lucene 的搜索引擎。它提供了一个分布式，多租户 -能够全文搜索与发动机 HTTP Web 界面和无架构 JSON 文件。Elasticsearch 是用 Java 开发的，并根据 Apache License 的条款作为开源发布。根据 DB-Engines 排名，Elasticsearch 是最受欢迎的企业搜索引擎，后面是基于 Lucene 的 Apache Solr。</p>
</li>
<li>
<p>Solr</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200209014947.png" alt="img" /></p>
<p>Solr 是 Apache Lucene 项目的开源企业搜索平台。其主要功能包括全文检索、命中标示、分面搜索、动态聚类、数据库集成，以及富文本（如 Word、PDF）的处理。Solr 是高度可扩展的，并提供了分布式搜索和索引复制</p>
</li>
</ul>
<h3 id="搜索引擎特性"><a class="markdownIt-Anchor" href="#搜索引擎特性"></a> 搜索引擎特性</h3>
<p>以 Elasticsearch 为例： 优点如下：</p>
<ul>
<li><strong>查询效率高</strong> - 对海量数据进行近实时的处理</li>
<li><strong>可扩展性</strong> - 基于集群环境可以方便横向扩展，可以承载 PB 级数据</li>
<li><strong>高可用</strong> - Elasticsearch 集群弹性-他们将发现新的或失败的节点，重组和重新平衡数据，确保数据是安全的和可访问的</li>
</ul>
<p>缺点如下：</p>
<ul>
<li><strong>部分支持事务</strong> - 单一文档的数据是 ACID 的，包含多个文档的事务时不支持事务的正常回滚，支持 I(Isolation)隔离性（基于乐观锁机制的），D(Durability)持久性，<strong>不支持 A(Atomicity)原子性，C(Consistency)一致性</strong></li>
<li>对类似数据库中通过外键的复杂的多表关联操作支持较弱。</li>
<li><strong>读写有一定延时</strong>，写入的数据，最快 1s 中能被检索到</li>
<li><strong>更新性能较低</strong>，底层实现是先删数据，再插入新数据</li>
<li><strong>内存占用大</strong>，因为 Lucene 将索引部分加载到内存中</li>
</ul>
<h3 id="搜索引擎场景"><a class="markdownIt-Anchor" href="#搜索引擎场景"></a> 搜索引擎场景</h3>
<p>适用场景如下：</p>
<ul>
<li><strong>搜索引擎和数据分析引擎</strong> - 全文检索，结构化检索，数据分析</li>
<li><strong>对海量数据进行近实时的处理</strong> - 可以将海量数据分散到多台服务器上去存储和检索</li>
</ul>
<p>不适用场景如下：</p>
<ul>
<li><strong>数据需要频繁更新</strong></li>
<li><strong>需要复杂关联查询</strong></li>
</ul>
<h2 id="六-图数据库"><a class="markdownIt-Anchor" href="#六-图数据库"></a> 六、图数据库</h2>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200209015751.png" alt="img" /></p>
<p><strong>图形数据库应用图论存储实体之间的关系信息</strong>。最常见例子就是社会网络中人与人之间的关系。关系型数据库用于存储“关系型”数据的效果并不好，其查询复杂、缓慢、超出预期，而图形数据库的独特设计恰恰弥补了这个缺陷，解决关系型数据库存储和处理复杂关系型数据功能较弱的问题。</p>
<h3 id="图数据库产品"><a class="markdownIt-Anchor" href="#图数据库产品"></a> 图数据库产品</h3>
<ul>
<li>
<p>Neo4j</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200209015817.png" alt="img" /></p>
<p>Neo4j 是由 Neo4j，Inc。开发的图形数据库管理系统。由其开发人员描述为具有原生图存储和处理的符合 ACID 的事务数据库，根据 DB-Engines 排名， Neo4j 是最流行的图形数据库。</p>
</li>
<li>
<p>ArangoDB</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200209015858.png" alt="img" /></p>
<p>ArangoDB 是由 triAGENS GmbH 开发的原生多模型数据库系统。数据库系统支持三个重要的数据模型（键/值，文档，图形），其中包含一个数据库核心和统一查询语言 AQL（ArangoDB 查询语言）。查询语言是声明性的，允许在单个查询中组合不同的数据访问模式。ArangoDB 是一个 NoSQL 数据库系统，但 AQL 在很多方面与 SQL 类似。</p>
</li>
<li>
<p>Titan</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200209015923.png" alt="img" /></p>
<p>Titan 是一个可扩展的图形数据库，针对存储和查询包含分布在多机群集中的数百亿个顶点和边缘的图形进行了优化。Titan 是一个事务性数据库，可以支持数千个并发用户实时执行复杂的图形遍历。</p>
</li>
</ul>
<h3 id="图数据库特性"><a class="markdownIt-Anchor" href="#图数据库特性"></a> 图数据库特性</h3>
<p>以 Neo4j 为例：</p>
<p>Neo4j 使用数据结构中图（graph）的概念来进行建模。 Neo4j 中两个最基本的概念是节点和边。节点表示实体，边则表示实体之间的关系。节点和边都可以有自己的属性。不同实体通过各种不同的关系关联起来，形成复杂的对象图。</p>
<p>针对关系数据，2 种 2 数据库的存储结构不同：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/10/165234a2b2cebaf8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="2种存储结构" /></p>
<p>Neo4j 中，存储节点时使用了”index-free adjacency”，即每个节点都有指向其邻居节点的指针，可以让我们在 O(1)的时间内找到邻居节点。另外，按照官方的说法，在 Neo4j 中边是最重要的,是”first-class entities”，所以单独存储，这有利于在图遍历的时候提高速度，也可以很方便地以任何方向进行遍历</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/10/165234a2b3a0f7b7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" /></p>
<p>如下优点：</p>
<ul>
<li><strong>高性能</strong> - 图的遍历是图数据结构所具有的独特算法，即从一个节点开始，根据其连接的关系，可以快速和方便地找出它的邻近节点。这种查找数据的方法并不受数据量的大小所影响，因为邻近查询始终查找的是有限的局部数据，不会对整个数据库进行搜索</li>
<li><strong>设计的灵活性</strong> - 数据结构的自然伸展特性及其非结构化的数据格式，让图数据库设计可以具有很大的伸缩性和灵活性。因为随着需求的变化而增加的节点、关系及其属性并不会影响到原来数据的正常使用</li>
<li><strong>开发的敏捷性</strong> - 直观明了的数据模型，从需求的讨论开始，到程序开发和实现，以及最终保存在数据库中的样子，它的模样似乎没有什么变化，甚至可以说本来就是一模一样的</li>
<li><strong>完全支持 ACID</strong> - 不像别的 NoSQL 数据库 Neo4j 还具有完全事务管理特性，完全支持 ACID 事务管理</li>
</ul>
<p>缺点如下：</p>
<ul>
<li>存在支持节点，关系和属性的数量的限制。</li>
<li>不支持拆分。</li>
</ul>
<h3 id="图数据库场景"><a class="markdownIt-Anchor" href="#图数据库场景"></a> 图数据库场景</h3>
<p>适用场景如下：</p>
<ul>
<li>关系性强的数据中，如社交网络</li>
<li>推荐引擎。如果我们将数据以图的形式表现，那么将会非常有益于推荐的制定</li>
</ul>
<p>不适用场景如下：</p>
<ul>
<li>记录大量基于事件的数据（例如日志条目或传感器数据）</li>
<li>对大规模分布式数据进行处理</li>
<li>保存在关系型数据库中的结构化数据</li>
<li>二进制数据存储</li>
</ul>
<h2 id="七-总结"><a class="markdownIt-Anchor" href="#七-总结"></a> 七、总结</h2>
<p>关系型数据库和 NoSQL 数据库的选型，往往需要考虑几个指标：</p>
<ul>
<li>数据量</li>
<li>并发量</li>
<li>实时性</li>
<li>一致性要求</li>
<li>读写分布和类型</li>
<li>安全性</li>
<li>运维成本</li>
</ul>
<p>常见软件系统数据库选型参考如下：</p>
<ul>
<li><strong>中后台管理型系统</strong> - 如运营系统，数据量少，并发量小，首选关系型数据库。</li>
<li><strong>大流量系统</strong> - 如电商单品页，后台考虑选关系型数据库，前台考虑选内存型数据库。</li>
<li><strong>日志型系统</strong> - 原始数据考虑选列式数据库，日志搜索考虑选搜索引擎。</li>
<li><strong>搜索型系统</strong> - 例如站内搜索，非通用搜索，如商品搜索，后台考虑选关系型数据库，前台考虑选搜索引擎。</li>
<li><strong>事务型系统</strong> - 如库存，交易，记账，考虑选关系型数据库+K-V 数据库（作为缓存）+分布式事务。</li>
<li><strong>离线计算</strong> - 如大量数据分析，考虑选列式数据库或关系型数据。</li>
<li><strong>实时计算</strong> - 如实时监控，可以考虑选内存型数据库或者列式数据库。</li>
</ul>
<p>设计实践中，要基于需求、业务驱动架构，无论选用 RDB/NoSQL/DRDB,<strong>一定是以需求为导向，最终数据存储方案必然是各种权衡的综合性设计</strong></p>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><a href="https://juejin.im/post/5b6d62ddf265da0f491bd200" target="_blank" rel="noopener">NoSQL 还是 SQL ？这一篇讲清楚</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/2020/02/02/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%85%B1%E8%AF%86%E6%80%A7%E7%AE%97%E6%B3%95-paxos/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2020/02/02/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%85%B1%E8%AF%86%E6%80%A7%E7%AE%97%E6%B3%95-paxos/" class="post-title-link" itemprop="url">深入剖析共识性算法 Paxos</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-02 22:00:00" itemprop="dateCreated datePublished" datetime="2020-02-02T22:00:00+08:00">2020-02-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-14 16:45:53" itemprop="dateModified" datetime="2022-04-14T16:45:53+08:00">2022-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">分布式理论</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2020/02/02/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%85%B1%E8%AF%86%E6%80%A7%E7%AE%97%E6%B3%95-paxos/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/02/02/深入剖析共识性算法-paxos/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="深入剖析共识性算法-paxos"><a class="markdownIt-Anchor" href="#深入剖析共识性算法-paxos"></a> 深入剖析共识性算法 Paxos</h1>
<blockquote>
<p>Paxos 是一种基于消息传递且具有容错性的共识性（consensus）算法。</p>
<p>Paxos 算法解决的问题正是分布式一致性问题。在一个节点数为 2N+1 的分布式集群中，只要半数以上的节点（N + 1）还正常工作，整个系统仍可以正常工作。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200202221611.png" alt="img" /></p>
<h2 id="1-paxos-背景"><a class="markdownIt-Anchor" href="#1-paxos-背景"></a> 1. Paxos 背景</h2>
<p>Paxos 是 Leslie Lamport 于 1990 年提出的一种基于消息传递且具有高度容错特性的共识（consensus）算法。</p>
<p>为描述 Paxos 算法，Lamport 虚拟了一个叫做 Paxos 的希腊城邦，这个岛按照议会民主制的政治模式制订法律，但是没有人愿意将自己的全部时间和精力放在这种事情上。所以无论是议员，议长或者传递纸条的服务员都不能承诺别人需要时一定会出现，也无法承诺批准决议或者传递消息的时间。</p>
<p>Paxos 算法包含 2 个部分：</p>
<ul>
<li>Basic Paxos 算法：描述的多节点之间如何就某个值达成共识。</li>
<li>Multi Paxos 思想：描述的是执行多个 Basic Paxos 实例，就一系列值达成共识。</li>
</ul>
<p>Paxos 算法解决的问题正是分布式一致性问题，即一个分布式系统中的各个进程如何就某个值（决议）达成一致。</p>
<p>Paxos 算法运行在允许宕机故障的异步系统中，不要求可靠的消息传递，可容忍消息丢失、延迟、乱序以及重复。它利用大多数 (Majority) 机制保证了 2N+1 的容错能力，即 2N+1 个节点的系统最多允许 N 个节点同时出现故障。</p>
<h2 id="2-basic-paxos-算法"><a class="markdownIt-Anchor" href="#2-basic-paxos-算法"></a> 2. Basic Paxos 算法</h2>
<h3 id="21-角色"><a class="markdownIt-Anchor" href="#21-角色"></a> 2.1. 角色</h3>
<p>Paxos 将分布式系统中的节点分为以下角色：</p>
<ul>
<li><strong>提议者（Proposer）</strong>：发出提案（Proposal）。Proposal 信息包括提案编号 (Proposal ID) 和提议的值 (Value)。</li>
<li><strong>决策者（Acceptor）</strong>：对每个 Proposal 进行投票，若 Proposal 获得多数 Acceptor 的接受，则称该 Proposal 被批准。</li>
<li><strong>学习者（Learner）</strong>：不参与决策，从 Proposers/Acceptors 学习、记录最新达成共识的提案（Value）。</li>
</ul>
<p>在多副本状态机中，每个副本都同时具有 Proposer、Acceptor、Learner 三种角色。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20210528150700.png" alt="img" /></p>
<h3 id="22-算法"><a class="markdownIt-Anchor" href="#22-算法"></a> 2.2. 算法</h3>
<p>Paxos 算法通过一个决议分为两个阶段（Learn 阶段之前决议已经形成）：</p>
<ol>
<li>第一阶段：Prepare 阶段。Proposer 向 Acceptors 发出 Prepare 请求，Acceptors 针对收到的 Prepare 请求进行 Promise 承诺。</li>
<li>第二阶段：Accept 阶段。Proposer 收到多数 Acceptors 承诺的 Promise 后，向 Acceptors 发出 Propose 请求，Acceptors 针对收到的 Propose 请求进行 Accept 处理。</li>
<li>第三阶段：Learn 阶段。Proposer 在收到多数 Acceptors 的 Accept 之后，标志着本次 Accept 成功，决议形成，将形成的决议发送给所有 Learners。</li>
</ol>
<p>Paxos 算法流程中的每条消息描述如下：</p>
<ul>
<li>
<p><strong>Prepare</strong>: Proposer 生成全局唯一且递增的 Proposal ID (可使用时间戳加 Server ID)，向所有 Acceptors 发送 Prepare 请求，这里无需携带提案内容，只携带 Proposal ID 即可。</p>
</li>
<li>
<p><strong>Promise</strong>: Acceptors 收到 Prepare 请求后，做出“两个承诺，一个应答”。</p>
<ul>
<li>
<p>两个承诺：</p>
<ul>
<li>不再接受 Proposal ID 小于等于当前请求的 Prepare 请求。</li>
<li>不再接受 Proposal ID 小于当前请求的 Propose 请求。</li>
</ul>
</li>
<li>
<p>一个应答：</p>
<ul>
<li>不违背以前作出的承诺下，回复已经 Accept 过的提案中 Proposal ID 最大的那个提案的 Value 和 Proposal ID，没有则返回空值。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Propose</strong>: Proposer 收到多数 Acceptors 的 Promise 应答后，从应答中选择 Proposal ID 最大的提案的 Value，作为本次要发起的提案。如果所有应答的提案 Value 均为空值，则可以自己随意决定提案 Value。然后携带当前 Proposal ID，向所有 Acceptors 发送 Propose 请求。</p>
</li>
<li>
<p><strong>Accept</strong>: Acceptor 收到 Propose 请求后，在不违背自己之前作出的承诺下，接受并持久化当前 Proposal ID 和提案 Value。</p>
</li>
<li>
<p><strong>Learn</strong>: Proposer 收到多数 Acceptors 的 Accept 后，决议形成，将形成的决议发送给所有 Learners。</p>
</li>
</ul>
<h3 id="23-实例"><a class="markdownIt-Anchor" href="#23-实例"></a> 2.3. 实例</h3>
<p>下面举几个例子，实例 1 如下图：</p>
<p><img src="https://pic1.zhimg.com/80/v2-ac7e4a827f77dc57d316c77ae95e1940_hd.jpg" alt="img" /></p>
<p>图中 P 代表 Prepare 阶段，A 代表 Accept 阶段。3.1 代表 Proposal ID 为 3.1，其中 3 为时间戳，1 为 Server ID。X 和 Y 代表提议 Value。</p>
<p>实例 1 中 P 3.1 达成多数派，其 Value(X) 被 Accept，然后 P 4.5 学习到 Value(X)，并 Accept。</p>
<h4 id="img"><a class="markdownIt-Anchor" href="#img"></a> <img src="https://pic2.zhimg.com/80/v2-3ae48cb81d39079022666ccb35821c71_hd.jpg" alt="img" /></h4>
<p>实例 2 中 P 3.1 没有被多数派 Accept（只有 S3 Accept），但是被 P 4.5 学习到，P 4.5 将自己的 Value 由 Y 替换为 X，Accept（X）。</p>
<p><img src="https://pic2.zhimg.com/80/v2-931f9487900f0f002867c9e116dec255_hd.jpg" alt="img" />Paxos 算法实例 3</p>
<p>实例 3 中 P 3.1 没有被多数派 Accept（只有 S1 Accept），同时也没有被 P 4.5 学习到。由于 P 4.5 Propose 的所有应答，均未返回 Value，则 P 4.5 可以 Accept 自己的 Value (Y)。后续 P 3.1 的 Accept (X) 会失败，已经 Accept 的 S1，会被覆盖。</p>
<p>Paxos 算法可能形成活锁而永远不会结束，如下图实例所示：</p>
<p><img src="https://pic1.zhimg.com/80/v2-0e18b29659367076ff1c0156ae46eca0_hd.jpg" alt="img" />Paxos 算法形成活锁</p>
<p>回顾两个承诺之一，Acceptor 不再应答 Proposal ID 小于等于当前请求的 Prepare 请求。意味着需要应答 Proposal ID 大于当前请求的 Prepare 请求。</p>
<p>两个 Proposers 交替 Prepare 成功，而 Accept 失败，形成活锁（Livelock）。</p>
<h2 id="3-multi-paxos-思想"><a class="markdownIt-Anchor" href="#3-multi-paxos-思想"></a> 3. Multi Paxos 思想</h2>
<h3 id="31-basic-paxos-的问题"><a class="markdownIt-Anchor" href="#31-basic-paxos-的问题"></a> 3.1. Basic Paxos 的问题</h3>
<p>Basic Paxos 有以下问题，导致它不能应用于实际：</p>
<ul>
<li><strong>Basic Paxos 算法只能对一个值形成决议</strong>。</li>
<li><strong>Basic Paxos 算法会消耗大量网络带宽</strong>。Basic Paxos 中，决议的形成至少需要两次网络通信，在高并发情况下可能需要更多的网络通信，极端情况下甚至可能形成活锁。如果想连续确定多个值，Basic Paxos 搞不定了。</li>
</ul>
<h3 id="32-multi-paxos-的改进"><a class="markdownIt-Anchor" href="#32-multi-paxos-的改进"></a> 3.2. Multi Paxos 的改进</h3>
<p>Multi Paxos 正是为解决以上问题而提出。Multi Paxos 基于 Basic Paxos 做了两点改进：</p>
<ul>
<li>针对每一个要确定的值，运行一次 Paxos 算法实例（Instance），形成决议。每一个 Paxos 实例使用唯一的 Instance ID 标识。</li>
<li>在所有 Proposer 中选举一个 Leader，由 Leader 唯一地提交 Proposal 给 Acceptor 进行表决。这样没有 Proposer 竞争，解决了活锁问题。在系统中仅有一个 Leader 进行 Value 提交的情况下，Prepare 阶段就可以跳过，从而将两阶段变为一阶段，提高效率。</li>
</ul>
<p>Multi Paxos 首先需要选举 Leader，Leader 的确定也是一次决议的形成，所以可执行一次 Basic Paxos 实例来选举出一个 Leader。选出 Leader 之后只能由 Leader 提交 Proposal，在 Leader 宕机之后服务临时不可用，需要重新选举 Leader 继续服务。在系统中仅有一个 Leader 进行 Proposal 提交的情况下，Prepare 阶段可以跳过。</p>
<p>Multi Paxos 通过改变 Prepare 阶段的作用范围至后面 Leader 提交的所有实例，从而使得 Leader 的连续提交只需要执行一次 Prepare 阶段，后续只需要执行 Accept 阶段，将两阶段变为一阶段，提高了效率。为了区分连续提交的多个实例，每个实例使用一个 Instance ID 标识，Instance ID 由 Leader 本地递增生成即可。</p>
<p>Multi Paxos 允许有多个自认为是 Leader 的节点并发提交 Proposal 而不影响其安全性，这样的场景即退化为 Basic Paxos。</p>
<p>Chubby 和 Boxwood 均使用 Multi Paxos。ZooKeeper 使用的 Zab 也是 Multi Paxos 的变形。</p>
<h2 id="4-总结"><a class="markdownIt-Anchor" href="#4-总结"></a> 4. 总结</h2>
<p>你可以看到，Basic Paxos 是通过二阶段提交的方式来达成共识的。二阶段提交是达成共识的常用方式，如果你需要设计新的共识算法的时候，也可以考虑这个方式。</p>
<p>除了共识，Basic Paxos 还实现了容错，在少于一半的节点出现故障时，集群也能工作。它不像分布式事务算法那样，必须要所有节点都同意后才提交操作，因为“所有节点都同意”这个原则，在出现节点故障的时候会导致整个集群不可用。也就是说，“大多数节点都同意”的原则，赋予了 Basic Paxos 容错的能力，让它能够容忍少于一半的节点的故障。</p>
<h2 id="5-参考资料"><a class="markdownIt-Anchor" href="#5-参考资料"></a> 5. 参考资料</h2>
<ul>
<li><a href="https://research.microsoft.com/en-us/um/people/lamport/pubs/lamport-paxos.pdf" target="_blank" rel="noopener">Part-time Parliament 论文</a></li>
<li><a href="https://lamport.azurewebsites.net/pubs/paxos-simple.pdf" target="_blank" rel="noopener">Paxos Made Simple 论文</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/31780743" target="_blank" rel="noopener">Paxos 算法详解</a></li>
<li><a href="https://zh.wikipedia.org/w/index.php?title=Paxos%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">Wiki - Paxos 算法</a></li>
<li><a href="https://www.bilibili.com/video/BV1TW411M7Fx?from=search&amp;seid=11524608198747599965" target="_blank" rel="noopener">一致性算法（Paxos、Raft、Zab）</a></li>
<li><a href="https://www.bilibili.com/video/av36556594" target="_blank" rel="noopener">Raft 作者讲解 Paxos 视频</a></li>
<li><a href="https://www.youtube.com/watch?v=d7nAGI_NZPk" target="_blank" rel="noopener">Paxos 算法讲解视频</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/2020/02/01/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%85%B1%E8%AF%86%E6%80%A7%E7%AE%97%E6%B3%95-raft/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2020/02/01/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%85%B1%E8%AF%86%E6%80%A7%E7%AE%97%E6%B3%95-raft/" class="post-title-link" itemprop="url">深入剖析共识性算法 Raft</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-01 22:07:00" itemprop="dateCreated datePublished" datetime="2020-02-01T22:07:00+08:00">2020-02-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-14 16:45:53" itemprop="dateModified" datetime="2022-04-14T16:45:53+08:00">2022-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">分布式理论</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2020/02/01/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%85%B1%E8%AF%86%E6%80%A7%E7%AE%97%E6%B3%95-raft/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/02/01/深入剖析共识性算法-raft/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="深入剖析共识性算法-raft"><a class="markdownIt-Anchor" href="#深入剖析共识性算法-raft"></a> 深入剖析共识性算法 Raft</h1>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200201221202.png" alt="img" /></p>
<h2 id="1-raft-简介"><a class="markdownIt-Anchor" href="#1-raft-简介"></a> 1. Raft 简介</h2>
<p><strong><a href="https://ramcloud.atlassian.net/wiki/download/attachments/6586375/raft.pdf" target="_blank" rel="noopener">Raft</a> 是一种为了管理日志复制的分布式一致性算法</strong>。</p>
<p><a href="https://ramcloud.atlassian.net/wiki/download/attachments/6586375/raft.pdf" target="_blank" rel="noopener">Raft</a> 出现之前，Paxos 一直是分布式一致性算法的标准。Paxos <strong>难以理解，更难以实现</strong>。Raft 的设计目标是简化 Paxos，使得算法<strong>既容易理解，也容易实现</strong>。</p>
<p>Paxos 和 Raft 都是分布式一致性算法，这个过程如同投票选举领袖（Leader），参选者（Candidate）需要说服大多数投票者（Follower）投票给他，一旦选举出领袖，就由领袖发号施令。Paxos 和 Raft 的区别在于选举的具体过程不同。</p>
<p><strong>Raft 可以解决分布式 CAP 理论中的 CP</strong>，即 <em>一致性（C：Consistency）</em> 和 <em>分区容忍性（P：Partition Tolerance）</em>，并不能解决 <em>可用性（A：Availability）</em> 的问题。</p>
<h3 id="11-分布式一致性"><a class="markdownIt-Anchor" href="#11-分布式一致性"></a> 1.1. 分布式一致性</h3>
<p>分布式一致性 (distributed consensus) 是分布式系统中最基本的问题，用来保证一个分布式系统的可靠性以及容错能力。简单来说，<strong><em>分布式一致性是指多个服务器的保持状态一致</em></strong>。</p>
<p>在分布式系统中，可能出现各种意外（断电、网络拥塞、CPU/内存耗尽等等），使得服务器宕机或无法访问，最终导致无法和其他服务器保持状态一致。为了应对这种情况，就需要有一种一致性协议来进行容错，使得分布式系统中即使有部分服务器宕机或无法访问，整体依然可以对外提供服务。</p>
<p>以容错方式达成一致，自然不能要求所有服务器都达成一致状态，只要<strong>超过半数以上</strong>的服务器达成一致就可以了。假设有 N 台服务器， 大于等于 <code>N/2 + 1</code> 台服务器就算是半数以上了 。</p>
<h3 id="12-复制状态机"><a class="markdownIt-Anchor" href="#12-复制状态机"></a> 1.2. 复制状态机</h3>
<p><strong><code>复制状态机（Replicated State Machines）</code></strong> 是指一组服务器上的状态机产生相同状态的副本，并且在一些机器宕掉的情况下也可以继续运行。一致性算法管理着来自客户端指令的复制日志。状态机从日志中处理相同顺序的相同指令，所以产生的结果也是相同的。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200131233906.png" alt="img" /></p>
<p>复制状态机通常都是基于复制日志实现的，如上图。每一个服务器存储一个包含一系列指令的日志，并且按照日志的顺序进行执行。每一个日志都按照相同的顺序包含相同的指令，所以每一个服务器都执行相同的指令序列。因为每个状态机都是确定的，每一次执行操作都产生相同的状态和同样的序列。</p>
<p>保证复制日志相同就是一致性算法的工作了。在一台服务器上，一致性模块接收客户端发送来的指令然后增加到自己的日志中去。它和其他服务器上的一致性模块进行通信来保证每一个服务器上的日志最终都以相同的顺序包含相同的请求，尽管有些服务器会宕机。一旦指令被正确的复制，每一个服务器的状态机按照日志顺序处理他们，然后输出结果被返回给客户端。因此，服务器集群看起来形成一个高可靠的状态机。</p>
<p>实际系统中使用的一致性算法通常含有以下特性：</p>
<ul>
<li><strong>安全性保证</strong>（绝对不会返回一个错误的结果）：在非拜占庭错误情况下，包括网络延迟、分区、丢包、冗余和乱序等错误都可以保证正确。</li>
<li><strong>可用性</strong>：集群中只要有大多数的机器可运行并且能够相互通信、和客户端通信，就可以保证可用。因此，一个典型的包含 5 个节点的集群可以容忍两个节点的失败。服务器被停止就认为是失败。他们当有稳定的存储的时候可以从状态中恢复回来并重新加入集群。</li>
<li><strong>不依赖时序来保证一致性</strong>：物理时钟错误或者极端的消息延迟只有在最坏情况下才会导致可用性问题。</li>
<li>通常情况下，一条指令可以尽可能快的在集群中大多数节点响应一轮远程过程调用时完成。小部分比较慢的节点不会影响系统整体的性能。</li>
</ul>
<h3 id="13-raft-应用"><a class="markdownIt-Anchor" href="#13-raft-应用"></a> 1.3. RAFT 应用</h3>
<p>RAFT 可以做什么？</p>
<p>通过 RAFT 提供的复制状态机，可以解决分布式系统的复制、修复、节点管理等问题。Raft 极大的简化当前分布式系统的设计与实现，让开发者只关注于业务逻辑，将其抽象实现成对应的状态机即可。基于这套框架，可以构建很多分布式应用：</p>
<ul>
<li>分布式锁服务，比如 Zookeeper</li>
<li>分布式存储系统，比如分布式消息队列、分布式块系统、分布式文件系统、分布式表格系统等</li>
<li>高可靠元信息管理，比如各类 Master 模块的 HA</li>
</ul>
<h2 id="2-raft-基础"><a class="markdownIt-Anchor" href="#2-raft-基础"></a> 2. Raft 基础</h2>
<p>Raft 将一致性问题分解成了三个子问题：</p>
<ul>
<li><strong>选举 Leader</strong></li>
<li><strong>日志复制</strong></li>
<li><strong>安全性</strong></li>
</ul>
<p>在后续章节，会详细讲解这个子问题。现在，先了解一下 Raft 的一些核心概念。</p>
<h3 id="21-服务器角色"><a class="markdownIt-Anchor" href="#21-服务器角色"></a> 2.1. 服务器角色</h3>
<p>在 Raft 中，任何时刻，每个服务器都处于这三个角色之一 ：</p>
<ul>
<li><strong><code>Leader</code></strong> - 领导者，通常一个系统中是<strong>一主（Leader）多从（Follower）</strong>。Leader <strong>负责处理所有的客户端请求</strong>。</li>
<li><strong><code>Follower</code></strong> - 跟随者，<strong>不会发送任何请求</strong>，只是简单的 <strong>响应来自 Leader 或者 Candidate 的请求</strong>。</li>
<li><strong><code>Candidate</code></strong> - 参选者，选举新 Leader 时的临时角色。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200131215742.png" alt="img" /></p>
<blockquote>
<p>💡 图示说明：</p>
<ul>
<li>Follower 只响应来自其他服务器的请求。在一定时限内，如果 Follower 接收不到消息，就会转变成 Candidate，并发起选举。</li>
<li>Candidate 向 Follower 发起投票请求，如果获得集群中半数以上的选票，就会转变为 Leader。</li>
<li>在一个 Term 内，Leader 始终保持不变，直到下线了。Leader 需要周期性向所有 Follower 发送心跳消息，以阻止 Follower 转变为 Candidate。</li>
</ul>
</blockquote>
<h3 id="22-任期"><a class="markdownIt-Anchor" href="#22-任期"></a> 2.2. 任期</h3>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200131220742.png" alt="img" /></p>
<p>Raft 把时间分割成任意长度的 <strong><em><code>任期（Term）</code></em></strong>，任期用连续的整数标记。每一段任期从一次<strong>选举</strong>开始。<strong>Raft 保证了在一个给定的任期内，最多只有一个领导者</strong>。</p>
<ul>
<li>如果选举成功，Leader 会管理整个集群直到任期结束。</li>
<li>如果选举失败，那么这个任期就会因为没有 Leader 而结束。</li>
</ul>
<p><strong>不同服务器节点观察到的任期转换状态可能不一样</strong>：</p>
<ul>
<li>服务器节点可能观察到多次的任期转换。</li>
<li>服务器节点也可能观察不到任何一次任期转换。</li>
</ul>
<p><strong>任期在 Raft 算法中充当逻辑时钟的作用，使得服务器节点可以查明一些过期的信息（比如过期的 Leader）。每个服务器节点都会存储一个当前任期号，这一编号在整个时期内单调的增长。当服务器之间通信的时候会交换当前任期号。</strong></p>
<ul>
<li>如果一个服务器的当前任期号比其他人小，那么他会更新自己的编号到较大的编号值。</li>
<li>如果一个 Candidate 或者 Leader 发现自己的任期号过期了，那么他会立即恢复成跟随者状态。</li>
<li>如果一个节点接收到一个包含过期的任期号的请求，那么他会直接拒绝这个请求。</li>
</ul>
<h3 id="23-rpc"><a class="markdownIt-Anchor" href="#23-rpc"></a> 2.3. RPC</h3>
<p>Raft 算法中服务器节点之间的通信使用 <strong><em><code>远程过程调用（RPC）</code></em></strong>。</p>
<p>基本的一致性算法只需要两种 RPC：</p>
<ul>
<li><strong><code>RequestVote RPC</code></strong> - 请求投票 RPC，由 Candidate 在选举期间发起。</li>
<li><strong><code>AppendEntries RPC</code></strong> - 附加条目 RPC，由 Leader 发起，用来复制日志和提供一种心跳机制。</li>
</ul>
<h2 id="3-选举-leader"><a class="markdownIt-Anchor" href="#3-选举-leader"></a> 3. 选举 Leader</h2>
<h3 id="31-选举规则"><a class="markdownIt-Anchor" href="#31-选举规则"></a> 3.1. 选举规则</h3>
<p><strong>Raft 使用一种心跳机制来触发 Leader 选举</strong>。</p>
<p><strong>Leader 需要周期性的向所有 Follower 发送心跳消息</strong>，以此维持自己的权威并阻止新 Leader 的产生。</p>
<p>每个 Follower 都设置了一个<strong>随机的竞选超时时间</strong>，一般为 <code>150ms ~ 300ms</code>，如果在竞选超时时间内没有收到 Leader 的心跳消息，就会认为当前 Term 没有可用的 Leader，并发起选举来选出新的 Leader。开始一次选举过程，Follower 先要增加自己的当前 Term 号，并<strong>转换为 Candidate</strong>。</p>
<p>Candidate 会并行的<strong>向集群中的所有服务器节点发送投票请求（<code>RequestVote RPC</code>）</strong>，它会保持当前状态直到以下三件事情之一发生：</p>
<ul>
<li><strong>自己成为 Leader</strong></li>
<li><strong>其他的服务器成为 Leader</strong></li>
<li><strong>没有任何服务器成为 Leader</strong></li>
</ul>
<h4 id="自己成为-leader"><a class="markdownIt-Anchor" href="#自己成为-leader"></a> 自己成为 Leader</h4>
<ul>
<li>当一个 Candidate 从整个集群<strong>半数以上</strong>的服务器节点获得了针对同一个 Term 的选票，那么它就赢得了这次选举并成为 Leader。每个服务器最多会对一个 Term 投出一张选票，按照先来先服务（FIFO）的原则。<em>要求半数以上选票的规则确保了最多只会有一个 Candidate 赢得此次选举</em>。</li>
<li>一旦 Candidate 赢得选举，就立即成为 Leader。然后它会向其他的服务器发送心跳消息来建立自己的权威并且阻止新的领导人的产生。</li>
</ul>
<h4 id="其他的服务器成为-leader"><a class="markdownIt-Anchor" href="#其他的服务器成为-leader"></a> 其他的服务器成为 Leader</h4>
<p>等待投票期间，Candidate 可能会从其他的服务器接收到声明它是 Leader 的 <code>AppendEntries RPC</code>。</p>
<ul>
<li>如果这个 Leader 的 Term 号（包含在此次的 RPC 中）不小于 Candidate 当前的 Term，那么 Candidate 会承认 Leader 合法并回到 Follower 状态。</li>
<li>如果此次 RPC 中的 Term 号比自己小，那么 Candidate 就会拒绝这个消息并继续保持 Candidate 状态。</li>
</ul>
<h4 id="没有任何服务器成为-leader"><a class="markdownIt-Anchor" href="#没有任何服务器成为-leader"></a> 没有任何服务器成为 Leader</h4>
<p>如果有多个 Follower 同时成为 Candidate，那么选票可能会被瓜分以至于没有 Candidate 可以赢得半数以上的投票。当这种情况发生的时候，每一个 Candidate 都会竞选超时，然后通过增加当前 Term 号来开始一轮新的选举。然而，没有其他机制的话，选票可能会被无限的重复瓜分。</p>
<p>Raft 算法使用随机选举超时时间的方法来确保很少会发生选票瓜分的情况，就算发生也能很快的解决。为了阻止选票起初就被瓜分，竞选超时时间是一个<strong>随机的时间</strong>，在一个固定的区间（例如 150-300 毫秒）随机选择，这样可以把选举都分散开。</p>
<ul>
<li>以至于在大多数情况下，只有一个服务器会超时，然后它赢得选举，成为 Leader，并在其他服务器超时之前发送心跳包。</li>
<li>同样的机制也被用在选票瓜分的情况下：每一个 Candidate 在开始一次选举的时候会重置一个随机的选举超时时间，然后在超时时间内等待投票的结果；这样减少了在新的选举中另外的选票瓜分的可能性。</li>
</ul>
<hr />
<p>理解了上面的选举规则后，我们通过动图来加深认识。</p>
<h3 id="32-单-candidate-选举"><a class="markdownIt-Anchor" href="#32-单-candidate-选举"></a> 3.2. 单 Candidate 选举</h3>
<p>（1）下图表示一个分布式系统的最初阶段，此时只有 Follower，没有 Leader。Follower A 等待一个随机的选举超时时间之后，没收到 Leader 发来的心跳消息。因此，将 Term 由 0 增加为 1，转换为 Candidate，进入选举状态。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/architecture/raft-candidate-01.gif" alt="img" /></p>
<p>（2）此时，A 向所有其他节点发送投票请求。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/architecture/raft-candidate-02.gif" alt="img" /></p>
<p>（3）其它节点会对投票请求进行回复，如果超过半数以上的节点投票了，那么该 Candidate 就会立即变成 Term 为 1 的 Leader。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/architecture/raft-candidate-03.gif" alt="img" /></p>
<p>（4）Leader 会周期性地发送心跳消息给所有 Follower，Follower 接收到心跳包，会重新开始计时。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/architecture/raft-candidate-04.gif" alt="img" /></p>
<h3 id="33-多-candidate-选举"><a class="markdownIt-Anchor" href="#33-多-candidate-选举"></a> 3.3. 多 Candidate 选举</h3>
<p>（1）如果有多个 Follower 成为 Candidate，并且所获得票数相同，那么就需要重新开始投票。例如下图中 Candidate B 和 Candidate D 都发起 Term 为 4 的选举，且都获得两票，因此需要重新开始投票。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/architecture/raft-multi-candidate-01.gif" alt="img" /></p>
<p>（2）当重新开始投票时，由于每个节点设置的随机竞选超时时间不同，因此能下一次再次出现多个 Candidate 并获得同样票数的概率很低。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/architecture/raft-multi-candidate-02.gif" alt="img" /></p>
<h2 id="4-日志复制"><a class="markdownIt-Anchor" href="#4-日志复制"></a> 4. 日志复制</h2>
<h3 id="41-日志格式"><a class="markdownIt-Anchor" href="#41-日志格式"></a> 4.1. 日志格式</h3>
<p><strong>日志由含日志索引（log index）的日志条目（log entry）组成</strong>。每个日志条目包含它被创建时的 Term 号（下图中方框中的数字），和一个复制状态机需要执行的指令。如果一个日志条目被复制到半数以上的服务器上，就被认为可以提交（Commit）了。</p>
<ul>
<li>日志条目中的 Term 号被用来检查是否出现不一致的情况。</li>
<li>日志条目中的日志索引（一个整数值）用来表明它在日志中的位置。</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-ee29a89e4eb63468e142bb6103dbe4de_hd.jpg" alt="img" /></p>
<p>Raft 日志同步保证如下两点：</p>
<ul>
<li>如果不同日志中的两个日志条目有着相同的日志索引和 Term，则<strong>它们所存储的命令是相同的</strong>。
<ul>
<li>这个特性基于这条原则：Leader 最多在一个 Term 内、在指定的一个日志索引上创建一条日志条目，同时日志条目在日志中的位置也从来不会改变。</li>
</ul>
</li>
<li>如果不同日志中的两个日志条目有着相同的日志索引和 Term，则<strong>它们之前的所有条目都是完全一样的</strong>。
<ul>
<li>这个特性由 <code>AppendEntries RPC</code> 的一个简单的一致性检查所保证。在发送 <code>AppendEntries RPC</code> 时，Leader 会把新日志条目之前的日志条目的日志索引和 Term 号一起发送。如果 Follower 在它的日志中找不到包含相同日志索引和 Term 号的日志条目，它就会拒绝接收新的日志条目。</li>
</ul>
</li>
</ul>
<h3 id="42-日志复制流程"><a class="markdownIt-Anchor" href="#42-日志复制流程"></a> 4.2. 日志复制流程</h3>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200201115848.png" alt="img" /></p>
<ol>
<li>Leader 负责处理所有客户端的请求。</li>
<li>Leader 把请求作为日志条目加入到它的日志中，然后并行的向其他服务器发送 <code>AppendEntries RPC</code> 请求，要求 Follower 复制日志条目。</li>
<li>Follower 复制成功后，返回确认消息。</li>
<li>当这个日志条目被半数以上的服务器复制后，Leader 提交这个日志条目到它的复制状态机，并向客户端返回执行结果。</li>
</ol>
<blockquote>
<p>注意：如果 Follower 崩溃或者运行缓慢，再或者网络丢包，Leader 会不断的重复尝试发送 <code>AppendEntries RPC</code> 请求 （尽管已经回复了客户端），直到所有的跟随者都最终复制了所有的日志条目。</p>
</blockquote>
<p>下面，通过一组动图来加深认识：</p>
<p>（1）来自客户端的修改都会被传入 Leader。注意该修改还未被提交，只是写入日志中。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/architecture/raft-sync-log-01.gif" alt="img" /></p>
<p>（2）Leader 会把修改复制到所有 Follower。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/architecture/raft-sync-log-02.gif" alt="img" /></p>
<p>（3）Leader 会等待大多数的 Follower 也进行了修改，然后才将修改提交。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/architecture/raft-sync-log-03.gif" alt="img" /></p>
<p>（4）此时 Leader 会通知的所有 Follower 让它们也提交修改，此时所有节点的值达成一致。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/architecture/raft-sync-log-04.gif" alt="img" /></p>
<h3 id="43-日志一致性"><a class="markdownIt-Anchor" href="#43-日志一致性"></a> 4.3. 日志一致性</h3>
<p>一般情况下，Leader 和 Followers 的日志保持一致，因此日志条目一致性检查通常不会失败。然而，Leader 崩溃可能会导致日志不一致：旧的 Leader 可能没有完全复制完日志中的所有条目。</p>
<h4 id="leader-和-follower-日志不一致的可能"><a class="markdownIt-Anchor" href="#leader-和-follower-日志不一致的可能"></a> Leader 和 Follower 日志不一致的可能</h4>
<p>Leader 和 Follower 可能存在多种日志不一致的可能。</p>
<p><img src="https://pic4.zhimg.com/80/v2-d36c587901391cae50788061f568d24f_hd.jpg" alt="img" /></p>
<blockquote>
<p>💡 图示说明：</p>
<p>上图阐述了 Leader 和 Follower 可能存在多种日志不一致的可能，每一个方框表示一个日志条目，里面的数字表示任期号 。</p>
<p>当一个 Leader 成功当选时，Follower 可能出现以下情况（a-f）：</p>
<ul>
<li><strong>存在未更新日志条目</strong>，如（a、b）。</li>
<li><strong>存在未提交日志条目</strong>，如（c、d）。</li>
<li>或<strong>两种情况都存在</strong>，如（e、f）。</li>
</ul>
<p><em>例如，场景 f 可能会这样发生，某服务器在 Term2 的时候是 Leader，已附加了一些日志条目到自己的日志中，但在提交之前就崩溃了；很快这个机器就被重启了，在 Term3 重新被选为 Leader，并且又增加了一些日志条目到自己的日志中；在 Term 2 和 Term 3 的日志被提交之前，这个服务器又宕机了，并且在接下来的几个任期里一直处于宕机状态</em>。</p>
</blockquote>
<h4 id="leader-和-follower-日志一致的保证"><a class="markdownIt-Anchor" href="#leader-和-follower-日志一致的保证"></a> Leader 和 Follower 日志一致的保证</h4>
<p>Leader 通过强制 Followers 复制它的日志来处理日志的不一致，<strong>Followers 上的不一致的日志会被 Leader 的日志覆盖</strong>。</p>
<ul>
<li>Leader 为了使 Followers 的日志同自己的一致，Leader 需要找到 Followers 同它的日志一致的地方，然后覆盖 Followers 在该位置之后的条目。</li>
<li>Leader 会从后往前试，每次日志条目失败后尝试前一个日志条目，直到成功找到每个 Follower 的日志一致位点，然后向后逐条覆盖 Followers 在该位置之后的条目。</li>
</ul>
<h2 id="5-安全性"><a class="markdownIt-Anchor" href="#5-安全性"></a> 5. 安全性</h2>
<p>前面描述了 Raft 算法是如何选举 Leader 和复制日志的。</p>
<p>Raft 还增加了一些限制来完善 Raft 算法，以保证安全性：保证了任意 Leader 对于给定的 Term，都拥有了之前 Term 的所有被提交的日志条目。</p>
<h3 id="51-选举限制"><a class="markdownIt-Anchor" href="#51-选举限制"></a> 5.1. 选举限制</h3>
<p>拥有最新的已提交的日志条目的 Follower 才有资格成为 Leader。</p>
<p>Raft 使用投票的方式来阻止一个 Candidate 赢得选举除非这个 Candidate 包含了所有已经提交的日志条目。 Candidate 为了赢得选举必须联系集群中的大部分节点，这意味着每一个已经提交的日志条目在这些服务器节点中肯定存在于至少一个节点上。如果 Candidate 的日志至少和大多数的服务器节点一样新（这个新的定义会在下面讨论），那么他一定持有了所有已经提交的日志条目。</p>
<p><code>RequestVote RPC</code> 实现了这样的限制：<strong>RequestVote RPC 中包含了 Candidate 的日志信息， Follower 会拒绝掉那些日志没有自己新的投票请求</strong>。</p>
<p>如何判断哪个日志条目比较新？</p>
<p>Raft 通过比较两份日志中最后一条日志条目的日志索引和 Term 来判断哪个日志比较新。</p>
<ul>
<li>先判断 Term，哪个数值大即代表哪个日志比较新。</li>
<li>如果 Term 相同，再比较 日志索引，哪个数值大即代表哪个日志比较新。</li>
</ul>
<h3 id="52-提交旧任期的日志条目"><a class="markdownIt-Anchor" href="#52-提交旧任期的日志条目"></a> 5.2. 提交旧任期的日志条目</h3>
<p>一个当前 Term 的日志条目被复制到了半数以上的服务器上，Leader 就认为它是可以被提交的。如果这个 Leader 在提交日志条目前就下线了，后续的 Leader 可能会覆盖掉这个日志条目。</p>
<p><img src="https://pic4.zhimg.com/80/v2-12a5ebab63781f9ec49e14e331775537_hd.jpg" alt="img" /></p>
<blockquote>
<p>💡 图示说明：</p>
<p>上图解释了为什么 Leader 无法对旧 Term 的日志条目进行提交。</p>
<ul>
<li>阶段 (a) ，S1 是 Leader，且 S1 写入日志条目为 (Term 2，日志索引 2），只有 S2 复制了这个日志条目。</li>
<li>阶段 (b)，S1 下线，S5 被选举为 Term3 的 Leader。S5 写入日志条目为 (Term 3，日志索引 2）。</li>
<li>阶段 ©，S5 下线，S1 重新上线，并被选举为 Term4 的 Leader。此时，Term 2 的那条日志条目已经被复制到了集群中的大多数节点上，但是还没有被提交。</li>
<li>阶段 (d)，S1 再次下线，S5 重新上线，并被重新选举为 Term3 的 Leader。然后 S5 覆盖了日志索引 2 处的日志。</li>
<li>阶段 (e)，如果阶段 (d) 还未发生，即 S1 再次下线之前，S1 把自己主导的日志条目复制到了大多数节点上，那么在后续 Term 里面这些新日志条目就会被提交。这样在同一时刻就同时保证了，之前的所有旧日志条目就会被提交。</li>
</ul>
</blockquote>
<p><strong>Raft 永远不会通过计算副本数目的方式去提交一个之前 Term 内的日志条目</strong>。只有 Leader 当前 Term 里的日志条目通过计算副本数目可以被提交；一旦当前 Term 的日志条目以这种方式被提交，那么由于日志匹配特性，之前的日志条目也都会被间接的提交。</p>
<p>当 Leader 复制之前任期里的日志时，Raft 会为所有日志保留原始的 Term，这在提交规则上产生了额外的复杂性。在其他的一致性算法中，如果一个新的领导人要重新复制之前的任期里的日志时，它必须使用当前新的任期号。Raft 使用的方法更加容易辨别出日志，因为它可以随着时间和日志的变化对日志维护着同一个任期编号。另外，和其他的算法相比，Raft 中的新领导人只需要发送更少日志条目（其他算法中必须在他们被提交之前发送更多的冗余日志条目来为他们重新编号）。</p>
<h2 id="6-日志压缩"><a class="markdownIt-Anchor" href="#6-日志压缩"></a> 6. 日志压缩</h2>
<p>在实际的系统中，不能让日志无限膨胀，否则系统重启时需要花很长的时间进行恢复，从而影响可用性。Raft 采用对整个系统进行快照来解决，快照之前的日志都可以丢弃。</p>
<p>每个副本独立的对自己的系统状态生成快照，并且只能对已经提交的日志条目生成快照。</p>
<p>快照包含以下内容：</p>
<ul>
<li>日志元数据。最后一条已提交的日志条目的日志索引和 Term。这两个值在快照之后的第一条日志条目的 <code>AppendEntries RPC</code> 的完整性检查的时候会被用上。</li>
<li>系统当前状态。</li>
</ul>
<p>当 Leader 要发送某个日志条目，落后太多的 Follower 的日志条目会被丢弃，Leader 会将快照发给 Follower。或者新上线一台机器时，也会发送快照给它。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200201220628.png" alt="img" /></p>
<p><strong>生成快照的频率要适中</strong>，频率过高会消耗大量 I/O 带宽；频率过低，一旦需要执行恢复操作，会丢失大量数据，影响可用性。推荐当日志达到某个固定的大小时生成快照。</p>
<p>生成一次快照可能耗时过长，影响正常日志同步。可以通过使用 copy-on-write 技术避免快照过程影响正常日志同步。</p>
<blockquote>
<p>说明：本文仅阐述 Raft 算法的核心内容，不包括算法论证、评估等</p>
</blockquote>
<h2 id="7-参考资料"><a class="markdownIt-Anchor" href="#7-参考资料"></a> 7. 参考资料</h2>
<ul>
<li><a href="https://ramcloud.atlassian.net/wiki/download/attachments/6586375/raft.pdf" target="_blank" rel="noopener">Raft 一致性算法论文原文</a></li>
<li><a href="https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md" target="_blank" rel="noopener">Raft 一致性算法论文译文</a></li>
<li><a href="https://www.youtube.com/watch?v=YbZ3zDzDnrw&amp;feature=youtu.be" target="_blank" rel="noopener">Raft 作者讲解视频</a></li>
<li><a href="http://www2.cs.uh.edu/~paris/6360/PowerPoint/Raft.ppt" target="_blank" rel="noopener">Raft 作者讲解视频对应的 PPT</a></li>
<li><a href="https://www.jdon.com/artichect/raft.html" target="_blank" rel="noopener">分布式系统的 Raft 算法</a></li>
<li><a href="http://thesecretlivesofdata.com/raft" target="_blank" rel="noopener">Raft: Understandable Distributed Consensus</a> - 一个动画教程</li>
<li><a href="https://raft.github.io/" target="_blank" rel="noopener">The Raft Consensus Algorithm</a> - 一个交互式动画教程</li>
<li><a href="https://github.com/sofastack/sofa-jraft" target="_blank" rel="noopener">sofa-jraft</a> - 蚂蚁金服的 Raft 算法实现库（Java 版）</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/2020/01/30/redis-%E5%BA%94%E7%94%A8%E6%8C%87%E5%8D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2020/01/30/redis-%E5%BA%94%E7%94%A8%E6%8C%87%E5%8D%97/" class="post-title-link" itemprop="url">Redis 应用指南</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-30 21:48:57" itemprop="dateCreated datePublished" datetime="2020-01-30T21:48:57+08:00">2020-01-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-14 16:45:53" itemprop="dateModified" datetime="2022-04-14T16:45:53+08:00">2022-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">KV数据库</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/KV%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2020/01/30/redis-%E5%BA%94%E7%94%A8%E6%8C%87%E5%8D%97/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/01/30/redis-应用指南/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="redis-应用指南"><a class="markdownIt-Anchor" href="#redis-应用指南"></a> Redis 应用指南</h1>
<h2 id="一-redis-简介"><a class="markdownIt-Anchor" href="#一-redis-简介"></a> 一、Redis 简介</h2>
<blockquote>
<p>Redis 是速度非常快的非关系型（NoSQL）内存键值数据库，可以存储键和五种不同类型的值之间的映射。</p>
<p>键的类型只能为字符串，值支持的五种类型数据类型为：字符串、列表、集合、有序集合、散列表。</p>
</blockquote>
<h3 id="redis-使用场景"><a class="markdownIt-Anchor" href="#redis-使用场景"></a> Redis 使用场景</h3>
<ul>
<li><strong>缓存</strong> - 将热点数据放到内存中，设置内存的最大使用量以及过期淘汰策略来保证缓存的命中率。</li>
<li><strong>计数器</strong> - Redis 这种内存数据库能支持计数器频繁的读写操作。</li>
<li><strong>应用限流</strong> - 限制一个网站访问流量。</li>
<li><strong>消息队列</strong> - 使用 List 数据类型，它是双向链表。</li>
<li><strong>查找表</strong> - 使用 HASH 数据类型。</li>
<li><strong>交集运算</strong> - 使用 SET 类型，例如求两个用户的共同好友。</li>
<li><strong>排行榜</strong> - 使用 ZSET 数据类型。</li>
<li><strong>分布式 Session</strong> - 多个应用服务器的 Session 都存储到 Redis 中来保证 Session 的一致性。</li>
<li><strong>分布式锁</strong> - 除了可以使用 SETNX 实现分布式锁之外，还可以使用官方提供的 RedLock 分布式锁实现。</li>
</ul>
<h3 id="redis-的优势"><a class="markdownIt-Anchor" href="#redis-的优势"></a> Redis 的优势</h3>
<ul>
<li>性能极高 – Redis 能读的速度是 110000 次/s,写的速度是 81000 次/s。</li>
<li>丰富的数据类型 - 支持字符串、列表、集合、有序集合、散列表。</li>
<li>原子 - Redis 的所有操作都是原子性的。单个操作是原子性的。多个操作也支持事务，即原子性，通过 MULTI 和 EXEC 指令包起来。</li>
<li>持久化 - Redis 支持数据的持久化。可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li>
<li>备份 - Redis 支持数据的备份，即 master-slave 模式的数据备份。</li>
<li>丰富的特性 - Redis 还支持发布订阅, 通知, key 过期等等特性。</li>
</ul>
<h3 id="redis-与-memcached"><a class="markdownIt-Anchor" href="#redis-与-memcached"></a> Redis 与 Memcached</h3>
<p>Redis 与 Memcached 因为都可以用于缓存，所以常常被拿来做比较，二者主要有以下区别：</p>
<p><strong>数据类型</strong></p>
<ul>
<li>Memcached 仅支持字符串类型；</li>
<li>而 Redis 支持五种不同种类的数据类型，使得它可以更灵活地解决问题。</li>
</ul>
<p><strong>数据持久化</strong></p>
<ul>
<li>Memcached 不支持持久化；</li>
<li>Redis 支持两种持久化策略：RDB 快照和 AOF 日志。</li>
</ul>
<p><strong>分布式</strong></p>
<ul>
<li>Memcached 不支持分布式，只能通过在客户端使用像一致性哈希这样的分布式算法来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点。</li>
<li>Redis Cluster 实现了分布式的支持。</li>
</ul>
<p><strong>内存管理机制</strong></p>
<ul>
<li>Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题，但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。</li>
<li>在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘。而 Memcached 的数据则会一直在内存中。</li>
</ul>
<h3 id="redis-为什么快"><a class="markdownIt-Anchor" href="#redis-为什么快"></a> Redis 为什么快</h3>
<p>Redis 单机 QPS 能达到 100000。</p>
<p>Redis 是单线程模型（Redis 6.0 已经支持多线程模型），为什么还能有这么高的并发？</p>
<ul>
<li>Redis 完全基于内存操作。</li>
<li>Redis 数据结构简单。</li>
<li>采用单线程，避免线程上下文切换和竞争。</li>
<li>使用 I/O 多路复用模型（非阻塞 I/O）。</li>
</ul>
<blockquote>
<p>I/O 多路复用</p>
<p>I/O 多路复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。</p>
</blockquote>
<h2 id="二-redis-数据类型"><a class="markdownIt-Anchor" href="#二-redis-数据类型"></a> 二、Redis 数据类型</h2>
<p>Redis 基本数据类型：STRING、HASH、LIST、SET、ZSET</p>
<p>Redis 高级数据类型：BitMap、HyperLogLog、GEO</p>
<blockquote>
<p>💡 更详细的特性及原理说明请参考：<a href="03.Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BA%94%E7%94%A8.md">Redis 数据类型和应用</a></p>
</blockquote>
<h2 id="三-redis-内存淘汰"><a class="markdownIt-Anchor" href="#三-redis-内存淘汰"></a> 三、Redis 内存淘汰</h2>
<h3 id="内存淘汰要点"><a class="markdownIt-Anchor" href="#内存淘汰要点"></a> 内存淘汰要点</h3>
<ul>
<li>
<p><strong>最大缓存</strong> - Redis 允许通过 <code>maxmemory</code> 参数来设置内存最大值。</p>
</li>
<li>
<p><strong>失效时间</strong> - 作为一种定期清理无效数据的重要机制，在 Redis 提供的诸多命令中，<code>EXPIRE</code>、<code>EXPIREAT</code>、<code>PEXPIRE</code>、<code>PEXPIREAT</code> 以及 <code>SETEX</code> 和 <code>PSETEX</code> 均可以用来设置一条键值对的失效时间。而一条键值对一旦被关联了失效时间就会在到期后自动删除（或者说变得无法访问更为准确）。</p>
</li>
<li>
<p><strong>淘汰策略</strong> - 随着不断的向 Redis 中保存数据，当内存剩余空间无法满足添加的数据时，Redis 内就会施行数据淘汰策略，清除一部分内容然后保证新的数据可以保存到内存中。内存淘汰机制是为了更好的使用内存，用一定得 miss 来换取内存的利用率，保证 Redis 缓存中保存的都是热点数据。</p>
</li>
<li>
<p><strong>非精准的 LRU</strong> - 实际上 Redis 实现的 LRU 并不是可靠的 LRU，也就是名义上我们使用 LRU 算法淘汰键，但是实际上被淘汰的键并不一定是真正的最久没用的。</p>
</li>
</ul>
<h3 id="主键过期时间"><a class="markdownIt-Anchor" href="#主键过期时间"></a> 主键过期时间</h3>
<p>Redis 可以为每个键设置过期时间，当键过期时，会自动删除该键。</p>
<p>对于散列表这种容器，只能为整个键设置过期时间（整个散列表），而不能为键里面的单个元素设置过期时间。</p>
<p>可以使用 <code>EXPIRE</code> 或 <code>EXPIREAT</code> 来为 key 设置过期时间。</p>
<blockquote>
<p>🔔 注意：当 <code>EXPIRE</code> 的时间如果设置的是负数，<code>EXPIREAT</code> 设置的时间戳是过期时间，将直接删除 key。</p>
</blockquote>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SET mykey <span class="string">"Hello"</span></span></span><br><span class="line">"OK"</span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> EXPIRE mykey 10</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> TTL mykey</span></span><br><span class="line">(integer) 10</span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SET mykey <span class="string">"Hello World"</span></span></span><br><span class="line">"OK"</span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> TTL mykey</span></span><br><span class="line">(integer) -1</span><br><span class="line"><span class="meta">redis&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="淘汰策略"><a class="markdownIt-Anchor" href="#淘汰策略"></a> 淘汰策略</h3>
<p>内存淘汰只是 Redis 提供的一个功能，为了更好地实现这个功能，必须为不同的应用场景提供不同的策略，内存淘汰策略讲的是为实现内存淘汰我们具体怎么做，要解决的问题包括淘汰键空间如何选择？在键空间中淘汰键如何选择？</p>
<p>Redis 提供了下面几种内存淘汰策略供用户选：</p>
<ul>
<li><strong><code>noeviction</code></strong> - 当内存使用达到阈值的时候，所有引起申请内存的命令会报错。这是 Redis 默认的策略。</li>
<li><strong><code>allkeys-lru</code></strong> - 在主键空间中，优先移除最近未使用的 key。</li>
<li><strong><code>allkeys-random</code></strong> - 在主键空间中，随机移除某个 key。</li>
<li><strong><code>volatile-lru</code></strong> - 在设置了过期时间的键空间中，优先移除最近未使用的 key。</li>
<li><strong><code>volatile-random</code></strong> - 在设置了过期时间的键空间中，随机移除某个 key。</li>
<li><strong><code>volatile-ttl</code></strong> - 在设置了过期时间的键空间中，具有更早过期时间的 key 优先移除。</li>
</ul>
<h3 id="如何选择淘汰策略"><a class="markdownIt-Anchor" href="#如何选择淘汰策略"></a> 如何选择淘汰策略</h3>
<ul>
<li>如果<strong>数据呈现幂等分布（存在热点数据，部分数据访问频率高，部分数据访问频率低），则使用 <code>allkeys-lru</code></strong>。</li>
<li>如果<strong>数据呈现平等分布（数据访问频率大致相同），则使用 <code>allkeys-random</code></strong>。</li>
<li>如果希望<strong>使用不同的 TTL 值向 Redis 提示哪些 key 更适合被淘汰，请使用 <code>volatile-ttl</code></strong>。</li>
<li><strong><code>volatile-lru</code> 和 <code>volatile-random</code> 适合既应用于缓存和又应用于持久化存储的场景</strong>，然而我们也可以通过使用两个 Redis 实例来达到相同的效果。</li>
<li><strong>将 key 设置过期时间实际上会消耗更多的内存，因此建议使用 <code>allkeys-lru</code> 策略从而更有效率的使用内存</strong>。</li>
</ul>
<h3 id="内部实现"><a class="markdownIt-Anchor" href="#内部实现"></a> 内部实现</h3>
<p>Redis 删除失效主键的方法主要有两种：</p>
<ul>
<li>消极方法（passive way），在主键被访问时如果发现它已经失效，那么就删除它。</li>
<li>主动方法（active way），周期性地从设置了失效时间的主键中选择一部分失效的主键删除。</li>
<li>主动删除：当前已用内存超过 <code>maxmemory</code> 限定时，触发主动清理策略，该策略由启动参数的配置决定主键具体的失效时间全部都维护在 <code>expires</code> 这个字典表中。</li>
</ul>
<h2 id="四-redis-持久化"><a class="markdownIt-Anchor" href="#四-redis-持久化"></a> 四、Redis 持久化</h2>
<p>Redis 是内存型数据库，为了保证数据在宕机后不会丢失，需要将内存中的数据持久化到硬盘上。</p>
<p>Redis 支持两种持久化方式：RDB 和 AOF。</p>
<ul>
<li>RDB - <strong>RDB 即快照方式，它将某个时间点的所有 Redis 数据保存到一个经过压缩的二进制文件（RDB 文件）中</strong>。</li>
<li>AOF - <code>AOF(Append Only File)</code> 是以文本日志形式将所有写命令追加到 AOF 文件的末尾，以此来记录数据的变化。当服务器重启的时候会重新载入和执行这些命令来恢复原始的数据。AOF 适合作为 <strong>热备</strong>。</li>
</ul>
<blockquote>
<p>💡 更详细的特性及原理说明请参考：<a href="04.Redis%E6%8C%81%E4%B9%85%E5%8C%96.md">Redis 持久化</a></p>
</blockquote>
<h2 id="五-redis-事件"><a class="markdownIt-Anchor" href="#五-redis-事件"></a> 五、Redis 事件</h2>
<p>Redis 服务器是一个事件驱动程序，服务器需要处理两类事件：</p>
<ul>
<li><strong><code>文件事件（file event）</code></strong> - Redis 服务器通过套接字（Socket）与客户端或者其它服务器进行通信，文件事件就是对套接字操作的抽象。服务器与客户端（或其他的服务器）的通信会产生文件事件，而服务器通过监听并处理这些事件来完成一系列网络通信操作。</li>
<li><strong><code>时间事件（time event）</code></strong> - Redis 服务器有一些操作需要在给定的时间点执行，时间事件是对这类定时操作的抽象。</li>
</ul>
<h3 id="文件事件"><a class="markdownIt-Anchor" href="#文件事件"></a> 文件事件</h3>
<p>Redis 基于 Reactor 模式开发了自己的网络时间处理器。</p>
<ul>
<li>Redis 文件事件处理器使用 I/O 多路复用程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li>
<li>当被监听的套接字准备好执行连接应答、读取、写入、关闭操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li>
</ul>
<p>虽然文件事件处理器以单线程方式运行，但通过使用 I/O 多路复用程序来监听多个套接字，文件事件处理器实现了高性能的网络通信模型。</p>
<p>文件事件处理器有四个组成部分：套接字、I/O 多路复用程序、文件事件分派器、事件处理器。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200130172525.png" alt="img" /></p>
<h3 id="时间事件"><a class="markdownIt-Anchor" href="#时间事件"></a> 时间事件</h3>
<p>时间事件又分为：</p>
<ul>
<li><strong>定时事件</strong>：是让一段程序在指定的时间之内执行一次；</li>
<li><strong>周期性事件</strong>：是让一段程序每隔指定时间就执行一次。</li>
</ul>
<p>Redis 将所有时间事件都放在一个无序链表中，每当时间事件执行器运行时，通过遍历整个链表查找出已到达的时间事件，并调用响应的事件处理器。</p>
<h3 id="事件的调度与执行"><a class="markdownIt-Anchor" href="#事件的调度与执行"></a> 事件的调度与执行</h3>
<p>服务器需要不断监听文件事件的套接字才能得到待处理的文件事件，但是不能一直监听，否则时间事件无法在规定的时间内执行，因此监听时间应该根据距离现在最近的时间事件来决定。</p>
<p>事件调度与执行由 aeProcessEvents 函数负责，伪代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aeProcessEvents</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">## 获取到达时间离当前时间最接近的时间事件</span></span><br><span class="line">    time_event = aeSearchNearestTimer()</span><br><span class="line"></span><br><span class="line">    <span class="comment">## 计算最接近的时间事件距离到达还有多少毫秒</span></span><br><span class="line">    remaind_ms = time_event.when - unix_ts_now()</span><br><span class="line"></span><br><span class="line">    <span class="comment">## 如果事件已到达，那么 remaind_ms 的值可能为负数，将它设为 0</span></span><br><span class="line">    <span class="keyword">if</span> remaind_ms &lt; <span class="number">0</span>:</span><br><span class="line">        remaind_ms = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">## 根据 remaind_ms 的值，创建 timeval</span></span><br><span class="line">    timeval = create_timeval_with_ms(remaind_ms)</span><br><span class="line"></span><br><span class="line">    <span class="comment">## 阻塞并等待文件事件产生，最大阻塞时间由传入的 timeval 决定</span></span><br><span class="line">    aeApiPoll(timeval)</span><br><span class="line"></span><br><span class="line">    <span class="comment">## 处理所有已产生的文件事件</span></span><br><span class="line">    procesFileEvents()</span><br><span class="line"></span><br><span class="line">    <span class="comment">## 处理所有已到达的时间事件</span></span><br><span class="line">    processTimeEvents()</span><br></pre></td></tr></table></figure>
<p>将 aeProcessEvents 函数置于一个循环里面，加上初始化和清理函数，就构成了 Redis 服务器的主函数，伪代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">## 初始化服务器</span></span><br><span class="line">    init_server()</span><br><span class="line"></span><br><span class="line">    <span class="comment">## 一直处理事件，直到服务器关闭为止</span></span><br><span class="line">    <span class="keyword">while</span> server_is_not_shutdown():</span><br><span class="line">        aeProcessEvents()</span><br><span class="line"></span><br><span class="line">    <span class="comment">## 服务器关闭，执行清理操作</span></span><br><span class="line">    clean_server()</span><br></pre></td></tr></table></figure>
<p>从事件处理的角度来看，服务器运行流程如下：</p>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/database/redis/redis-event.png" />
</div>
<h2 id="六-redis-事务"><a class="markdownIt-Anchor" href="#六-redis-事务"></a> 六、Redis 事务</h2>
<blockquote>
<p><strong>Redis 提供的不是严格的事务，Redis 只保证串行执行命令，并且能保证全部执行，但是执行命令失败时并不会回滚，而是会继续执行下去</strong>。</p>
</blockquote>
<p><code>MULTI</code> 、 <code>EXEC</code> 、 <code>DISCARD</code> 和 <code>WATCH</code> 是 Redis 事务相关的命令。</p>
<p>事务可以一次执行多个命令， 并且有以下两个重要的保证：</p>
<ul>
<li>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li>
<li>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</li>
</ul>
<h3 id="multi"><a class="markdownIt-Anchor" href="#multi"></a> MULTI</h3>
<p><strong><a href="https://redis.io/commands/multi" target="_blank" rel="noopener"><code>MULTI</code></a> 命令用于开启一个事务，它总是返回 OK 。</strong></p>
<p><code>MULTI</code> 执行之后， 客户端可以继续向服务器发送任意多条命令， 这些命令不会立即被执行， 而是被放到一个队列中， 当 EXEC 命令被调用时， 所有队列中的命令才会被执行。</p>
<p>以下是一个事务例子， 它原子地增加了 foo 和 bar 两个键的值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">&gt; INCR foo</span><br><span class="line">QUEUED</span><br><span class="line">&gt; INCR bar</span><br><span class="line">QUEUED</span><br><span class="line">&gt; EXEC</span><br><span class="line"><span class="number">1</span>) (integer) <span class="number">1</span></span><br><span class="line"><span class="number">2</span>) (integer) <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="exec"><a class="markdownIt-Anchor" href="#exec"></a> EXEC</h3>
<p><strong><a href="https://redis.io/commands/exec" target="_blank" rel="noopener"><code>EXEC</code></a> 命令负责触发并执行事务中的所有命令。</strong></p>
<ul>
<li>如果客户端在使用 <code>MULTI</code> 开启了一个事务之后，却因为断线而没有成功执行 <code>EXEC</code> ，那么事务中的所有命令都不会被执行。</li>
<li>另一方面，如果客户端成功在开启事务之后执行 <code>EXEC</code> ，那么事务中的所有命令都会被执行。</li>
</ul>
<h3 id="discard"><a class="markdownIt-Anchor" href="#discard"></a> DISCARD</h3>
<p><strong>当执行 <a href="https://redis.io/commands/discard" target="_blank" rel="noopener"><code>DISCARD</code></a> 命令时， 事务会被放弃， 事务队列会被清空， 并且客户端会从事务状态中退出。</strong></p>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; SET foo <span class="number">1</span></span><br><span class="line">OK</span><br><span class="line">&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">&gt; INCR foo</span><br><span class="line">QUEUED</span><br><span class="line">&gt; DISCARD</span><br><span class="line">OK</span><br><span class="line">&gt; GET foo</span><br><span class="line"><span class="string">"1"</span></span><br></pre></td></tr></table></figure>
<h3 id="watch"><a class="markdownIt-Anchor" href="#watch"></a> WATCH</h3>
<p><strong><a href="https://redis.io/commands/watch" target="_blank" rel="noopener"><code>WATCH</code></a> 命令可以为 Redis 事务提供 check-and-set （CAS）行为。</strong></p>
<p>被 WATCH 的键会被监视，并会发觉这些键是否被改动过了。 如果有至少一个被监视的键在 EXEC 执行之前被修改了， 那么整个事务都会被取消， EXEC 返回 nil-reply 来表示事务已经失败。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">WATCH mykey</span><br><span class="line">val = GET mykey</span><br><span class="line">val = val + <span class="number">1</span></span><br><span class="line">MULTI</span><br><span class="line">SET mykey $val</span><br><span class="line">EXEC</span><br></pre></td></tr></table></figure>
<p>使用上面的代码， 如果在 WATCH 执行之后， EXEC 执行之前， 有其他客户端修改了 mykey 的值， 那么当前客户端的事务就会失败。 程序需要做的， 就是不断重试这个操作， 直到没有发生碰撞为止。</p>
<p>这种形式的锁被称作乐观锁， 它是一种非常强大的锁机制。 并且因为大多数情况下， 不同的客户端会访问不同的键， 碰撞的情况一般都很少， 所以通常并不需要进行重试。</p>
<p>WATCH 使得 EXEC 命令需要有条件地执行：事务只能在所有被监视键都没有被修改的前提下执行，如果这个前提不能满足的话，事务就不会被执行。</p>
<p>WATCH 命令可以被调用多次。对键的监视从 WATCH 执行之后开始生效，直到调用 EXEC 为止。</p>
<p>用户还可以在单个 WATCH 命令中监视任意多个键，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">redis&gt; WATCH key1 key2 key3</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<h4 id="取消-watch-的场景"><a class="markdownIt-Anchor" href="#取消-watch-的场景"></a> 取消 WATCH 的场景</h4>
<p>当 EXEC 被调用时， 不管事务是否成功执行， 对所有键的监视都会被取消。</p>
<p>另外， 当客户端断开连接时， 该客户端对键的监视也会被取消。</p>
<p>使用无参数的 UNWATCH 命令可以手动取消对所有键的监视。 对于一些需要改动多个键的事务， 有时候程序需要同时对多个键进行加锁， 然后检查这些键的当前值是否符合程序的要求。 当值达不到要求时， 就可以使用 UNWATCH 命令来取消目前对键的监视， 中途放弃这个事务， 并等待事务的下次尝试。</p>
<h4 id="使用-watch-创建原子操作"><a class="markdownIt-Anchor" href="#使用-watch-创建原子操作"></a> 使用 WATCH 创建原子操作</h4>
<p>WATCH 可以用于创建 Redis 没有内置的原子操作。</p>
<p>举个例子，以下代码实现了原创的 ZPOP 命令，它可以原子地弹出有序集合中分值（score）最小的元素：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">WATCH</span> <span class="string">zset</span></span><br><span class="line"><span class="attr">element</span> = <span class="string">ZRANGE zset 0 0</span></span><br><span class="line"><span class="attr">MULTI</span></span><br><span class="line"><span class="attr">ZREM</span> <span class="string">zset element</span></span><br><span class="line"><span class="attr">EXEC</span></span><br></pre></td></tr></table></figure>
<h3 id="rollback"><a class="markdownIt-Anchor" href="#rollback"></a> Rollback</h3>
<p><strong>Redis 不支持回滚</strong>。Redis 不支持回滚的理由：</p>
<ul>
<li>Redis 命令只会因为错误的语法而失败，或是命令用在了错误类型的键上面。</li>
<li>因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。</li>
</ul>
<h2 id="七-redis-管道"><a class="markdownIt-Anchor" href="#七-redis-管道"></a> 七、Redis 管道</h2>
<p>Redis 是一种基于 C/S 模型以及请求/响应协议的 TCP 服务。Redis 支持管道技术。管道技术允许请求以异步方式发送，即旧请求的应答还未返回的情况下，允许发送新请求。这种方式可以大大提高传输效率。</p>
<p>在需要批量执行 Redis 命令时，如果一条一条执行，显然很低效。为了减少通信次数并降低延迟，可以使用 Redis 管道功能。Redis 的管道（pipeline）功能没有提供命令行支持，但是在各种语言版本的客户端中都有相应的实现。</p>
<p>以 Jedis 为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pipeline pipe = conn.pipelined();</span><br><span class="line">pipe.multi();</span><br><span class="line">pipe.hset(<span class="string">"login:"</span>, token, user);</span><br><span class="line">pipe.zadd(<span class="string">"recent:"</span>, timestamp, token);</span><br><span class="line"><span class="keyword">if</span> (item != <span class="keyword">null</span>) &#123;</span><br><span class="line">    pipe.zadd(<span class="string">"viewed:"</span> + token, timestamp, item);</span><br><span class="line">    pipe.zremrangeByRank(<span class="string">"viewed:"</span> + token, <span class="number">0</span>, -<span class="number">26</span>);</span><br><span class="line">    pipe.zincrby(<span class="string">"viewed:"</span>, -<span class="number">1</span>, item);</span><br><span class="line">&#125;</span><br><span class="line">pipe.exec();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>🔔 注意：使用管道发送命令时，Redis Server 会将部分请求放到缓存队列中（占用内存），执行完毕后一次性发送结果。如果需要发送大量的命令，会占用大量的内存，因此应该按照合理数量分批次的处理。</p>
</blockquote>
<h2 id="八-redis-发布与订阅"><a class="markdownIt-Anchor" href="#八-redis-发布与订阅"></a> 八、Redis 发布与订阅</h2>
<p>Redis 提供了 5 个发布与订阅命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>SUBSCRIBE</code></td>
<td><code>SUBSCRIBE channel [channel ...]</code>—订阅指定频道。</td>
</tr>
<tr>
<td><code>UNSUBSCRIBE</code></td>
<td><code>UNSUBSCRIBE [channel [channel ...]]</code>—取消订阅指定频道。</td>
</tr>
<tr>
<td><code>PUBLISH</code></td>
<td><code>PUBLISH channel message</code>—发送信息到指定的频道。</td>
</tr>
<tr>
<td><code>PSUBSCRIBE</code></td>
<td><code>PSUBSCRIBE pattern [pattern ...]</code>—订阅符合指定模式的频道。</td>
</tr>
<tr>
<td><code>PUNSUBSCRIBE</code></td>
<td><code>PUNSUBSCRIBE [pattern [pattern ...]]</code>—取消订阅符合指定模式的频道。</td>
</tr>
</tbody>
</table>
<p>订阅者订阅了频道之后，发布者向频道发送字符串消息会被所有订阅者接收到。</p>
<p>某个客户端使用 SUBSCRIBE 订阅一个频道，其它客户端可以使用 PUBLISH 向这个频道发送消息。</p>
<p>发布与订阅模式和观察者模式有以下不同：</p>
<ul>
<li>观察者模式中，观察者和主题都知道对方的存在；而在发布与订阅模式中，发布者与订阅者不知道对方的存在，它们之间通过频道进行通信。</li>
<li>观察者模式是同步的，当事件触发时，主题会去调用观察者的方法；而发布与订阅模式是异步的；</li>
</ul>
<hr />
<p><strong><em>分割线以下为 Redis 集群功能特性</em></strong></p>
<h2 id="九-redis-复制"><a class="markdownIt-Anchor" href="#九-redis-复制"></a> 九、Redis 复制</h2>
<blockquote>
<p>关系型数据库通常会使用一个主服务器向多个从服务器发送更新，并使用从服务器来处理所有读请求，Redis 也采用了同样的方式来实现复制特性。</p>
</blockquote>
<h3 id="旧版复制"><a class="markdownIt-Anchor" href="#旧版复制"></a> 旧版复制</h3>
<p>Redis 2.8 版本以前的复制功能基于 <code>SYNC</code> 命令实现。</p>
<p>Redis 的复制功能分为同步（sync）和命令传播（command propagate）两个操作：</p>
<ul>
<li><strong><code>同步（sync）</code></strong> - 用于将从服务器的数据库状态更新至主服务器当前的数据库状态。</li>
<li><strong><code>命令传播（command propagate）</code></strong> - 当主服务器的数据库状态被修改，导致主从数据库状态不一致时，让主从服务器的数据库重新回到一致状态。</li>
</ul>
<p>这种方式存在缺陷：不能高效处理断线重连后的复制情况。</p>
<h3 id="新版复制"><a class="markdownIt-Anchor" href="#新版复制"></a> 新版复制</h3>
<p>Redis 2.8 版本以后的复制功能基于 <code>PSYNC</code> 命令实现。<code>PSYNC</code> 命令具有完整重同步和部分重同步两种模式。</p>
<ul>
<li><strong><code>完整重同步（full resychronization）</code></strong> - 用于初次复制。执行步骤与 <code>SYNC</code> 命令基本一致。</li>
<li><strong><code>部分重同步（partial resychronization）</code></strong> - 用于断线后重复制。<strong>如果条件允许，主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器</strong>，从服务器只需接收并执行这些写命令，即可将主从服务器的数据库状态保持一致。</li>
</ul>
<h3 id="部分重同步"><a class="markdownIt-Anchor" href="#部分重同步"></a> 部分重同步</h3>
<p>部分重同步有三个组成部分：</p>
<ul>
<li>主从服务器的<strong>复制偏移量（replication offset）</strong></li>
<li>主服务器的<strong>复制积压缓冲区（replication backlog）</strong></li>
<li><strong>服务器的运行 ID</strong></li>
</ul>
<h3 id="psync-命令"><a class="markdownIt-Anchor" href="#psync-命令"></a> PSYNC 命令</h3>
<p>从服务器向要复制的主服务器发送 <code>PSYNC &lt;runid&gt; &lt;offset&gt;</code> 命令</p>
<ul>
<li>假如主从服务器的 <strong>master run id 相同</strong>，并且<strong>指定的偏移量（offset）在内存缓冲区中还有效</strong>，复制就会从上次中断的点开始继续。</li>
<li>如果其中一个条件不满足，就会进行完全重新同步。</li>
</ul>
<h3 id="心跳检测"><a class="markdownIt-Anchor" href="#心跳检测"></a> 心跳检测</h3>
<p>主服务器通过向从服务传播命令来更新从服务器状态，保持主从数据一致。</p>
<p>从服务器通过向主服务器发送命令 <code>REPLCONF ACK &lt;replication_offset&gt;</code> 来进行心跳检测，以及命令丢失检测。</p>
<blockquote>
<p>💡 更详细的特性及原理说明请参考：<a href="05.Redis%E5%A4%8D%E5%88%B6.md">Redis 复制</a></p>
</blockquote>
<h2 id="十-redis-哨兵"><a class="markdownIt-Anchor" href="#十-redis-哨兵"></a> 十、Redis 哨兵</h2>
<p>Sentinel（哨兵）可以监听主服务器，并在主服务器进入下线状态时，自动从从服务器中选举出新的主服务器。</p>
<blockquote>
<p>💡 更详细的特性及原理说明请参考：<a href="06.Redis%E5%93%A8%E5%85%B5.md">Redis 哨兵</a></p>
</blockquote>
<h2 id="十一-redis-集群"><a class="markdownIt-Anchor" href="#十一-redis-集群"></a> 十一、Redis 集群</h2>
<p>分片是将数据划分为多个部分的方法，可以将数据存储到多台机器里面，也可以从多台机器里面获取数据，这种方法在解决某些问题时可以获得线性级别的性能提升。</p>
<p>假设有 4 个 Reids 实例 R0，R1，R2，R3，还有很多表示用户的键 user:1，user:2，… 等等，有不同的方式来选择一个指定的键存储在哪个实例中。最简单的方式是范围分片，例如用户 id 从 0~1000 的存储到实例 R0 中，用户 id 从 1001~2000 的存储到实例 R1 中，等等。但是这样需要维护一张映射范围表，维护操作代价很高。还有一种方式是哈希分片，使用 CRC32 哈希函数将键转换为一个数字，再对实例数量求模就能知道应该存储的实例。</p>
<p>主要有三种分片方式：</p>
<ul>
<li>客户端分片：客户端使用一致性哈希等算法决定键应当分布到哪个节点。</li>
<li>代理分片：将客户端请求发送到代理上，由代理转发请求到正确的节点上。</li>
<li>服务器分片：Redis Cluster（官方的 Redis 集群解决方案）。</li>
</ul>
<h2 id="十二-redis-client"><a class="markdownIt-Anchor" href="#十二-redis-client"></a> 十二、Redis Client</h2>
<p>Redis 社区中有多种编程语言的客户端，可以在这里查找合适的客户端：<a href="https://redis.io/clients" target="_blank" rel="noopener">Redis 官方罗列的客户端清单</a></p>
<p>redis 官方推荐的 Java Redis Client：</p>
<ul>
<li><a href="https://github.com/xetorthio/jedis" target="_blank" rel="noopener">jedis</a> - 最流行的 Redis Java 客户端</li>
<li><a href="https://github.com/redisson/redisson" target="_blank" rel="noopener">redisson</a> - 额外提供了很多的分布式服务特性，如：分布式锁、分布式 Java 常用对象（BitSet、BlockingQueue、CountDownLatch 等）</li>
<li><a href="https://github.com/lettuce-io/lettuce-core" target="_blank" rel="noopener">lettuce</a> - Spring Boot 2.0 默认 Redis 客户端</li>
</ul>
<h2 id="扩展阅读"><a class="markdownIt-Anchor" href="#扩展阅读"></a> 扩展阅读</h2>
<blockquote>
<p>💡 Redis 常用于分布式缓存，有关缓存的特性和原理请参考：<a href="https://dunwu.github.io/design/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98.html">缓存基本原理</a></p>
</blockquote>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><strong>官网</strong>
<ul>
<li><a href="https://redis.io/" target="_blank" rel="noopener">Redis 官网</a></li>
<li><a href="https://github.com/antirez/redis" target="_blank" rel="noopener">Redis github</a></li>
<li><a href="http://redis.cn/" target="_blank" rel="noopener">Redis 官方文档中文版</a></li>
</ul>
</li>
<li><strong>书籍</strong>
<ul>
<li><a href="https://item.jd.com/11791607.html" target="_blank" rel="noopener">《Redis 实战》</a></li>
<li><a href="https://item.jd.com/11486101.html" target="_blank" rel="noopener">《Redis 设计与实现》</a></li>
</ul>
</li>
<li><strong>教程</strong>
<ul>
<li><a href="http://redisdoc.com/" target="_blank" rel="noopener">Redis 命令参考</a></li>
</ul>
</li>
<li><strong>资源汇总</strong>
<ul>
<li><a href="https://github.com/JamzyWang/awesome-redis" target="_blank" rel="noopener">awesome-redis</a></li>
</ul>
</li>
<li><strong>Redis Client</strong>
<ul>
<li><a href="https://docs.spring.io/spring-data/redis/docs/1.8.13.RELEASE/reference/html/" target="_blank" rel="noopener">spring-data-redis 官方文档</a></li>
<li><a href="https://github.com/redisson/redisson/wiki/%E7%9B%AE%E5%BD%95" target="_blank" rel="noopener">redisson 官方文档(中文,略有滞后)</a></li>
<li><a href="https://github.com/redisson/redisson/wiki/Table-of-Content" target="_blank" rel="noopener">redisson 官方文档(英文)</a></li>
<li><a href="https://www.jianshu.com/p/82f0d5abb002" target="_blank" rel="noopener">CRUG | Redisson PRO vs. Jedis: Which Is Faster? 翻译</a></li>
<li><a href="https://blog.csdn.net/everlasting_188/article/details/51073505" target="_blank" rel="noopener">redis 分布锁 Redisson 性能测试</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blog/page/9/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/blog/page/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/18/">18</a><a class="extend next" rel="next" href="/blog/page/11/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="Zhang Peng"
    src="/blog/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Zhang Peng</p>
  <div class="site-description" itemprop="description">Dunwu's Blog</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">173</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">102</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/dunwu" title="GitHub &amp;rarr; https:&#x2F;&#x2F;github.com&#x2F;dunwu" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:forbreak@163.com" title="E-Mail &amp;rarr; mailto:forbreak@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/blog/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-paper-plane"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhang Peng</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">976k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">14:48</span>
</div>

        












        
      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1/canvas-nest.min.js"></script>
  <script src="/blog/lib/anime.min.js"></script>
  <script src="/blog/lib/velocity/velocity.min.js"></script>
  <script src="/blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/pisces.js"></script>


<script src="/blog/js/next-boot.js"></script>

<script src="/blog/js/bookmark.js"></script>




  




  
<script src="/blog/js/local-search.js"></script>














  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://blog-ajay4qmfci.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>

</body>
</html>
