<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon.ico">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/themes/blue/pace-theme-minimal.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/pace.min.js"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/blog/',
    scheme: 'Pisces',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":true},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":true,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="Dunwu&#39;s Blog">
<meta property="og:type" content="website">
<meta property="og:title" content="Dunwu">
<meta property="og:url" content="https://dunwu.github.io/blog/page/14/index.html">
<meta property="og:site_name" content="Dunwu">
<meta property="og:description" content="Dunwu&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Zhang Peng">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://dunwu.github.io/blog/page/14/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Dunwu</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/blog/atom.xml" title="Dunwu" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/blog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Dunwu</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <h1 class="site-subtitle" itemprop="description">大道至简，知易行难</h1>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/blog/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">102</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">37</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">173</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/dunwu" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/2018/10/13/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E9%9D%9E%E5%BF%85%E8%A6%81%E7%9A%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2018/10/13/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E9%9D%9E%E5%BF%85%E8%A6%81%E7%9A%84/" class="post-title-link" itemprop="url">代码坏味道之非必要的</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-13 22:48:00" itemprop="dateCreated datePublished" datetime="2018-10-13T22:48:00+08:00">2018-10-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-14 16:45:53" itemprop="dateModified" datetime="2022-04-14T16:45:53+08:00">2022-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index">
                    <span itemprop="name">设计</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/%E9%87%8D%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">重构</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2018/10/13/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E9%9D%9E%E5%BF%85%E8%A6%81%E7%9A%84/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/10/13/代码坏味道之非必要的/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>翻译自：<a href="https://sourcemaking.com/refactoring/smells/dispensables" target="_blank" rel="noopener">https://sourcemaking.com/refactoring/smells/dispensables</a></p>
<p><strong>非必要的(Dispensables)这组坏味道意味着：这样的代码可有可无，它的存在反而影响整体代码的整洁和可读性。</strong></p>
</blockquote>
<h2 id="1-冗余类"><a class="markdownIt-Anchor" href="#1-冗余类"></a> 1. 冗余类</h2>
<blockquote>
<p>冗余类(Lazy Class)</p>
<p>理解和维护总是费时费力的。如果一个类不值得你花费精力，它就应该被删除。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/lazy-class-1.png" alt="img" /></p>
<h3 id="11-问题原因"><a class="markdownIt-Anchor" href="#11-问题原因"></a> 1.1. 问题原因</h3>
<p>也许一个类的初始设计是一个功能完全的类，然而随着代码的变迁，变得没什么用了。<br />
又或者类起初的设计是为了支持未来的功能扩展，然而却一直未派上用场。</p>
<h3 id="12-解决方法"><a class="markdownIt-Anchor" href="#12-解决方法"></a> 1.2. 解决方法</h3>
<ul>
<li>没什么用的类可以运用 <code>将类内联化(Inline Class)</code> 来干掉。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/lazy-class-2.png" alt="img" /></p>
<ul>
<li>如果子类用处不大，试试 <code>折叠继承体系(Collapse Hierarchy)</code> 。</li>
</ul>
<h3 id="13-收益"><a class="markdownIt-Anchor" href="#13-收益"></a> 1.3. 收益</h3>
<ul>
<li>减少代码量</li>
<li>易于维护</li>
</ul>
<h3 id="14-何时忽略"><a class="markdownIt-Anchor" href="#14-何时忽略"></a> 1.4. 何时忽略</h3>
<ul>
<li>有时，创建冗余类是为了描述未来开发的意图。在这种情况下，尝试在代码中保持清晰和简单之间的平衡。</li>
</ul>
<h3 id="15-重构方法说明"><a class="markdownIt-Anchor" href="#15-重构方法说明"></a> 1.5. 重构方法说明</h3>
<h4 id="151-将类内联化inline-class"><a class="markdownIt-Anchor" href="#151-将类内联化inline-class"></a> 1.5.1. 将类内联化(Inline Class)</h4>
<p><strong>问题</strong></p>
<p>某个类没有做太多事情。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/inline-class-before.png" alt="img" /></p>
<p><strong>解决</strong></p>
<p>将这个类的所有特性搬移到另一个类中，然后移除原类。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/inline-class-after.png" alt="img" /></p>
<h4 id="152-折叠继承体系collapse-hierarchy"><a class="markdownIt-Anchor" href="#152-折叠继承体系collapse-hierarchy"></a> 1.5.2. 折叠继承体系(Collapse Hierarchy)</h4>
<p><strong>问题</strong></p>
<p>超类和子类之间无太大区别。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/collapse-hierarchy-before.png" alt="img" /></p>
<p><strong>解决</strong></p>
<p>将它们合为一体。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/collapse-hierarchy-after.png" alt="img" /></p>
<h2 id="2-夸夸其谈未来性"><a class="markdownIt-Anchor" href="#2-夸夸其谈未来性"></a> 2. 夸夸其谈未来性</h2>
<blockquote>
<p>夸夸其谈未来性(Speculative Generality)</p>
<p>存在未被使用的类、函数、字段或参数。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/speculative-generality-1.png" alt="img" /></p>
<h3 id="21-问题原因"><a class="markdownIt-Anchor" href="#21-问题原因"></a> 2.1. 问题原因</h3>
<p>有时，代码仅仅为了支持未来的特性而产生，然而却一直未实现。结果，代码变得难以理解和维护。</p>
<h3 id="22-解决方法"><a class="markdownIt-Anchor" href="#22-解决方法"></a> 2.2. 解决方法</h3>
<ul>
<li>如果你的某个抽象类其实没有太大作用，请运用 <code>折叠继承体系(Collapse Hierarch)</code> 。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/speculative-generality-2.png" alt="img" /></p>
<ul>
<li>不必要的委托可运用 <code>将类内联化(Inline Class)</code> 消除。</li>
<li>无用的函数可运用 <code>内联函数(Inline Method)</code> 消除。</li>
<li>函数中有无用的参数应该运用 <code>移除参数(Remove Parameter)</code> 消除。</li>
<li>无用字段可以直接删除。</li>
</ul>
<h3 id="23-收益"><a class="markdownIt-Anchor" href="#23-收益"></a> 2.3. 收益</h3>
<ul>
<li>减少代码量。</li>
<li>更易维护。</li>
</ul>
<h3 id="24-何时忽略"><a class="markdownIt-Anchor" href="#24-何时忽略"></a> 2.4. 何时忽略</h3>
<ul>
<li>如果你在一个框架上工作，创建框架本身没有使用的功能是非常合理的，只要框架的用户需要这个功能。</li>
<li>删除元素之前，请确保它们不在单元测试中使用。如果测试需要从类中获取某些内部信息或执行特殊的测试相关操作，就会发生这种情况。</li>
</ul>
<h3 id="25-重构方法说明"><a class="markdownIt-Anchor" href="#25-重构方法说明"></a> 2.5. 重构方法说明</h3>
<h4 id="251-折叠继承体系collapse-hierarchy"><a class="markdownIt-Anchor" href="#251-折叠继承体系collapse-hierarchy"></a> 2.5.1. 折叠继承体系(Collapse Hierarchy)</h4>
<p><strong>问题</strong></p>
<p>超类和子类之间无太大区别。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/collapse-hierarchy-before.png" alt="img" /></p>
<p><strong>解决</strong></p>
<p>将它们合为一体。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/collapse-hierarchy-after.png" alt="img" /></p>
<h4 id="252-将类内联化inline-class"><a class="markdownIt-Anchor" href="#252-将类内联化inline-class"></a> 2.5.2. 将类内联化(Inline Class)</h4>
<p><strong>问题</strong></p>
<p>某个类没有做太多事情。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/inline-class-before.png" alt="img" /></p>
<p><strong>解决</strong></p>
<p>将这个类的所有特性搬移到另一个类中，然后移除原类。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/inline-class-after.png" alt="img" /></p>
<h4 id="253-内联函数inline-method"><a class="markdownIt-Anchor" href="#253-内联函数inline-method"></a> 2.5.3. 内联函数(Inline Method)</h4>
<p><strong>问题</strong></p>
<p>一个函数的本体比函数名更清楚易懂。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PizzaDelivery</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getRating</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> moreThanFiveLateDeliveries() ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">moreThanFiveLateDeliveries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> numberOfLateDeliveries &gt; <span class="number">5</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>在函数调用点插入函数本体，然后移除该函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PizzaDelivery</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getRating</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> numberOfLateDeliveries &gt; <span class="number">5</span> ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="254-移除参数remove-parameter"><a class="markdownIt-Anchor" href="#254-移除参数remove-parameter"></a> 2.5.4. 移除参数(Remove Parameter)</h4>
<p><strong>问题</strong></p>
<p>函数本体不再需要某个参数。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/remove-parameter-before.png" alt="img" /></p>
<p><strong>解决</strong></p>
<p>将该参数去除。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/remove-parameter-after.png" alt="img" /></p>
<h2 id="3-纯稚的数据类"><a class="markdownIt-Anchor" href="#3-纯稚的数据类"></a> 3. 纯稚的数据类</h2>
<blockquote>
<p><code>纯稚的数据类(Data Class)</code> 指的是只包含字段和访问它们的 getter 和 setter 函数的类。这些仅仅是供其他类使用的数据容器。这些类不包含任何附加功能，并且不能对自己拥有的数据进行独立操作。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/data-class-1.png" alt="img" /></p>
<h3 id="31-问题原因"><a class="markdownIt-Anchor" href="#31-问题原因"></a> 3.1. 问题原因</h3>
<p>当一个新创建的类只包含几个公共字段（甚至可能几个 getters / setters）是很正常的。但是对象的真正力量在于它们可以包含作用于数据的行为类型或操作。</p>
<h3 id="32-解决方法"><a class="markdownIt-Anchor" href="#32-解决方法"></a> 3.2. 解决方法</h3>
<ul>
<li>如果一个类有公共字段，你应该运用 <code>封装字段(Encapsulated Field)</code> 来隐藏字段的直接访问方式。</li>
<li>如果这些类含容器类的字段，你应该检查它们是不是得到了恰当的封装；如果没有，就运用 <code>封装集合(Encapsulated Collection)</code> 把它们封装起来。</li>
<li>找出这些 getter/setter 函数被其他类运用的地点。尝试以 <code>搬移函数(Move Method)</code> 把那些调用行为搬移到 <code>纯稚的数据类(Data Class)</code> 来。如果无法搬移这个函数，就运用 <code>提炼函数(Extract Method)</code> 产生一个可搬移的函数。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/data-class-2.png" alt="img" /></p>
<ul>
<li>在类已经充满了深思熟虑的函数之后，你可能想要摆脱旧的数据访问方法，以提供适应面较广的类数据访问接口。为此，可以运用 <code>移除设置函数(Remove Setting Method)</code> 和 <code>隐藏函数(Hide Method)</code> 。</li>
</ul>
<h3 id="33-收益"><a class="markdownIt-Anchor" href="#33-收益"></a> 3.3. 收益</h3>
<ul>
<li>提高代码的可读性和组织性。特定数据的操作现在被集中在一个地方，而不是在分散在代码各处。</li>
<li>帮助你发现客户端代码的重复处。</li>
</ul>
<h3 id="34-重构方法说明"><a class="markdownIt-Anchor" href="#34-重构方法说明"></a> 3.4. 重构方法说明</h3>
<h4 id="341-封装字段encapsulated-field"><a class="markdownIt-Anchor" href="#341-封装字段encapsulated-field"></a> 3.4.1. 封装字段(Encapsulated Field)</h4>
<p><strong>问题</strong></p>
<p>你的类中存在 public 字段。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Person</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>将它声明为 private，并提供相应的访问函数。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">String</span> name;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">String</span> arg)</span> </span>&#123;</span><br><span class="line">    name = arg;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="342-封装集合encapsulated-collection"><a class="markdownIt-Anchor" href="#342-封装集合encapsulated-collection"></a> 3.4.2. 封装集合(Encapsulated Collection)</h4>
<p><strong>问题</strong></p>
<p>有个函数返回一个集合。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/encapsulate-collection-before.png" alt="img" /></p>
<p><strong>解决</strong></p>
<p>让该函数返回该集合的一个只读副本，并在这个类中提供添加、移除集合元素的函数。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/encapsulate-collection-after.png" alt="img" /></p>
<h4 id="343-搬移函数move-method"><a class="markdownIt-Anchor" href="#343-搬移函数move-method"></a> 3.4.3. 搬移函数(Move Method)</h4>
<p><strong>问题</strong></p>
<p>你的程序中，有个函数与其所驻类之外的另一个类进行更多交流：调用后者，或被后者调用。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/move-method-before.png" alt="img" /></p>
<p><strong>解决</strong></p>
<p>在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是旧函数完全移除。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/move-method-after.png" alt="img" /></p>
<h4 id="344-提炼函数extract-method"><a class="markdownIt-Anchor" href="#344-提炼函数extract-method"></a> 3.4.4. 提炼函数(Extract Method)</h4>
<p><strong>问题</strong></p>
<p>你有一段代码可以组织在一起。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printOwing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  printBanner();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//print details</span></span><br><span class="line">  System.out.println(<span class="string">"name: "</span> + name);</span><br><span class="line">  System.out.println(<span class="string">"amount: "</span> + getOutstanding());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>移动这段代码到一个新的函数中，使用函数的调用来替代老代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printOwing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  printBanner();</span><br><span class="line">  printDetails(getOutstanding());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDetails</span><span class="params">(<span class="keyword">double</span> outstanding)</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"name: "</span> + name);</span><br><span class="line">  System.out.println(<span class="string">"amount: "</span> + outstanding);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="345-移除设置函数remove-setting-method"><a class="markdownIt-Anchor" href="#345-移除设置函数remove-setting-method"></a> 3.4.5. 移除设置函数(Remove Setting Method)</h4>
<p><strong>问题</strong></p>
<p>类中的某个字段应该在对象创建时被设值，然后就不再改变。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/remove-setting-method-before.png" alt="img" /></p>
<p><strong>解决</strong></p>
<p>去掉该字段的所有设值函数。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/remove-setting-method-after.png" alt="img" /></p>
<h4 id="346-隐藏函数hide-method"><a class="markdownIt-Anchor" href="#346-隐藏函数hide-method"></a> 3.4.6. 隐藏函数(Hide Method)</h4>
<p><strong>问题</strong></p>
<p>有一个函数，从来没有被其他任何类用到。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/hide-method-before.png" alt="img" /></p>
<p><strong>解决</strong></p>
<p>将这个函数修改为 private。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/hide-method-after.png" alt="img" /></p>
<h2 id="4-过多的注释"><a class="markdownIt-Anchor" href="#4-过多的注释"></a> 4. 过多的注释</h2>
<blockquote>
<p>过多的注释(Comments)</p>
<p>注释本身并不是坏事。但是常常有这样的情况：一段代码中出现长长的注释，而它之所以存在，是因为代码很糟糕。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/comments-1.png" alt="img" /></p>
<h3 id="41-问题原因"><a class="markdownIt-Anchor" href="#41-问题原因"></a> 4.1. 问题原因</h3>
<p>注释的作者意识到自己的代码不直观或不明显，所以想使用注释来说明自己的意图。这种情况下，注释就像是烂代码的除臭剂。</p>
<blockquote>
<p>最好的注释是为函数或类起一个恰当的名字。</p>
</blockquote>
<p>如果你觉得一个代码片段没有注释就无法理解，请先尝试重构，试着让所有注释都变得多余。</p>
<h3 id="42-解决方法"><a class="markdownIt-Anchor" href="#42-解决方法"></a> 4.2. 解决方法</h3>
<ul>
<li>如果一个注释是为了解释一个复杂的表达式，可以运用 <code>提炼变量(Extract Variable)</code> 将表达式切分为易理解的子表达式。</li>
<li>如果你需要通过注释来解释一段代码做了什么，请试试 <code>提炼函数(Extract Method)</code> 。</li>
<li>如果函数已经被提炼，但仍需要注释函数做了什么，试试运用 <code>函数改名(Rename Method)</code> 来为函数起一个可以自解释的名字。</li>
<li>如果需要对系统某状态进行断言，请运用 <code>引入断言(Introduce Assertion)</code> 。</li>
</ul>
<h3 id="43-收益"><a class="markdownIt-Anchor" href="#43-收益"></a> 4.3. 收益</h3>
<ul>
<li>代码变得更直观和明显。</li>
</ul>
<h3 id="44-何时忽略"><a class="markdownIt-Anchor" href="#44-何时忽略"></a> 4.4. 何时忽略</h3>
<p>注释有时候很有用：</p>
<ul>
<li>当解释为什么某事物要以特殊方式实现时。</li>
<li>当解释某种复杂算法时。</li>
<li>当你实在不知可以做些什么时。</li>
</ul>
<h3 id="45-重构方法说明"><a class="markdownIt-Anchor" href="#45-重构方法说明"></a> 4.5. 重构方法说明</h3>
<h4 id="451-提炼变量extract-variable"><a class="markdownIt-Anchor" href="#451-提炼变量extract-variable"></a> 4.5.1. 提炼变量(Extract Variable)</h4>
<p><strong>问题</strong></p>
<p>你有个难以理解的表达式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">renderBanner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ((platform.toUpperCase().indexOf(<span class="string">"MAC"</span>) &gt; -<span class="number">1</span>) &amp;&amp;</span><br><span class="line">       (browser.toUpperCase().indexOf(<span class="string">"IE"</span>) &gt; -<span class="number">1</span>) &amp;&amp;</span><br><span class="line">        wasInitialized() &amp;&amp; resize &gt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>将表达式的结果或它的子表达式的结果用不言自明的变量来替代。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">renderBanner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">boolean</span> isMacOs = platform.toUpperCase().indexOf(<span class="string">"MAC"</span>) &gt; -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">boolean</span> isIE = browser.toUpperCase().indexOf(<span class="string">"IE"</span>) &gt; -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">boolean</span> wasResized = resize &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isMacOs &amp;&amp; isIE &amp;&amp; wasInitialized() &amp;&amp; wasResized) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="452-提炼函数extract-method"><a class="markdownIt-Anchor" href="#452-提炼函数extract-method"></a> 4.5.2. 提炼函数(Extract Method)</h4>
<p><strong>问题</strong></p>
<p>你有一段代码可以组织在一起。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printOwing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  printBanner();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//print details</span></span><br><span class="line">  System.out.println(<span class="string">"name: "</span> + name);</span><br><span class="line">  System.out.println(<span class="string">"amount: "</span> + getOutstanding());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>移动这段代码到一个新的函数中，使用函数的调用来替代老代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printOwing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  printBanner();</span><br><span class="line">  printDetails(getOutstanding());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDetails</span><span class="params">(<span class="keyword">double</span> outstanding)</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"name: "</span> + name);</span><br><span class="line">  System.out.println(<span class="string">"amount: "</span> + outstanding);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="453-函数改名rename-method"><a class="markdownIt-Anchor" href="#453-函数改名rename-method"></a> 4.5.3. 函数改名(Rename Method)</h4>
<p><strong>问题</strong></p>
<p>函数的名称未能恰当的揭示函数的用途。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getsnm</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>修改函数名。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getSecondName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="454-引入断言introduce-assertion"><a class="markdownIt-Anchor" href="#454-引入断言introduce-assertion"></a> 4.5.4. 引入断言(Introduce Assertion)</h4>
<p><strong>问题</strong></p>
<p>某一段代码需要对程序状态做出某种假设。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getExpenseLimit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// should have either expense limit or a primary project</span></span><br><span class="line">  <span class="keyword">return</span> (expenseLimit != NULL_EXPENSE) ?</span><br><span class="line">    expenseLimit:</span><br><span class="line">    primaryProject.getMemberExpenseLimit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>以断言明确表现这种假设。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getExpenseLimit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Assert.isTrue(expenseLimit != NULL_EXPENSE || primaryProject != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (expenseLimit != NULL_EXPENSE) ?</span><br><span class="line">    expenseLimit:</span><br><span class="line">    primaryProject.getMemberExpenseLimit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>注：请不要滥用断言。不要使用它来检查”应该为真“的条件，只能使用它来检查“一定必须为真”的条件。实际上，断言更多是用于自我检测代码的一种手段。在产品真正交付时，往往都会消除所有断言。</em></p>
<h2 id="5-重复代码"><a class="markdownIt-Anchor" href="#5-重复代码"></a> 5. 重复代码</h2>
<blockquote>
<p>重复代码(Duplicate Code)</p>
<p>重复代码堪称为代码坏味道之首。消除重复代码总是有利无害的。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/duplicate-code-1.png" alt="img" /></p>
<h3 id="51-问题原因"><a class="markdownIt-Anchor" href="#51-问题原因"></a> 5.1. 问题原因</h3>
<p>重复代码通常发生在多个程序员同时在同一程序的不同部分上工作时。由于他们正在处理不同的任务，他们可能不知道他们的同事已经写了类似的代码。</p>
<p>还有一种更隐晦的重复，特定部分的代码看上去不同但实际在做同一件事。这种重复代码往往难以找到和消除。</p>
<p>有时重复是有目的性的。当急于满足 deadline，并且现有代码对于要交付的任务是“几乎正确的”时，新手程序员可能无法抵抗复制和粘贴相关代码的诱惑。在某些情况下，程序员只是太懒惰。</p>
<h3 id="52-解决方法"><a class="markdownIt-Anchor" href="#52-解决方法"></a> 5.2. 解决方法</h3>
<ul>
<li>同一个类的两个函数含有相同的表达式，这时可以采用 <code>提炼函数(Extract Method)</code> 提炼出重复的代码，然后让这两个地点都调用被提炼出来的那段代码。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/duplicate-code-2.png" alt="img" /></p>
<ul>
<li>如果两个互为兄弟的子类含有重复代码：
<ul>
<li>首先对两个类都运用 <code>提炼函数(Extract Method)</code> ，然后对被提炼出来的函数运用 <code>函数上移(Pull Up Method)</code> ，将它推入超类。</li>
<li>如果重复代码在构造函数中，运用 <code>构造函数本体上移(Pull Up Constructor Body)</code> 。</li>
<li>如果重复代码只是相似但不是完全相同，运用 <code>塑造模板函数(Form Template Method)</code> 获得一个 <strong>模板方法模式(Template Method)</strong> 。</li>
<li>如果有些函数以不同的算法做相同的事，你可以选择其中较清晰地一个，并运用 <code>替换算法(Substitute Algorithm)</code> 将其他函数的算法替换掉。</li>
</ul>
</li>
<li>如果两个毫不相关的类中有重复代码：
<ul>
<li>请尝试运用 <code>提炼超类(Extract Superclass)</code> ，以便为维护所有先前功能的这些类创建一个超类。</li>
<li>如果创建超类十分困难，可以在一个类中运用 <code>提炼类(Extract Class)</code> ，并在另一个类中使用这个新的组件。</li>
</ul>
</li>
<li>如果存在大量的条件表达式，并且它们执行完全相同的代码（仅仅是它们的条件不同），可以运用 <code>合并条件表达式(Consolidate Conditional Expression)</code> 将这些操作合并为单个条件，并运用 <code>提炼函数(Extract Method)</code> 将该条件放入一个名字容易理解的独立函数中。</li>
<li>如果条件表达式的所有分支都有部分相同的代码片段：可以运用 <code>合并重复的条件片段(Consolidate Duplicate Conditional Fragments)</code> 将它们都存在的代码片段置于条件表达式外部。</li>
</ul>
<h3 id="53-收益"><a class="markdownIt-Anchor" href="#53-收益"></a> 5.3. 收益</h3>
<ul>
<li>合并重复代码会简化代码的结构，并减少代码量。</li>
<li>代码更简化、更易维护。</li>
</ul>
<h3 id="54-重构方法说明"><a class="markdownIt-Anchor" href="#54-重构方法说明"></a> 5.4. 重构方法说明</h3>
<h4 id="541-提炼函数extract-method"><a class="markdownIt-Anchor" href="#541-提炼函数extract-method"></a> 5.4.1. 提炼函数(Extract Method)</h4>
<p><strong>问题</strong></p>
<p>你有一段代码可以组织在一起。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printOwing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  printBanner();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//print details</span></span><br><span class="line">  System.out.println(<span class="string">"name: "</span> + name);</span><br><span class="line">  System.out.println(<span class="string">"amount: "</span> + getOutstanding());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>移动这段代码到一个新的函数中，使用函数的调用来替代老代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printOwing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  printBanner();</span><br><span class="line">  printDetails(getOutstanding());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDetails</span><span class="params">(<span class="keyword">double</span> outstanding)</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"name: "</span> + name);</span><br><span class="line">  System.out.println(<span class="string">"amount: "</span> + outstanding);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="542-函数上移pull-up-method"><a class="markdownIt-Anchor" href="#542-函数上移pull-up-method"></a> 5.4.2. 函数上移(Pull Up Method)</h4>
<p><strong>问题</strong></p>
<p>有些函数，在各个子类中产生完全相同的结果。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/pull-up-method-before.png" alt="img" /></p>
<p><strong>解决</strong></p>
<p>将该函数移至超类。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/pull-up-method-after.png" alt="img" /></p>
<h4 id="543-构造函数本体上移pull-up-constructor-body"><a class="markdownIt-Anchor" href="#543-构造函数本体上移pull-up-constructor-body"></a> 5.4.3. 构造函数本体上移(Pull Up Constructor Body)</h4>
<p><strong>问题</strong></p>
<p>你在各个子类中拥有一些构造函数，它们的本体几乎完全一致。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Manager</span><span class="params">(String name, String id, <span class="keyword">int</span> grade)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">    <span class="keyword">this</span>.grade = grade;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>在超类中新建一个构造函数，并在子类构造函数中调用它。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Manager</span><span class="params">(String name, String id, <span class="keyword">int</span> grade)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(name, id);</span><br><span class="line">    <span class="keyword">this</span>.grade = grade;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="544-塑造模板函数form-template-method"><a class="markdownIt-Anchor" href="#544-塑造模板函数form-template-method"></a> 5.4.4. 塑造模板函数(Form Template Method)</h4>
<p><strong>问题</strong></p>
<p>你有一些子类，其中相应的某些函数以相同的顺序执行类似的操作，但各个操作的细节上有所不同。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/form-template-method-before.png" alt="img" /></p>
<p><strong>解决</strong></p>
<p>将这些操作分别放进独立函数中，并保持它们都有相同的签名，于是原函数也就变得相同了。然后将原函数上移至超类。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/form-template-method-after.png" alt="img" /></p>
<p><em>注：这里只提到具体做法，建议了解一下模板方法设计模式。</em></p>
<h4 id="545-替换算法substitute-algorithm"><a class="markdownIt-Anchor" href="#545-替换算法substitute-algorithm"></a> 5.4.5. 替换算法(Substitute Algorithm)</h4>
<p><strong>问题</strong></p>
<p>你想要把某个算法替换为另一个更清晰的算法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">foundPerson</span><span class="params">(String[] people)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; people.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (people[i].equals(<span class="string">"Don"</span>))&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Don"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (people[i].equals(<span class="string">"John"</span>))&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"John"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (people[i].equals(<span class="string">"Kent"</span>))&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Kent"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>将函数本体替换为另一个算法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">foundPerson</span><span class="params">(String[] people)</span></span>&#123;</span><br><span class="line">  List candidates =</span><br><span class="line">    Arrays.asList(<span class="keyword">new</span> String[] &#123;<span class="string">"Don"</span>, <span class="string">"John"</span>, <span class="string">"Kent"</span>&#125;);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; people.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (candidates.contains(people[i])) &#123;</span><br><span class="line">      <span class="keyword">return</span> people[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="546-提炼超类extract-superclass"><a class="markdownIt-Anchor" href="#546-提炼超类extract-superclass"></a> 5.4.6. 提炼超类(Extract Superclass)</h4>
<p><strong>问题</strong></p>
<p>两个类有相似特性。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/extract-superclass-before.png" alt="img" /></p>
<p><strong>解决</strong></p>
<p>为这两个类建立一个超类，将相同特性移至超类。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/extract-superclass-after.png" alt="img" /></p>
<h4 id="547-提炼类extract-class"><a class="markdownIt-Anchor" href="#547-提炼类extract-class"></a> 5.4.7. 提炼类(Extract Class)</h4>
<p><strong>问题</strong></p>
<p>某个类做了不止一件事。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/extract-class-before.png" alt="img" /></p>
<p><strong>解决</strong></p>
<p>建立一个新类，将相关的字段和函数从旧类搬移到新类。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/extract-class-after.png" alt="img" /></p>
<h4 id="548-合并条件表达式consolidate-conditional-expression"><a class="markdownIt-Anchor" href="#548-合并条件表达式consolidate-conditional-expression"></a> 5.4.8. 合并条件表达式(Consolidate Conditional Expression)</h4>
<p><strong>问题</strong></p>
<p>你有一系列条件分支，都得到相同结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">disabilityAmount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (seniority &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (monthsDisabled &gt; <span class="number">12</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isPartTime) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// compute the disability amount</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>将这些条件分支合并为一个条件，并将这个条件提炼为一个独立函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">disabilityAmount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isNotEligableForDisability()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// compute the disability amount</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="549-合并重复的条件片段consolidate-duplicate-conditional-fragments"><a class="markdownIt-Anchor" href="#549-合并重复的条件片段consolidate-duplicate-conditional-fragments"></a> 5.4.9. 合并重复的条件片段(Consolidate Duplicate Conditional Fragments)</h4>
<p><strong>问题</strong></p>
<p>在条件表达式的每个分支上有着相同的一段代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (isSpecialDeal()) &#123;</span><br><span class="line">  total = price * <span class="number">0.95</span>;</span><br><span class="line">  send();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  total = price * <span class="number">0.98</span>;</span><br><span class="line">  send();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>将这段重复代码搬移到条件表达式之外。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (isSpecialDeal()) &#123;</span><br><span class="line">  total = price * <span class="number">0.95</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  total = price * <span class="number">0.98</span>;</span><br><span class="line">&#125;</span><br><span class="line">send();</span><br></pre></td></tr></table></figure>
<h2 id="6-扩展阅读"><a class="markdownIt-Anchor" href="#6-扩展阅读"></a> 6. 扩展阅读</h2>
<ul>
<li><a href="https://github.com/dunwu/design/blob/master/docs/refactor/" target="_blank" rel="noopener">代码的坏味道和重构</a></li>
<li><a href="https://github.com/dunwu/design/blob/master/docs/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E4%BB%A3%E7%A0%81%E8%87%83%E8%82%BF.md" target="_blank" rel="noopener">代码坏味道之代码臃肿</a></li>
<li><a href="https://github.com/dunwu/design/blob/master/docs/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E6%BB%A5%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.md" target="_blank" rel="noopener">代码坏味道之滥用面向对象</a></li>
<li><a href="https://github.com/dunwu/design/blob/master/docs/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E5%8F%98%E9%9D%A9%E7%9A%84%E9%9A%9C%E7%A2%8D.md" target="_blank" rel="noopener">代码坏味道之变革的障碍</a></li>
<li><a href="https://github.com/dunwu/design/blob/master/docs/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E9%9D%9E%E5%BF%85%E8%A6%81%E7%9A%84.md" target="_blank" rel="noopener">代码坏味道之非必要的</a></li>
<li><a href="https://github.com/dunwu/design/blob/master/docs/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E8%80%A6%E5%90%88.md" target="_blank" rel="noopener">代码坏味道之耦合</a></li>
</ul>
<h2 id="7-参考资料"><a class="markdownIt-Anchor" href="#7-参考资料"></a> 7. 参考资料</h2>
<ul>
<li><a href="https://book.douban.com/subject/4199741/" target="_blank" rel="noopener">《代码整洁之道》</a></li>
<li><a href="https://book.douban.com/subject/4262627/" target="_blank" rel="noopener">《重构 - 改善既有代码的设计》</a></li>
<li><a href="https://book.douban.com/subject/1477390/" target="_blank" rel="noopener">《代码大全》</a></li>
<li><a href="https://sourcemaking.com/refactoring" target="_blank" rel="noopener">https://sourcemaking.com/refactoring</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/2018/10/13/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E8%80%A6%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2018/10/13/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E8%80%A6%E5%90%88/" class="post-title-link" itemprop="url">代码坏味道之耦合</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-13 22:48:00" itemprop="dateCreated datePublished" datetime="2018-10-13T22:48:00+08:00">2018-10-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-14 16:45:53" itemprop="dateModified" datetime="2022-04-14T16:45:53+08:00">2022-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index">
                    <span itemprop="name">设计</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/%E9%87%8D%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">重构</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2018/10/13/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E8%80%A6%E5%90%88/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/10/13/代码坏味道之耦合/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>翻译自：<a href="https://sourcemaking.com/refactoring/smells/couplers" target="_blank" rel="noopener">https://sourcemaking.com/refactoring/smells/couplers</a></p>
<p><strong>耦合(Couplers)这组坏味道意味着：不同类之间过度耦合。</strong></p>
</blockquote>
<h2 id="不完美的库类"><a class="markdownIt-Anchor" href="#不完美的库类"></a> 不完美的库类</h2>
<blockquote>
<p>不完美的库类(Incomplete Library Class)</p>
<p>当一个类库已经不能满足实际需要时，你就不得不改变这个库（如果这个库是只读的，那就没辙了）。</p>
</blockquote>
<h3 id="问题原因"><a class="markdownIt-Anchor" href="#问题原因"></a> 问题原因</h3>
<p>许多编程技术都建立在库类的基础上。库类的作者没用未卜先知的能力，不能因此责怪他们。麻烦的是库往往构造的不够好，而且往往不可能让我们修改其中的类以满足我们的需要。</p>
<h3 id="解决方法"><a class="markdownIt-Anchor" href="#解决方法"></a> 解决方法</h3>
<ul>
<li>如果你只想修改类库的一两个函数，可以运用 <code>引入外加函数(Introduce Foreign Method)</code>；</li>
<li>如果想要添加一大堆额外行为，就得运用 <code>引入本地扩展(Introduce Local Extension)</code> 。</li>
</ul>
<h3 id="收益"><a class="markdownIt-Anchor" href="#收益"></a> 收益</h3>
<ul>
<li>减少代码重复（你不用一言不合就自己动手实现一个库的全部功能，代价太高）</li>
</ul>
<h3 id="何时忽略"><a class="markdownIt-Anchor" href="#何时忽略"></a> 何时忽略</h3>
<ul>
<li>如果扩展库会带来额外的工作量。</li>
</ul>
<h3 id="重构方法说明"><a class="markdownIt-Anchor" href="#重构方法说明"></a> 重构方法说明</h3>
<h4 id="引入外加函数introduce-foreign-method"><a class="markdownIt-Anchor" href="#引入外加函数introduce-foreign-method"></a> 引入外加函数(Introduce Foreign Method)</h4>
<p><strong>问题</strong></p>
<p>你需要为提供服务的类增加一个函数，但你无法修改这个类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Report</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">sendReport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Date nextDay = <span class="keyword">new</span> Date(previousEnd.getYear(),</span><br><span class="line">      previousEnd.getMonth(), previousEnd.getDate() + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>在客户类中建立一个函数，并一个第一个参数形式传入一个服务类实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Report</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">sendReport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Date newStart = nextDay(previousEnd);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Date <span class="title">nextDay</span><span class="params">(Date arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Date(arg.getYear(), arg.getMonth(), arg.getDate() + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="引入本地扩展introduce-local-extension"><a class="markdownIt-Anchor" href="#引入本地扩展introduce-local-extension"></a> 引入本地扩展(Introduce Local Extension)</h4>
<p><strong>问题</strong></p>
<p>你需要为服务类提供一些额外函数，但你无法修改这个类。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/introduce-local-extension-before.png" alt="img" /></p>
<p><strong>解决</strong></p>
<p>建立一个新类，使它包含这些额外函数，让这个扩展品成为源类的子类或包装类。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/introduce-local-extension-after.png" alt="img" /></p>
<h2 id="中间人"><a class="markdownIt-Anchor" href="#中间人"></a> 中间人</h2>
<blockquote>
<p>中间人(Middle Man)</p>
<p>如果一个类的作用仅仅是指向另一个类的委托，为什么要存在呢？</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/middle-man-1.png" alt="img" /></p>
<h3 id="问题原因-2"><a class="markdownIt-Anchor" href="#问题原因-2"></a> 问题原因</h3>
<p>对象的基本特征之一就是封装：对外部世界隐藏其内部细节。封装往往伴随委托。但是人们可能过度运用委托。比如，你也许会看到一个类的大部分有用工作都委托给了其他类，类本身成了一个空壳，除了委托之外不做任何事情。</p>
<h3 id="解决方法-2"><a class="markdownIt-Anchor" href="#解决方法-2"></a> 解决方法</h3>
<p>应该运用 <code>移除中间人(Remove Middle Man)</code>，直接和真正负责的对象打交道。</p>
<h3 id="收益-2"><a class="markdownIt-Anchor" href="#收益-2"></a> 收益</h3>
<ul>
<li>减少笨重的代码。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/middle-man-2.png" alt="img" /></p>
<h3 id="何时忽略-2"><a class="markdownIt-Anchor" href="#何时忽略-2"></a> 何时忽略</h3>
<p>如果是以下情况，不要删除已创建的中间人：</p>
<ul>
<li>添加中间人是为了避免类之间依赖关系。</li>
<li>一些设计模式有目的地创建中间人（例如代理模式和装饰器模式）。</li>
</ul>
<h3 id="重构方法说明-2"><a class="markdownIt-Anchor" href="#重构方法说明-2"></a> 重构方法说明</h3>
<h4 id="移除中间人remove-middle-man"><a class="markdownIt-Anchor" href="#移除中间人remove-middle-man"></a> 移除中间人(Remove Middle Man)</h4>
<p><strong>问题</strong></p>
<p>某个类做了过多的简单委托动作。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/remove-middle-man-before.png" alt="img" /></p>
<p><strong>解决</strong></p>
<p>让客户直接调用委托类。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/remove-middle-man-after.png" alt="img" /></p>
<h2 id="依恋情结"><a class="markdownIt-Anchor" href="#依恋情结"></a> 依恋情结</h2>
<blockquote>
<p>依恋情结(Feature Envy)</p>
<p>一个函数访问其它对象的数据比访问自己的数据更多。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/feature-envy-1.png" alt="img" /></p>
<h3 id="问题原因-3"><a class="markdownIt-Anchor" href="#问题原因-3"></a> 问题原因</h3>
<p>这种气味可能发生在字段移动到数据类之后。如果是这种情况，你可能想将数据类的操作移动到这个类中。</p>
<h3 id="解决方法-3"><a class="markdownIt-Anchor" href="#解决方法-3"></a> 解决方法</h3>
<p>As a basic rule, if things change at the same time, you should keep them in the same place. Usually data and functions that use this data are changed together (although exceptions are possible).</p>
<p>有一个基本原则：同时会发生改变的事情应该被放在同一个地方。通常，数据和使用这些数据的函数是一起改变的。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/feature-envy-2.png" alt="img" /></p>
<ul>
<li>如果一个函数明显应该被移到另一个地方，可运用 <code>搬移函数(Move Method)</code> 。</li>
<li>如果仅仅是函数的部分代码访问另一个对象的数据，运用 <code>提炼函数(Extract Method)</code> 将这部分代码移到独立的函数中。</li>
<li>如果一个方法使用来自其他几个类的函数，首先确定哪个类包含大多数使用的数据。然后，将该方法与其他数据一起放在此类中。或者，使用 <code>提炼函数(Extract Method)</code> 将方法拆分为几个部分，可以放置在不同类中的不同位置。</li>
</ul>
<h3 id="收益-3"><a class="markdownIt-Anchor" href="#收益-3"></a> 收益</h3>
<ul>
<li>减少重复代码（如果数据处理的代码放在中心位置）。</li>
<li>更好的代码组织性（处理数据的函数靠近实际数据）。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/feature-envy-3.png" alt="img" /></p>
<h3 id="何时忽略-3"><a class="markdownIt-Anchor" href="#何时忽略-3"></a> 何时忽略</h3>
<ul>
<li>有时，行为被有意地与保存数据的类分开。这通常的优点是能够动态地改变行为（见策略设计模式，访问者设计模式和其他模式）。</li>
</ul>
<h3 id="重构方法说明-3"><a class="markdownIt-Anchor" href="#重构方法说明-3"></a> 重构方法说明</h3>
<h4 id="搬移函数move-method"><a class="markdownIt-Anchor" href="#搬移函数move-method"></a> 搬移函数(Move Method)</h4>
<p><strong>问题</strong></p>
<p>你的程序中，有个函数与其所驻类之外的另一个类进行更多交流：调用后者，或被后者调用。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/move-method-before.png" alt="img" /></p>
<p><strong>解决</strong></p>
<p>在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是旧函数完全移除。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/move-method-after.png" alt="img" /></p>
<h4 id="提炼函数extract-method"><a class="markdownIt-Anchor" href="#提炼函数extract-method"></a> 提炼函数(Extract Method)</h4>
<p><strong>问题</strong></p>
<p>你有一段代码可以组织在一起。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printOwing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  printBanner();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//print details</span></span><br><span class="line">  System.out.println(<span class="string">"name: "</span> + name);</span><br><span class="line">  System.out.println(<span class="string">"amount: "</span> + getOutstanding());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>移动这段代码到一个新的函数中，使用函数的调用来替代老代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printOwing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  printBanner();</span><br><span class="line">  printDetails(getOutstanding());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDetails</span><span class="params">(<span class="keyword">double</span> outstanding)</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"name: "</span> + name);</span><br><span class="line">  System.out.println(<span class="string">"amount: "</span> + outstanding);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="狎昵关系"><a class="markdownIt-Anchor" href="#狎昵关系"></a> 狎昵关系</h2>
<blockquote>
<p>狎昵关系(Inappropriate Intimacy)</p>
<p>一个类大量使用另一个类的内部字段和方法。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/inappropriate-intimacy-1.png" alt="img" /></p>
<h3 id="问题原因-4"><a class="markdownIt-Anchor" href="#问题原因-4"></a> 问题原因</h3>
<p>类和类之间应该尽量少的感知彼此（减少耦合）。这样的类更容易维护和复用。</p>
<h3 id="解决方法-4"><a class="markdownIt-Anchor" href="#解决方法-4"></a> 解决方法</h3>
<ul>
<li>最简单的解决方法是运用 <code>搬移函数(Move Method)</code> 和 <code>搬移字段(Move Field)</code> 来让类之间斩断羁绊。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/inappropriate-intimacy-2.png" alt="img" /></p>
<ul>
<li>
<p>你也可以看看是否能运用 <code>将双向关联改为单向关联(Change Bidirectional Association to Unidirectional)</code> 让其中一个类对另一个说分手。</p>
</li>
<li>
<p>如果这两个类实在是情比金坚，难分难舍，可以运用 <code>提炼类(Extract Class)</code> 把二者共同点提炼到一个新类中，让它们产生爱的结晶。或者，可以尝试运用 <code>隐藏委托关系(Hide Delegate)</code> 让另一个类来为它们牵线搭桥。</p>
</li>
<li>
<p>继承往往造成类之间过分紧密，因为子类对超类的了解总是超过后者的主观愿望，如果你觉得该让这个子类自己闯荡，请运用 <code>以委托取代继承(Replace Inheritance with Delegation)</code> 来让超类和子类分家。</p>
</li>
</ul>
<h3 id="收益-4"><a class="markdownIt-Anchor" href="#收益-4"></a> 收益</h3>
<ul>
<li>提高代码组织性。</li>
<li>提高代码复用性。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/inappropriate-intimacy-3.png" alt="img" /></p>
<h3 id="重构方法说明-4"><a class="markdownIt-Anchor" href="#重构方法说明-4"></a> 重构方法说明</h3>
<h4 id="搬移函数move-method-2"><a class="markdownIt-Anchor" href="#搬移函数move-method-2"></a> 搬移函数(Move Method)</h4>
<p><strong>问题</strong></p>
<p>你的程序中，有个函数与其所驻类之外的另一个类进行更多交流：调用后者，或被后者调用。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/move-method-before.png" alt="img" /></p>
<p><strong>解决</strong></p>
<p>在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是旧函数完全移除。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/move-method-after.png" alt="img" /></p>
<h4 id="搬移字段move-field"><a class="markdownIt-Anchor" href="#搬移字段move-field"></a> 搬移字段(Move Field)</h4>
<p><strong>问题</strong></p>
<p>在你的程序中，某个字段被其所驻类之外的另一个类更多地用到。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/move-field-before.png" alt="img" /></p>
<p><strong>解决</strong></p>
<p>在目标类新建一个字段，修改源字段的所有用户，令他们改用新字段。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/move-field-after.png" alt="img" /></p>
<h4 id="将双向关联改为单向关联change-bidirectional-association-to-unidirectional"><a class="markdownIt-Anchor" href="#将双向关联改为单向关联change-bidirectional-association-to-unidirectional"></a> 将双向关联改为单向关联(Change Bidirectional Association to Unidirectional)</h4>
<p><strong>问题</strong></p>
<p>两个类之间有双向关联，但其中一个类如今不再需要另一个类的特性。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/change-bidirectional-association-to-unidirectional-before.png" alt="img" /></p>
<p><strong>解决</strong></p>
<p>去除不必要的关联。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/change-bidirectional-association-to-unidirectional-after.png" alt="img" /></p>
<h4 id="提炼类extract-class"><a class="markdownIt-Anchor" href="#提炼类extract-class"></a> 提炼类(Extract Class)</h4>
<p><strong>问题</strong></p>
<p>某个类做了不止一件事。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/extract-class-before.png" alt="img" /></p>
<p><strong>解决</strong></p>
<p>建立一个新类，将相关的字段和函数从旧类搬移到新类。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/extract-class-after.png" alt="img" /></p>
<h4 id="隐藏委托关系hide-delegate"><a class="markdownIt-Anchor" href="#隐藏委托关系hide-delegate"></a> 隐藏委托关系(Hide Delegate)</h4>
<p><strong>问题</strong></p>
<p>客户通过一个委托类来调用另一个对象。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/hide-delegate-before.png" alt="img" /></p>
<p><strong>解决</strong></p>
<p>在服务类上建立客户所需的所有函数，用以隐藏委托关系。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/hide-delegate-after.png" alt="img" /></p>
<h4 id="以委托取代继承replace-inheritance-with-delegation"><a class="markdownIt-Anchor" href="#以委托取代继承replace-inheritance-with-delegation"></a> 以委托取代继承(Replace Inheritance with Delegation)</h4>
<p><strong>问题</strong></p>
<p>某个子类只使用超类接口中的一部分，或是根本不需要继承而来的数据。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/replace-delegation-with-inheritance-before.png" alt="img" /></p>
<p><strong>解决</strong></p>
<p>在子类中新建一个字段用以保存超类；调整子类函数，令它改而委托超类；然后去掉两者之间的继承关系。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/replace-delegation-with-inheritance-after.png" alt="img" /></p>
<h2 id="过度耦合的消息链"><a class="markdownIt-Anchor" href="#过度耦合的消息链"></a> 过度耦合的消息链</h2>
<blockquote>
<p>过度耦合的消息链(Message Chains)</p>
<p>消息链的形式类似于：<code>obj.getA().getB().getC()</code>。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/message-chains-1.png" alt="img" /></p>
<h3 id="问题原因-5"><a class="markdownIt-Anchor" href="#问题原因-5"></a> 问题原因</h3>
<p>如果你看到用户向一个对象请求另一个对象，然后再向后者请求另一个对象，然后再请求另一个对象……这就是消息链。实际代码中你看到的可能是一长串 getThis()或一长串临时变量。采取这种方式，意味客户代码将与查找过程中的导航紧密耦合。一旦对象间关系发生任何变化，客户端就不得不做出相应的修改。</p>
<h3 id="解决方法-5"><a class="markdownIt-Anchor" href="#解决方法-5"></a> 解决方法</h3>
<ul>
<li>可以运用 <code>隐藏委托关系(Hide Delegate)</code> 删除一个消息链。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/message-chains-2.png" alt="img" /></p>
<ul>
<li>有时更好的选择是：先观察消息链最终得到的对象是用来干什么的。看看能否以 <code>提炼函数(Extract Method)</code>把使用该对象的代码提炼到一个独立函数中，再运用 <code>搬移函数(Move Method)</code> 把这个函数推入消息链。</li>
</ul>
<h3 id="收益-5"><a class="markdownIt-Anchor" href="#收益-5"></a> 收益</h3>
<ul>
<li>能减少链中类之间的依赖。</li>
<li>能减少代码量。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/message-chains-3.png" alt="img" /></p>
<h3 id="何时忽略-4"><a class="markdownIt-Anchor" href="#何时忽略-4"></a> 何时忽略</h3>
<ul>
<li>过于侵略性的委托可能会使程序员难以理解功能是如何触发的。</li>
</ul>
<h3 id="重构方法说明-5"><a class="markdownIt-Anchor" href="#重构方法说明-5"></a> 重构方法说明</h3>
<h4 id="隐藏委托关系hide-delegate-2"><a class="markdownIt-Anchor" href="#隐藏委托关系hide-delegate-2"></a> 隐藏委托关系(Hide Delegate)</h4>
<p><strong>问题</strong></p>
<p>客户通过一个委托类来调用另一个对象。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/hide-delegate-before.png" alt="img" /></p>
<p><strong>解决</strong></p>
<p>在服务类上建立客户所需的所有函数，用以隐藏委托关系。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/hide-delegate-after.png" alt="img" /></p>
<h4 id="提炼函数extract-method-2"><a class="markdownIt-Anchor" href="#提炼函数extract-method-2"></a> 提炼函数(Extract Method)</h4>
<p><strong>问题</strong></p>
<p>你有一段代码可以组织在一起。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printOwing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  printBanner();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//print details</span></span><br><span class="line">  System.out.println(<span class="string">"name: "</span> + name);</span><br><span class="line">  System.out.println(<span class="string">"amount: "</span> + getOutstanding());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong></p>
<p>移动这段代码到一个新的函数中，使用函数的调用来替代老代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printOwing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  printBanner();</span><br><span class="line">  printDetails(getOutstanding());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDetails</span><span class="params">(<span class="keyword">double</span> outstanding)</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"name: "</span> + name);</span><br><span class="line">  System.out.println(<span class="string">"amount: "</span> + outstanding);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="搬移函数move-method-3"><a class="markdownIt-Anchor" href="#搬移函数move-method-3"></a> 搬移函数(Move Method)</h4>
<p><strong>问题</strong></p>
<p>你的程序中，有个函数与其所驻类之外的另一个类进行更多交流：调用后者，或被后者调用。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/move-method-before.png" alt="img" /></p>
<p><strong>解决</strong></p>
<p>在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是旧函数完全移除。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/refactor/move-method-after.png" alt="img" /></p>
<h2 id="扩展阅读"><a class="markdownIt-Anchor" href="#扩展阅读"></a> 扩展阅读</h2>
<ul>
<li><a href="https://github.com/dunwu/design/blob/master/docs/refactor/" target="_blank" rel="noopener">代码的坏味道和重构</a></li>
<li><a href="https://github.com/dunwu/design/blob/master/docs/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E4%BB%A3%E7%A0%81%E8%87%83%E8%82%BF.md" target="_blank" rel="noopener">代码坏味道之代码臃肿</a></li>
<li><a href="https://github.com/dunwu/design/blob/master/docs/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E6%BB%A5%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.md" target="_blank" rel="noopener">代码坏味道之滥用面向对象</a></li>
<li><a href="https://github.com/dunwu/design/blob/master/docs/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E5%8F%98%E9%9D%A9%E7%9A%84%E9%9A%9C%E7%A2%8D.md" target="_blank" rel="noopener">代码坏味道之变革的障碍</a></li>
<li><a href="https://github.com/dunwu/design/blob/master/docs/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E9%9D%9E%E5%BF%85%E8%A6%81%E7%9A%84.md" target="_blank" rel="noopener">代码坏味道之非必要的</a></li>
<li><a href="https://github.com/dunwu/design/blob/master/docs/refactor/%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E8%80%A6%E5%90%88.md" target="_blank" rel="noopener">代码坏味道之耦合</a></li>
</ul>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><a href="https://book.douban.com/subject/4199741/" target="_blank" rel="noopener">《代码整洁之道》</a></li>
<li><a href="https://book.douban.com/subject/4262627/" target="_blank" rel="noopener">《重构 - 改善既有代码的设计》</a></li>
<li><a href="https://book.douban.com/subject/1477390/" target="_blank" rel="noopener">《代码大全》</a></li>
<li><a href="https://sourcemaking.com/refactoring" target="_blank" rel="noopener">https://sourcemaking.com/refactoring</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/2018/10/11/kong/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2018/10/11/kong/" class="post-title-link" itemprop="url">kong</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-11 13:08:18" itemprop="dateCreated datePublished" datetime="2018-10-11T13:08:18+08:00">2018-10-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-14 16:45:53" itemprop="dateModified" datetime="2022-04-14T16:45:53+08:00">2022-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BA%94%E7%94%A8/" itemprop="url" rel="index">
                    <span itemprop="name">分布式应用</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BA%94%E7%94%A8/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" itemprop="url" rel="index">
                    <span itemprop="name">微服务</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2018/10/11/kong/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/10/11/kong/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="kong"><a class="markdownIt-Anchor" href="#kong"></a> Kong</h1>
<blockquote>
<p><a href="https://github.com/Kong/kong" target="_blank" rel="noopener">Kong</a> 是一个云原生、快速、可扩展和分布式的微服务抽象层（也称为 API 网关，API 中间件）。</p>
<p>关键词：<code>nginx</code>,<code>api网关</code>,<code>微服务</code></p>
</blockquote>
<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2>
<h3 id="为什么选择-kong"><a class="markdownIt-Anchor" href="#为什么选择-kong"></a> 为什么选择 Kong</h3>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/images/microservices/kong/why-kong.png"/></div><br></p>
<h2 id="quickstart"><a class="markdownIt-Anchor" href="#quickstart"></a> Quickstart</h2>
<h3 id="安装配置"><a class="markdownIt-Anchor" href="#安装配置"></a> 安装配置</h3>
<blockquote>
<p>本文仅以 Centos7 为例。</p>
</blockquote>
<p>Kong 支持在多种环境下安装。</p>
<p>官方安装说明：<a href="https://konghq.com/install/" target="_blank" rel="noopener">https://konghq.com/install/</a></p>
<p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20180920181011104339.png"/></div><br></p>
<p>以下为 Centos7 安装步骤：</p>
<p>（1）下载 rpm 安装包到本地</p>
<p>（2）安装 Kong</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ sudo yum <span class="keyword">install</span> epel-<span class="keyword">release</span></span><br><span class="line">$ sudo yum <span class="keyword">install</span> kong-community-<span class="keyword">edition</span><span class="number">-0.14</span><span class="number">.1</span>.*.noarch.rpm <span class="comment">--nogpgcheck</span></span><br></pre></td></tr></table></figure>
<p>（3）准备数据库</p>
<p>Kong 需要存储数据，支持两种数据库：<a href="http://www.postgresql.org/" target="_blank" rel="noopener">PostgreSQL 9.5+</a> 和 <a href="http://cassandra.apache.org/" target="_blank" rel="noopener">Cassandra 3.x.x</a></p>
<p>本人选择了 PostgreSQL，安装方法可以参考 —— <a href="https://github.com/dunwu/database/blob/master/docs/postgresql.md#%E5%AE%89%E8%A3%85" target="_blank" rel="noopener">PostgreSQL 安装</a></p>
<p>安装 PostgreSQL 后，配置一个数据库和数据库用户：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> kong;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> kong OWNER kong;</span><br></pre></td></tr></table></figure>
<p>（4）执行 Kong 迁移</p>
<p>执行以下命令：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ kong migrations <span class="keyword">up</span> [-<span class="keyword">c</span> /path/<span class="keyword">to</span>/kong.<span class="keyword">conf</span>]</span><br></pre></td></tr></table></figure>
<p>注意：永远不应同时运行迁移；一个 Kong 节点应该只执行一次迁移。</p>
<p>（5）启动 Kong</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">$ kong <span class="keyword">start</span> [-c /<span class="type">path</span>/<span class="keyword">to</span>/kong.conf]</span><br></pre></td></tr></table></figure>
<p>（6）测试启动成功</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>curl -i <span class="symbol">http:</span>/<span class="regexp">/localhost:8001/</span></span><br></pre></td></tr></table></figure>
<p>至此，安装配置完成。</p>
<h3 id="使用-kong"><a class="markdownIt-Anchor" href="#使用-kong"></a> 使用 Kong</h3>
<ul>
<li>启动（必须确保执行过 <code>kong migrations up</code>） - <code>kong start [-c /path/to/kong.conf]</code>
<ul>
<li><code>-c /path/to/kong.conf</code> 参数用来指定用户的配置</li>
</ul>
</li>
<li>停止 - <code>kong stop</code></li>
<li>重启 - <code>kong reload</code></li>
</ul>
<h3 id="配置服务"><a class="markdownIt-Anchor" href="#配置服务"></a> 配置服务</h3>
<p>（1）添加第一个服务</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ curl -i -X POST \</span><br><span class="line">  --url http://localhost:8001/services/ \</span><br><span class="line">  --data <span class="string">'name=example-service'</span> \</span><br><span class="line">  --data <span class="string">'url=http://mockbin.org'</span></span><br></pre></td></tr></table></figure>
<p>应答类似下面形式：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">201</span> Created</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   "host":"mockbin.org",</span><br><span class="line">   "created_at":1519130509,</span><br><span class="line">   "connect_timeout":60000,</span><br><span class="line">   "id":"92956672-f5ea-4e9a-b096-667bf55bc40c",</span><br><span class="line">   "protocol":"http",</span><br><span class="line">   "name":"example-service",</span><br><span class="line">   "read_timeout":60000,</span><br><span class="line">   "port":80,</span><br><span class="line">   "path":null,</span><br><span class="line">   "updated_at":1519130509,</span><br><span class="line">   "retries":5,</span><br><span class="line">   "write_timeout":60000</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）为服务添加路由</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ curl -i -X POST \</span><br><span class="line">  --url http://localhost:8001/services/example-service/routes \</span><br><span class="line">  --data <span class="string">'hosts[]=example.com'</span></span><br></pre></td></tr></table></figure>
<p>应答类似下面形式：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">201</span> Created</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   "created_at":1519131139,</span><br><span class="line">   "strip_path":true,</span><br><span class="line">   "hosts":[</span><br><span class="line">      "example.com"</span><br><span class="line">   ],</span><br><span class="line">   "preserve_host":false,</span><br><span class="line">   "regex_priority":0,</span><br><span class="line">   "updated_at":1519131139,</span><br><span class="line">   "paths":null,</span><br><span class="line">   "service":&#123;</span><br><span class="line">      "id":"79d7ee6e-9fc7-4b95-aa3b-61d2e17e7516"</span><br><span class="line">   &#125;,</span><br><span class="line">   "methods":null,</span><br><span class="line">   "protocols":[</span><br><span class="line">      "http",</span><br><span class="line">      "https"</span><br><span class="line">   ],</span><br><span class="line">   "id":"f9ce2ed7-c06e-4e16-bd5d-3a82daef3f9d"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，Kong 已经关注这个服务，并准备代理请求。</p>
<p>（3）通过 Kong 转发请求</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ curl -i -X GET \</span><br><span class="line">  --url http://localhost:8000/ \</span><br><span class="line">  --header <span class="string">'Host: example.com'</span></span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<p><a href="https://www.itcodemonkey.com/article/5980.html" target="_blank" rel="noopener">https://www.itcodemonkey.com/article/5980.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/2018/07/10/%E5%88%86%E5%B8%83%E5%BC%8F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2018/07/10/%E5%88%86%E5%B8%83%E5%BC%8F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">分布式面试总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-10 16:02:00" itemprop="dateCreated datePublished" datetime="2018-07-10T16:02:00+08:00">2018-07-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-14 16:45:53" itemprop="dateModified" datetime="2022-04-14T16:45:53+08:00">2022-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BB%BC%E5%90%88/" itemprop="url" rel="index">
                    <span itemprop="name">分布式综合</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2018/07/10/%E5%88%86%E5%B8%83%E5%BC%8F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/07/10/分布式面试总结/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="分布式面试总结"><a class="markdownIt-Anchor" href="#分布式面试总结"></a> 分布式面试总结</h1>
<h2 id="1-分布式缓存"><a class="markdownIt-Anchor" href="#1-分布式缓存"></a> 1. 分布式缓存</h2>
<h3 id="11-redis-有什么数据类型分别用于什么场景"><a class="markdownIt-Anchor" href="#11-redis-有什么数据类型分别用于什么场景"></a> 1.1. Redis 有什么数据类型？分别用于什么场景</h3>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>可以存储的值</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>STRING</td>
<td>字符串、整数或者浮点数</td>
<td>对整个字符串或者字符串的其中一部分执行操作</br> 对整数和浮点数执行自增或者自减操作</td>
</tr>
<tr>
<td>LIST</td>
<td>列表</td>
<td>从两端压入或者弹出元素</br> 读取单个或者多个元素</br> 进行修剪，只保留一个范围内的元素</td>
</tr>
<tr>
<td>SET</td>
<td>无序集合</td>
<td>添加、获取、移除单个元素</br> 检查一个元素是否存在于集合中</br> 计算交集、并集、差集</br> 从集合里面随机获取元素</td>
</tr>
<tr>
<td>HASH</td>
<td>包含键值对的无序散列表</td>
<td>添加、获取、移除单个键值对</br> 获取所有键值对</br> 检查某个键是否存在</td>
</tr>
<tr>
<td>ZSET</td>
<td>有序集合</td>
<td>添加、获取、删除元素</br> 根据分值范围或者成员来获取元素</br> 计算一个键的排名</td>
</tr>
</tbody>
</table>
<blockquote>
<p><a href="https://redislabs.com/ebook/part-1-getting-started/chapter-1-getting-to-know-redis/1-2-what-redis-data-structures-look-like/" target="_blank" rel="noopener">What Redis data structures look like</a></p>
</blockquote>
<h3 id="12-redis-的主从复制是如何实现的"><a class="markdownIt-Anchor" href="#12-redis-的主从复制是如何实现的"></a> 1.2. Redis 的主从复制是如何实现的</h3>
<ol>
<li>从服务器连接主服务器，发送 SYNC 命令；</li>
<li>主服务器接收到 SYNC 命名后，开始执行 BGSAVE 命令生成 RDB 文件并使用缓冲区记录此后执行的所有写命令；</li>
<li>主服务器 BGSAVE 执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令；</li>
<li>从服务器收到快照文件后丢弃所有旧数据，载入收到的快照；</li>
<li>主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令；</li>
<li>从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令；</li>
</ol>
<h3 id="13-redis-的-key-是如何寻址的"><a class="markdownIt-Anchor" href="#13-redis-的-key-是如何寻址的"></a> 1.3. Redis 的 key 是如何寻址的</h3>
<h4 id="131-背景"><a class="markdownIt-Anchor" href="#131-背景"></a> 1.3.1. 背景</h4>
<p>（1）redis 中的每一个数据库，都由一个 redisDb 的结构存储。其中：</p>
<ul>
<li><a href="http://redisDb.id" target="_blank" rel="noopener">redisDb.id</a> 存储着 redis 数据库以整数表示的号码。</li>
<li>redisDb.dict 存储着该库所有的键值对数据。</li>
<li>redisDb.expires 保存着每一个键的过期时间。</li>
</ul>
<p>（2）当 redis 服务器初始化时，会预先分配 16 个数据库（该数量可以通过配置文件配置），所有数据库保存到结构 redisServer 的一个成员 redisServer.db 数组中。当我们选择数据库 select number 时，程序直接通过 redisServer.db[number] 来切换数据库。有时候当程序需要知道自己是在哪个数据库时，直接读取 <a href="http://redisDb.id" target="_blank" rel="noopener">redisDb.id</a> 即可。</p>
<p>（3）redis 的字典使用哈希表作为其底层实现。dict 类型使用的两个指向哈希表的指针，其中 0 号哈希表（ht[0]）主要用于存储数据库的所有键值，而 1 号哈希表主要用于程序对 0 号哈希表进行 rehash 时使用，rehash 一般是在添加新值时会触发，这里不做过多的赘述。所以 redis 中查找一个 key，其实就是对进行该 dict 结构中的 ht[0] 进行查找操作。</p>
<p>（4）既然是哈希，那么我们知道就会有哈希碰撞，那么当多个键哈希之后为同一个值怎么办呢？redis 采取链表的方式来存储多个哈希碰撞的键。也就是说，当根据 key 的哈希值找到该列表后，如果列表的长度大于 1，那么我们需要遍历该链表来找到我们所查找的 key。当然，一般情况下链表长度都为是 1，所以时间复杂度可看作 o(1)。</p>
<h4 id="132-寻址-key-的步骤"><a class="markdownIt-Anchor" href="#132-寻址-key-的步骤"></a> 1.3.2. 寻址 key 的步骤</h4>
<ol>
<li>当拿到一个 key 后，redis 先判断当前库的 0 号哈希表是否为空，即：if (dict-&gt;ht[0].size == 0)。如果为 true 直接返回 NULL。</li>
<li>判断该 0 号哈希表是否需要 rehash，因为如果在进行 rehash，那么两个表中者有可能存储该 key。如果正在进行 rehash，将调用一次<code>_dictRehashStep</code> 方法，<code>_dictRehashStep</code> 用于对数据库字典、以及哈希键的字典进行被动 rehash，这里不作赘述。</li>
<li>计算哈希表，根据当前字典与 key 进行哈希值的计算。</li>
<li>根据哈希值与当前字典计算哈希表的索引值。</li>
<li>根据索引值在哈希表中取出链表，遍历该链表找到 key 的位置。一般情况，该链表长度为 1。</li>
<li>当 ht[0] 查找完了之后，再进行了次 rehash 判断，如果未在 rehashing，则直接结束，否则对 ht[1]重复 345 步骤。</li>
</ol>
<h3 id="14-redis-的集群模式是如何实现的"><a class="markdownIt-Anchor" href="#14-redis-的集群模式是如何实现的"></a> 1.4. Redis 的集群模式是如何实现的？</h3>
<p>Redis Cluster 是 Redis 的分布式解决方案，在 Redis 3.0 版本正式推出的。</p>
<p>Redis Cluster 去中心化，每个节点保存数据和整个集群状态，每个节点都和其他所有节点连接。</p>
<h4 id="141-redis-cluster-节点分配"><a class="markdownIt-Anchor" href="#141-redis-cluster-节点分配"></a> 1.4.1. Redis Cluster 节点分配</h4>
<p>Redis Cluster 特点：</p>
<ol>
<li>所有的 redis 节点彼此互联(PING-PONG 机制)，内部使用二进制协议优化传输速度和带宽。</li>
<li>节点的 fail 是通过集群中超过半数的节点检测失效时才生效。</li>
<li>客户端与 redis 节点直连,不需要中间 proxy 层。客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可。</li>
<li>redis-cluster 把所有的物理节点映射到[0-16383] 哈希槽 (hash slot)上（不一定是平均分配）,cluster 负责维护 node&lt;-&gt;slot&lt;-&gt;value。</li>
<li>Redis 集群预分好 16384 个桶，当需要在 Redis 集群中放置一个 key-value 时，根据 CRC16(key) mod 16384 的值，决定将一个 key 放到哪个桶中。</li>
</ol>
<h4 id="142-redis-cluster-主从模式"><a class="markdownIt-Anchor" href="#142-redis-cluster-主从模式"></a> 1.4.2. Redis Cluster 主从模式</h4>
<p>Redis Cluster 为了保证数据的高可用性，加入了主从模式。</p>
<p>一个主节点对应一个或多个从节点，主节点提供数据存取，从节点则是从主节点拉取数据备份。当这个主节点挂掉后，就会有这个从节点选取一个来充当主节点，从而保证集群不会挂掉。所以，在集群建立的时候，一定要为每个主节点都添加了从节点。</p>
<h4 id="143-redis-sentinel"><a class="markdownIt-Anchor" href="#143-redis-sentinel"></a> 1.4.3. Redis Sentinel</h4>
<p>Redis Sentinel 用于管理多个 Redis 服务器，它有三个功能：</p>
<ul>
<li><strong>监控（Monitoring）</strong> - Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。</li>
<li><strong>提醒（Notification）</strong> - 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。</li>
<li><strong>自动故障迁移（Automatic failover）</strong> - 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作， 它会将失效主服务器的其中一个从服务器升级为新的主服务器， 并让失效主服务器的其他从服务器改为复制新的主服务器； 当客户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址， 使得集群可以使用新主服务器代替失效服务器。</li>
</ul>
<p>Redis 集群中应该有奇数个节点，所以至少有三个节点。</p>
<p>哨兵监控集群中的主服务器出现故障时，需要根据 quorum 选举出一个哨兵来执行故障转移。选举需要 majority，即大多数哨兵是运行的（2 个哨兵的 majority=2，3 个哨兵的 majority=2，5 个哨兵的 majority=3，4 个哨兵的 majority=2）。</p>
<p>假设集群仅仅部署 2 个节点</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">+----+         +----+</span><br><span class="line">|<span class="string"> M1 </span>|<span class="string">---------</span>|<span class="string"> R1 </span>|</span><br><span class="line">|<span class="string"> S1 </span>|<span class="string">         </span>|<span class="string"> S2 </span>|</span><br><span class="line">+----+         +----+</span><br></pre></td></tr></table></figure>
<p>如果 M1 和 S1 所在服务器宕机，则哨兵只有 1 个，无法满足 majority 来进行选举，就不能执行故障转移。</p>
<h3 id="15-redis-如何实现分布式锁zookeeper-如何实现分布式锁比较二者优劣"><a class="markdownIt-Anchor" href="#15-redis-如何实现分布式锁zookeeper-如何实现分布式锁比较二者优劣"></a> 1.5. Redis 如何实现分布式锁？ZooKeeper 如何实现分布式锁？比较二者优劣？</h3>
<p>分布式锁的三种实现：</p>
<ul>
<li>基于数据库实现分布式锁；</li>
<li>基于缓存（Redis 等）实现分布式锁；</li>
<li>基于 Zookeeper 实现分布式锁；</li>
</ul>
<h4 id="151-数据库实现"><a class="markdownIt-Anchor" href="#151-数据库实现"></a> 1.5.1. 数据库实现</h4>
<h4 id="152-redis-实现"><a class="markdownIt-Anchor" href="#152-redis-实现"></a> 1.5.2. Redis 实现</h4>
<ol>
<li>获取锁的时候，使用 setnx 加锁，并使用 expire 命令为锁添加一个超时时间，超过该时间则自动释放锁，锁的 value 值为一个随机生成的 UUID，通过此在释放锁的时候进行判断。</li>
<li>获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。</li>
<li>释放锁的时候，通过 UUID 判断是不是该锁，若是该锁，则执行 delete 进行锁释放。</li>
</ol>
<h4 id="153-zookeeper-实现"><a class="markdownIt-Anchor" href="#153-zookeeper-实现"></a> 1.5.3. ZooKeeper 实现</h4>
<ol>
<li>创建一个目录 mylock；</li>
<li>线程 A 想获取锁就在 mylock 目录下创建临时顺序节点；</li>
<li>获取 mylock 目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；</li>
<li>线程 B 获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点；</li>
<li>线程 A 处理完，删除自己的节点，线程 B 监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。</li>
</ol>
<h4 id="154-实现对比"><a class="markdownIt-Anchor" href="#154-实现对比"></a> 1.5.4. 实现对比</h4>
<p>ZooKeeper 具备高可用、可重入、阻塞锁特性，可解决失效死锁问题。<br />
但 ZooKeeper 因为需要频繁的创建和删除节点，性能上不如 Redis 方式。</p>
<h3 id="16-redis-的持久化方式有什么优缺点持久化实现原理"><a class="markdownIt-Anchor" href="#16-redis-的持久化方式有什么优缺点持久化实现原理"></a> 1.6. Redis 的持久化方式？有什么优缺点？持久化实现原理？</h3>
<h4 id="161-rdb-快照snapshot"><a class="markdownIt-Anchor" href="#161-rdb-快照snapshot"></a> 1.6.1. RDB 快照（snapshot）</h4>
<p>将存在于某一时刻的所有数据都写入到硬盘中。</p>
<h5 id="快照的原理"><a class="markdownIt-Anchor" href="#快照的原理"></a> 快照的原理</h5>
<p>在默认情况下，Redis 将数据库快照保存在名字为 dump.rdb 的二进制文件中。你可以对 Redis 进行设置， 让它在“N 秒内数据集至少有 M 个改动”这一条件被满足时， 自动保存一次数据集。你也可以通过调用 SAVE 或者 BGSAVE，手动让 Redis 进行数据集保存操作。这种持久化方式被称为快照。</p>
<p>当 Redis 需要保存 dump.rdb 文件时， 服务器执行以下操作:</p>
<ul>
<li>Redis 创建一个子进程。</li>
<li>子进程将数据集写入到一个临时快照文件中。</li>
<li>当子进程完成对新快照文件的写入时，Redis 用新快照文件替换原来的快照文件，并删除旧的快照文件。</li>
</ul>
<p>这种工作方式使得 Redis 可以从写时复制（copy-on-write）机制中获益。</p>
<h5 id="快照的优点"><a class="markdownIt-Anchor" href="#快照的优点"></a> 快照的优点</h5>
<ul>
<li>它保存了某个时间点的数据集，非常适用于数据集的备份。</li>
<li>很方便传送到另一个远端数据中心或者亚马逊的 S3（可能加密），非常适用于灾难恢复。</li>
<li>快照在保存 RDB 文件时父进程唯一需要做的就是 fork 出一个子进程，接下来的工作全部由子进程来做，父进程不需要再做其他 IO 操作，所以快照持久化方式可以最大化 redis 的性能。</li>
<li>与 AOF 相比，在恢复大的数据集的时候，DB 方式会更快一些。</li>
</ul>
<h5 id="快照的缺点"><a class="markdownIt-Anchor" href="#快照的缺点"></a> 快照的缺点</h5>
<ul>
<li>如果你希望在 redis 意外停止工作（例如电源中断）的情况下丢失的数据最少的话，那么快照不适合你。</li>
<li>快照需要经常 fork 子进程来保存数据集到硬盘上。当数据集比较大的时候，fork 的过程是非常耗时的，可能会导致 Redis 在一些毫秒级内不能响应客户端的请求。</li>
</ul>
<h4 id="162-aof"><a class="markdownIt-Anchor" href="#162-aof"></a> 1.6.2. AOF</h4>
<p>AOF 持久化方式记录每次对服务器执行的写操作。当服务器重启的时候会重新执行这些命令来恢复原始的数据。</p>
<h4 id="163-aof-的原理"><a class="markdownIt-Anchor" href="#163-aof-的原理"></a> 1.6.3. AOF 的原理</h4>
<ul>
<li>Redis 创建一个子进程。</li>
<li>子进程开始将新 AOF 文件的内容写入到临时文件。</li>
<li>对于所有新执行的写入命令，父进程一边将它们累积到一个内存缓存中，一边将这些改动追加到现有 AOF 文件的末尾，这样样即使在重写的中途发生停机，现有的 AOF 文件也还是安全的。</li>
<li>当子进程完成重写工作时，它给父进程发送一个信号，父进程在接收到信号之后，将内存缓存中的所有数据追加到新 AOF 文件的末尾。</li>
<li>搞定！现在 Redis 原子地用新文件替换旧文件，之后所有命令都会直接追加到新 AOF 文件的末尾。</li>
</ul>
<h4 id="164-aof-的优点"><a class="markdownIt-Anchor" href="#164-aof-的优点"></a> 1.6.4. AOF 的优点</h4>
<ul>
<li>使用默认的每秒 fsync 策略，Redis 的性能依然很好(fsync 是由后台线程进行处理的,主线程会尽力处理客户端请求)，一旦出现故障，使用 AOF ，你最多丢失 1 秒的数据。</li>
<li>AOF 文件是一个只进行追加的日志文件，所以不需要写入 seek，即使由于某些原因(磁盘空间已满，写的过程中宕机等等)未执行完整的写入命令，你也也可使用 redis-check-aof 工具修复这些问题。</li>
<li>Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写：重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。整个重写操作是绝对安全的。</li>
<li>AOF 文件有序地保存了对数据库执行的所有写入操作，这些写入操作以 Redis 协议的格式保存。因此 AOF 文件的内容非常容易被人读懂，对文件进行分析（parse）也很轻松。</li>
</ul>
<h4 id="165-aof-的缺点"><a class="markdownIt-Anchor" href="#165-aof-的缺点"></a> 1.6.5. AOF 的缺点</h4>
<ul>
<li>对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。</li>
<li>根据所使用的 fsync 策略，AOF 的速度可能会慢于快照。在一般情况下，每秒 fsync 的性能依然非常高，而关闭 fsync 可以让 AOF 的速度和快照一样快，即使在高负荷之下也是如此。不过在处理巨大的写入载入时，快照可以提供更有保证的最大延迟时间（latency）。</li>
</ul>
<h3 id="17-redis-过期策略有哪些"><a class="markdownIt-Anchor" href="#17-redis-过期策略有哪些"></a> 1.7. Redis 过期策略有哪些？</h3>
<ul>
<li><strong>noeviction</strong> - 当内存使用达到阈值的时候，所有引起申请内存的命令会报错。</li>
<li><strong>allkeys-lru</strong> - 在主键空间中，优先移除最近未使用的 key。</li>
<li><strong>allkeys-random</strong> - 在主键空间中，随机移除某个 key。</li>
<li><strong>volatile-lru</strong> - 在设置了过期时间的键空间中，优先移除最近未使用的 key。</li>
<li><strong>volatile-random</strong> - 在设置了过期时间的键空间中，随机移除某个 key。</li>
<li><strong>volatile-ttl</strong> - 在设置了过期时间的键空间中，具有更早过期时间的 key 优先移除。</li>
</ul>
<h3 id="18-redis-和-memcached-有什么区别"><a class="markdownIt-Anchor" href="#18-redis-和-memcached-有什么区别"></a> 1.8. Redis 和 Memcached 有什么区别？</h3>
<p>两者都是非关系型内存键值数据库。有以下主要不同：</p>
<p><strong>数据类型</strong></p>
<ul>
<li>Memcached 仅支持字符串类型；</li>
<li>而 Redis 支持五种不同种类的数据类型，使得它可以更灵活地解决问题。</li>
</ul>
<p><strong>数据持久化</strong></p>
<ul>
<li>Memcached 不支持持久化；</li>
<li>Redis 支持两种持久化策略：RDB 快照和 AOF 日志。</li>
</ul>
<p><strong>分布式</strong></p>
<ul>
<li>Memcached 不支持分布式，只能通过在客户端使用像一致性哈希这样的分布式算法来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点。</li>
<li>Redis Cluster 实现了分布式的支持。</li>
</ul>
<p><strong>内存管理机制</strong></p>
<ul>
<li>Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题，但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。</li>
<li>在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘。而 Memcached 的数据则会一直在内存中。</li>
</ul>
<h3 id="19-为什么单线程的-redis-性能反而优于多线程的-memcached"><a class="markdownIt-Anchor" href="#19-为什么单线程的-redis-性能反而优于多线程的-memcached"></a> 1.9. 为什么单线程的 Redis 性能反而优于多线程的 Memcached？</h3>
<p>Redis 快速的原因：</p>
<ol>
<li>绝大部分请求是纯粹的内存操作（非常快速）</li>
<li>采用单线程,避免了不必要的上下文切换和竞争条件</li>
<li>非阻塞 IO</li>
</ol>
<p>内部实现采用 epoll，采用了 epoll+自己实现的简单的事件框架。epoll 中的读、写、关闭、连接都转化成了事件，然后利用 epoll 的多路复用特性，绝不在 io 上浪费一点时间。</p>
<h2 id="2-分布式消息队列mq"><a class="markdownIt-Anchor" href="#2-分布式消息队列mq"></a> 2. 分布式消息队列（MQ）</h2>
<h3 id="21-为什么使用-mq"><a class="markdownIt-Anchor" href="#21-为什么使用-mq"></a> 2.1. 为什么使用 MQ？</h3>
<ul>
<li>异步处理 - 相比于传统的串行、并行方式，提高了系统吞吐量。</li>
<li>应用解耦 - 系统间通过消息通信，不用关心其他系统的处理。</li>
<li>流量削锋 - 可以通过消息队列长度控制请求量；可以缓解短时间内的高并发请求。</li>
<li>日志处理 - 解决大量日志传输。</li>
<li>消息通讯 - 消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等。</li>
</ul>
<h3 id="22-如何保证-mq-的高可用"><a class="markdownIt-Anchor" href="#22-如何保证-mq-的高可用"></a> 2.2. 如何保证 MQ 的高可用？</h3>
<h4 id="221-数据复制"><a class="markdownIt-Anchor" href="#221-数据复制"></a> 2.2.1. 数据复制</h4>
<ol>
<li>将所有 Broker 和待分配的 Partition 排序</li>
<li>将第 i 个 Partition 分配到第（i mod n）个 Broker 上</li>
<li>将第 i 个 Partition 的第 j 个 Replica 分配到第（(i + j) mode n）个 Broker 上</li>
</ol>
<h4 id="222-选举主服务器"><a class="markdownIt-Anchor" href="#222-选举主服务器"></a> 2.2.2. 选举主服务器</h4>
<h3 id="23-mq-有哪些常见问题如何解决这些问题"><a class="markdownIt-Anchor" href="#23-mq-有哪些常见问题如何解决这些问题"></a> 2.3. MQ 有哪些常见问题？如何解决这些问题？</h3>
<p>MQ 的常见问题有：</p>
<ol>
<li>消息的顺序问题</li>
<li>消息的重复问题</li>
</ol>
<h4 id="231-消息的顺序问题"><a class="markdownIt-Anchor" href="#231-消息的顺序问题"></a> 2.3.1. 消息的顺序问题</h4>
<p>消息有序指的是可以按照消息的发送顺序来消费。</p>
<p>假如生产者产生了 2 条消息：M1、M2，假定 M1 发送到 S1，M2 发送到 S2，如果要保证 M1 先于 M2 被消费，怎么做？</p>
<div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-23145c8b554a0f2f.jpg"/></div>
解决方案：
<p>（1）保证生产者 - MQServer - 消费者是一对一对一的关系</p>
<div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-034106d7e04c062d.jpg"/></div>
缺陷：
<ul>
<li>并行度就会成为消息系统的瓶颈（吞吐量不够）</li>
<li>更多的异常处理，比如：只要消费端出现问题，就会导致整个处理流程阻塞，我们不得不花费更多的精力来解决阻塞的问题。</li>
</ul>
<p>（2）通过合理的设计或者将问题分解来规避。</p>
<ul>
<li>不关注乱序的应用实际大量存在</li>
<li>队列无序并不意味着消息无序</li>
</ul>
<p>所以从业务层面来保证消息的顺序而不仅仅是依赖于消息系统，是一种更合理的方式。</p>
<h4 id="232-消息的重复问题"><a class="markdownIt-Anchor" href="#232-消息的重复问题"></a> 2.3.2. 消息的重复问题</h4>
<p>造成消息重复的根本原因是：网络不可达。</p>
<p>所以解决这个问题的办法就是绕过这个问题。那么问题就变成了：如果消费端收到两条一样的消息，应该怎样处理？</p>
<p>消费端处理消息的业务逻辑保持幂等性。只要保持幂等性，不管来多少条重复消息，最后处理的结果都一样。<br />
保证每条消息都有唯一编号且保证消息处理成功与去重表的日志同时出现。利用一张日志表来记录已经处理成功的消息的 ID，如果新到的消息 ID 已经在日志表中，那么就不再处理这条消息。</p>
<h3 id="24-kafka-activemq-rabbitmq-rocketmq-各有什么优缺点"><a class="markdownIt-Anchor" href="#24-kafka-activemq-rabbitmq-rocketmq-各有什么优缺点"></a> 2.4. Kafka, ActiveMQ, RabbitMQ, RocketMQ 各有什么优缺点？</h3>
<div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-c26f4a3048c38af4.jpg"/></div>
## 3. 分布式服务（RPC）
<h3 id="31-dubbo-的实现过程"><a class="markdownIt-Anchor" href="#31-dubbo-的实现过程"></a> 3.1. Dubbo 的实现过程？</h3>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/java/javaweb/distributed/rpc/dubbo/dubbo基本架构.png" width="500"/>
</div>
<p>节点角色：</p>
<table>
<thead>
<tr>
<th>节点</th>
<th>角色说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Provider</td>
<td>暴露服务的服务提供方</td>
</tr>
<tr>
<td>Consumer</td>
<td>调用远程服务的服务消费方</td>
</tr>
<tr>
<td>Registry</td>
<td>服务注册与发现的注册中心</td>
</tr>
<tr>
<td>Monitor</td>
<td>统计服务的调用次数和调用时间的监控中心</td>
</tr>
<tr>
<td>Container</td>
<td>服务运行容器</td>
</tr>
</tbody>
</table>
<p>调用关系：</p>
<ol>
<li>务容器负责启动，加载，运行服务提供者。</li>
<li>服务提供者在启动时，向注册中心注册自己提供的服务。</li>
<li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li>
<li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li>
<li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li>
<li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li>
</ol>
<h3 id="32-dubbo-负载均衡策略有哪些"><a class="markdownIt-Anchor" href="#32-dubbo-负载均衡策略有哪些"></a> 3.2. Dubbo 负载均衡策略有哪些？</h3>
<h5 id="random"><a class="markdownIt-Anchor" href="#random"></a> Random</h5>
<ul>
<li>随机，按权重设置随机概率。</li>
<li>在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。</li>
</ul>
<h5 id="roundrobin"><a class="markdownIt-Anchor" href="#roundrobin"></a> RoundRobin</h5>
<ul>
<li>轮循，按公约后的权重设置轮循比率。</li>
<li>存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</li>
</ul>
<h5 id="leastactive"><a class="markdownIt-Anchor" href="#leastactive"></a> LeastActive</h5>
<ul>
<li>最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。</li>
<li>使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。</li>
</ul>
<h5 id="consistenthash"><a class="markdownIt-Anchor" href="#consistenthash"></a> ConsistentHash</h5>
<ul>
<li>一致性 Hash，相同参数的请求总是发到同一提供者。</li>
<li>当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。</li>
<li>算法参见：<a href="http://en.wikipedia.org/wiki/Consistent_hashing" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Consistent_hashing</a></li>
<li>缺省只对第一个参数 Hash，如果要修改，请配置 <code>&lt;dubbo:parameter key=&quot;hash.arguments&quot; value=&quot;0,1&quot; /&gt;</code></li>
<li>缺省用 160 份虚拟节点，如果要修改，请配置 <code>&lt;dubbo:parameter key=&quot;hash.nodes&quot; value=&quot;320&quot; /&gt;</code></li>
</ul>
<h3 id="33-dubbo-集群容错策略"><a class="markdownIt-Anchor" href="#33-dubbo-集群容错策略"></a> 3.3. Dubbo 集群容错策略 ？</h3>
<div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/java/javaweb/distributed/rpc/dubbo/dubbo%E9%9B%86%E7%BE%A4%E5%AE%B9%E9%94%99.jpg"/></div>
- **Failover** - 失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过 retries="2" 来设置重试次数(不含第一次)。
- **Failfast** - 快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。
- **Failsafe** - 失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。
- **Failback** - 失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。
- **Forking** - 并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks="2" 来设置最大并行数。
- **Broadcast** - 播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有提供者更新缓存或日志等本地资源信息。
<h3 id="34-动态代理策略"><a class="markdownIt-Anchor" href="#34-动态代理策略"></a> 3.4. 动态代理策略？</h3>
<p>Dubbo 作为 RPC 框架，首先要完成的就是跨系统，跨网络的服务调用。消费方与提供方遵循统一的接口定义，消费方调用接口时，Dubbo 将其转换成统一格式的数据结构，通过网络传输，提供方根据规则找到接口实现，通过反射完成调用。也就是说，消费方获取的是对远程服务的一个代理(Proxy)，而提供方因为要支持不同的接口实现，需要一个包装层(Wrapper)。调用的过程大概是这样：</p>
<div align="center"><img src="https://oscimg.oschina.net/oscnet/bef19cd5a31b5ae13aff35a8cb4898faaf0.jpg"/></div>
消费方的 Proxy 和提供方的 Wrapper 得以让 Dubbo 构建出复杂、统一的体系。而这种动态代理与包装也是通过基于 SPI 的插件方式实现的，它的接口就是**ProxyFactory**。
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SPI</span>(<span class="string">"javassist"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;Constants.PROXY_KEY&#125;)</span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;Constants.PROXY_KEY&#125;)</span><br><span class="line">    &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">getInvoker</span><span class="params">(T proxy, Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ProxyFactory 有两种实现方式，一种是基于 JDK 的代理实现，一种是基于 javassist 的实现。ProxyFactory 接口上定义了@SPI(“javassist”)，默认为 javassist 的实现。</p>
<h3 id="35-dubbo-支持哪些序列化协议hessianhessian-的数据结构"><a class="markdownIt-Anchor" href="#35-dubbo-支持哪些序列化协议hessianhessian-的数据结构"></a> 3.5. Dubbo 支持哪些序列化协议？Hessian？Hessian 的数据结构？</h3>
<ol>
<li>dubbo 序列化，阿里尚不成熟的 java 序列化实现。</li>
<li>hessian2 序列化：hessian 是一种跨语言的高效二进制的序列化方式，但这里实际不是原生的 hessian2 序列化，而是阿里修改过的 hessian lite，它是 dubbo RPC 默认启用的序列化方式。</li>
<li>json 序列化：目前有两种实现，一种是采用的阿里的 fastjson 库，另一种是采用 dubbo 中自已实现的简单 json 库，一般情况下，json 这种文本序列化性能不如二进制序列化。</li>
<li>java 序列化：主要是采用 JDK 自带的 java 序列化实现，性能很不理想。</li>
<li>Kryo 和 FST：Kryo 和 FST 的性能依然普遍优于 hessian 和 dubbo 序列化。</li>
</ol>
<p>Hessian 序列化与 Java 默认的序列化区别？</p>
<p>Hessian 是一个轻量级的 remoting on http 工具，采用的是 Binary RPC 协议，所以它很适合于发送二进制数据，同时又具有防火墙穿透能力。</p>
<ol>
<li>Hessian 支持跨语言串行</li>
<li>比 java 序列化具有更好的性能和易用性</li>
<li>支持的语言比较多</li>
</ol>
<h3 id="36-protoco-buffer-是什么"><a class="markdownIt-Anchor" href="#36-protoco-buffer-是什么"></a> 3.6. Protoco Buffer 是什么？</h3>
<p>Protocol Buffer 是 Google 出品的一种轻量 &amp; 高效的结构化数据存储格式，性能比 Json、XML 真的强！太！多！</p>
<p>Protocol Buffer 的序列化 &amp; 反序列化简单 &amp; 速度快的原因是：</p>
<ol>
<li>编码 / 解码 方式简单（只需要简单的数学运算 = 位移等等）</li>
<li>采用 Protocol Buffer 自身的框架代码 和 编译器 共同完成</li>
</ol>
<p>Protocol Buffer 的数据压缩效果好（即序列化后的数据量体积小）的原因是：</p>
<ol>
<li>采用了独特的编码方式，如 Varint、Zigzag 编码方式等等</li>
<li>采用 T - L - V 的数据存储方式：减少了分隔符的使用 &amp; 数据存储得紧凑</li>
</ol>
<h3 id="37-注册中心挂了可以继续通信吗"><a class="markdownIt-Anchor" href="#37-注册中心挂了可以继续通信吗"></a> 3.7. 注册中心挂了可以继续通信吗？</h3>
<p>可以。Dubbo 消费者在应用启动时会从注册中心拉取已注册的生产者的地址接口，并缓存在本地。每次调用时，按照本地存储的地址进行调用。</p>
<h3 id="38-zookeeper-原理是什么zookeeper-有什么用"><a class="markdownIt-Anchor" href="#38-zookeeper-原理是什么zookeeper-有什么用"></a> 3.8. ZooKeeper 原理是什么？ZooKeeper 有什么用？</h3>
<p>ZooKeeper 是一个分布式应用协调系统，已经用到了许多分布式项目中，用来完成统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等工作。</p>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/java/javaweb/distributed/rpc/zookeeper/zookeeper-service.png" />
</div>
<ol>
<li>每个 Server 在内存中存储了一份数据；</li>
<li>Zookeeper 启动时，将从实例中选举一个 leader（Paxos 协议）；</li>
<li>Leader 负责处理数据更新等操作（Zab 协议）；</li>
<li>一个更新操作成功，当且仅当大多数 Server 在内存中成功修改数据。</li>
</ol>
<h3 id="39-netty-有什么用niobioaio-有什么用有什么区别"><a class="markdownIt-Anchor" href="#39-netty-有什么用niobioaio-有什么用有什么区别"></a> 3.9. Netty 有什么用？NIO/BIO/AIO 有什么用？有什么区别？</h3>
<p>Netty 是一个“网络通讯框架”。</p>
<p>Netty 进行事件处理的流程。<code>Channel</code>是连接的通道，是 ChannelEvent 的产生者，而<code>ChannelPipeline</code>可以理解为 ChannelHandler 的集合。</p>
<div align="center"><img src="https://camo.githubusercontent.com/5f7331d15c79fba29474c5be6e9e86db465637c3/687474703a2f2f7374617469632e6f736368696e612e6e65742f75706c6f6164732f73706163652f323031332f303932312f3137343033325f313872625f3139303539312e706e67"/></div>
> 参考：https://github.com/code4craft/netty-learning/blob/master/posts/ch1-overview.md
<p>IO 的方式通常分为几种：</p>
<ul>
<li>同步阻塞的 BIO</li>
<li>同步非阻塞的 NIO</li>
<li>异步非阻塞的 AIO</li>
</ul>
<p>在使用同步 I/O 的网络应用中，如果要同时处理多个客户端请求，或是在客户端要同时和多个服务器进行通讯，就必须使用多线程来处理。</p>
<p>NIO 基于 Reactor，当 socket 有流可读或可写入 socket 时，操作系统会相应的通知引用程序进行处理，应用再将流读取到缓冲区或写入操作系统。也就是说，这个时候，已经不是一个连接就要对应一个处理线程了，而是有效的请求，对应一个线程，当连接没有数据时，是没有工作线程来处理的。</p>
<p>与 NIO 不同，当进行读写操作时，只须直接调用 API 的 read 或 write 方法即可。这两种方法均为异步的，对于读操作而言，当有流可读取时，操作系统会将可读的流传入 read 方法的缓冲区，并通知应用程序；对于写操作而言，当操作系统将 write 方法传递的流写入完毕时，操作系统主动通知应用程序。 即可以理解为，read/write 方法都是异步的，完成后会主动调用回调函数。</p>
<blockquote>
<p>参考：<a href="https://blog.csdn.net/skiof007/article/details/52873421" target="_blank" rel="noopener">https://blog.csdn.net/skiof007/article/details/52873421</a></p>
</blockquote>
<h3 id="310-为什么要进行系统拆分拆分不用-dubbo-可以吗"><a class="markdownIt-Anchor" href="#310-为什么要进行系统拆分拆分不用-dubbo-可以吗"></a> 3.10. 为什么要进行系统拆分？拆分不用 Dubbo 可以吗？</h3>
<p>系统拆分从资源角度分为：应用拆分和数据库拆分。</p>
<p>从采用的先后顺序可分为：水平扩展、垂直拆分、业务拆分、水平拆分。</p>
<div align="center"><img src="http://misc.linkedkeeper.com/misc/img/blog/201804/linkedkeeper0_9c2ed2ed-6156-40f7-ad08-20af067047ca.jpg"/></div>
是否使用服务依据实际业务场景来决定。
<p>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。</p>
<p>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键。</p>
<h3 id="311-dubbo-和-thrift-有什么区别"><a class="markdownIt-Anchor" href="#311-dubbo-和-thrift-有什么区别"></a> 3.11. Dubbo 和 Thrift 有什么区别？</h3>
<ul>
<li>Thrift 是跨语言的 RPC 框架。</li>
<li>Dubbo 支持服务治理，而 Thrift 不支持。</li>
</ul>
<h2 id="4-分布式锁基本原理"><a class="markdownIt-Anchor" href="#4-分布式锁基本原理"></a> 4. 分布式锁基本原理</h2>
<blockquote>
<p>分布式锁有几种实现方式？实现的要点是什么？</p>
<p>分布式锁各方案有什么利弊？如何选择方案？为什么？</p>
<p>Redis 分布式锁如何保证可重入性？</p>
<p>详细内容请参考：<a href="distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.md">分布式锁</a></p>
</blockquote>
<p>【答题思路】</p>
<p>实现方式一般有：</p>
<ul>
<li>基于数据库实现：
<ul>
<li>建一张表（t_dlock），关键字段有：<code>id</code>、<code>method_name</code>、<code>time</code>。</li>
<li>向表中插入记录成功，即为获取锁成功。需要注意的是，获取锁一般是通过自旋方式，并设置尝试次数，超过最大尝试次数，才判定获取锁失败。</li>
<li>删除记录，即为释放锁。</li>
<li>因为数据库没有淘汰机制，为了避免获取锁永不释放，应用需要自身实现定期检查，删除过期记录（根据 time 判断）。</li>
</ul>
</li>
<li>基于 Redis 实现
<ul>
<li>生成一个分布式 ID 作为 key，通过 <code>setnx</code> 写入</li>
<li>写入成功，即为获取锁成功。需要注意的是，获取锁一般是通过自旋方式，并设置尝试次数，超过最大尝试次数，才判定获取锁失败。</li>
<li>删除 key，即为获取锁失败。</li>
<li>Redis 自身有内存淘汰策略，所以只要设置 expire，就可以让 key 自动过期。</li>
</ul>
</li>
<li>基于 ZooKeeper 实现
<ul>
<li>创建一个节点，所有节点都 Watch 此节点。</li>
<li>任意节点的任意线程只要向这个节点创建临时子节点成功，即为获取锁成功。</li>
<li>由于创建临时子节点是原子性的，不存在竞态，不需要自旋尝试，性能很好。</li>
<li>因为 ZooKeeper 只要和节点断开会话，就会自动删除临时节点。即为删除锁。所以无需过期机制。</li>
</ul>
</li>
</ul>
<p>从实现方式可以看出，三种方案的对比：</p>
<ul>
<li>Mysql 方案性能最差，并且影响 Mysql 吞吐量。而且还要程序保证容错处理。不建议采用这种方案。</li>
<li>Redis 方案需要不断自旋尝试获取锁，应用会消耗一些性能开销。而且为了保证分布式锁的可重入性，需要设置对于所有节点、所有线程都唯一的分布式 ID，生成 ID 也需要一定的 CPU 开销。</li>
<li>ZooKeeper 方案实现最简单，最稳定。是推荐的方案。但是它也有一个问题：ZooKeeper 的主从架构，所有写都由 Master 节点负责，所以 ZooKeeper 自身有一定的性能瓶颈。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/2018/07/09/%E5%A4%A7%E5%9E%8B%E7%B3%BB%E7%BB%9F%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2018/07/09/%E5%A4%A7%E5%9E%8B%E7%B3%BB%E7%BB%9F%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/" class="post-title-link" itemprop="url">大型系统核心技术</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-09 00:00:00" itemprop="dateCreated datePublished" datetime="2018-07-09T00:00:00+08:00">2018-07-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-14 16:45:53" itemprop="dateModified" datetime="2022-04-14T16:45:53+08:00">2022-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2018/07/09/%E5%A4%A7%E5%9E%8B%E7%B3%BB%E7%BB%9F%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/07/09/大型系统核心技术/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="大型系统核心技术"><a class="markdownIt-Anchor" href="#大型系统核心技术"></a> 大型系统核心技术</h1>
<blockquote>
<p>大型系统的设计目标就是为了快速、高效、稳定的处理海量的数据以及高并发的请求。</p>
<p>单机服务受限于硬件，客观存在着资源瓶颈，难以应对不断增长的数据量和请求量，为了打破瓶颈，大型系统基本上都被设计为分布式系统。</p>
<p>分布式系统由于其面临的共性问题，在很多场景下的解决方案往往也存在着共性。因此，我们会发现，很多优秀的大型系统在设计方案上存在着很多的共同点。</p>
<p>本文主要讨论应对分布式系统共性问题的解决方案，这既可以加深对分布式系统运作原理的理解，也可以作为设计大型分布式系统时的借鉴。</p>
</blockquote>
<h2 id="1-分布式事务"><a class="markdownIt-Anchor" href="#1-分布式事务"></a> 1. 分布式事务</h2>
<blockquote>
<p>参考：<a href="%E5%88%86%E5%B8%83%E5%BC%8F%E5%8E%9F%E7%90%86.md#4-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E9%97%AE%E9%A2%98">分布式原理#4-分布式事务问题</a></p>
</blockquote>
<h2 id="2-分布式锁"><a class="markdownIt-Anchor" href="#2-分布式锁"></a> 2. 分布式锁</h2>
<p>Java 原生 API 虽然有并发锁，但并没有提供分布式锁的能力，所以针对分布式场景中的锁需要解决的方案。</p>
<p>分布式锁的解决方案大致有以下几种：</p>
<ul>
<li>基于数据库实现</li>
<li>基于缓存（redis，memcached 等）实现</li>
<li>基于 Zookeeper 实现</li>
</ul>
<h3 id="21-基于数据库实现分布式锁"><a class="markdownIt-Anchor" href="#21-基于数据库实现分布式锁"></a> 2.1. 基于数据库实现分布式锁</h3>
<h4 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h4>
<h5 id="1-创建表"><a class="markdownIt-Anchor" href="#1-创建表"></a> 1. 创建表</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`methodLock`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键'</span>,</span><br><span class="line">  <span class="string">`method_name`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'锁定的方法名'</span>,</span><br><span class="line">  <span class="string">`desc`</span> <span class="built_in">varchar</span>(<span class="number">1024</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'备注信息'</span>,</span><br><span class="line">  <span class="string">`update_time`</span> <span class="built_in">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'保存数据时间，自动生成'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`uidx_method_name`</span> (<span class="string">`method_name `</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'锁定中的方法'</span>;</span><br></pre></td></tr></table></figure>
<h5 id="2-获取锁"><a class="markdownIt-Anchor" href="#2-获取锁"></a> 2. 获取锁</h5>
<p>想要锁住某个方法时，执行以下 SQL：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> methodLock(method_name,<span class="keyword">desc</span>) <span class="keyword">values</span> (‘method_name’,‘<span class="keyword">desc</span>’)</span><br></pre></td></tr></table></figure>
<p>因为我们对 <code>method_name</code> 做了唯一性约束，这里如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，那么我们就可以认为操作成功的那个线程获得了该方法的锁，可以执行方法体内容。</p>
<p>成功插入则获取锁。</p>
<h5 id="3-释放锁"><a class="markdownIt-Anchor" href="#3-释放锁"></a> 3. 释放锁</h5>
<p>当方法执行完毕之后，想要释放锁的话，需要执行以下 Sql:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> methodLock <span class="keyword">where</span> method_name =<span class="string">'method_name'</span></span><br></pre></td></tr></table></figure>
<h4 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h4>
<ol>
<li>这把锁强依赖数据库的可用性。如果数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。</li>
<li>这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。</li>
<li>这把锁只能是非阻塞的，因为数据的 insert 操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。</li>
<li>这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。</li>
</ol>
<h4 id="解决办法"><a class="markdownIt-Anchor" href="#解决办法"></a> 解决办法</h4>
<ol>
<li>单点问题可以用多数据库实例，同时塞 N 个表，N/2+1 个成功就任务锁定成功</li>
<li>写一个定时任务，隔一段时间清除一次过期的数据。</li>
<li>写一个 while 循环，不断的重试插入，直到成功。</li>
<li>在数据库表中加个字段，记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了。</li>
</ol>
<h4 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h4>
<ul>
<li>优点: 直接借助数据库，容易理解。</li>
<li>缺点: 会有各种各样的问题，在解决问题的过程中会使整个方案变得越来越复杂。操作数据库需要一定的开销，性能问题需要考虑。</li>
</ul>
<h3 id="22-基于-redis-实现分布式锁"><a class="markdownIt-Anchor" href="#22-基于-redis-实现分布式锁"></a> 2.2. 基于 Redis 实现分布式锁</h3>
<p>相比于用数据库来实现分布式锁，基于缓存实现的分布式锁的性能会更好一些。目前有很多成熟的分布式产品，包括 Redis、memcache、Tair 等。这里以 Redis 举例。</p>
<h4 id="redis-命令"><a class="markdownIt-Anchor" href="#redis-命令"></a> Redis 命令</h4>
<ul>
<li>setnx - setnx key val：当且仅当 key 不存在时，set 一个 key 为 val 的字符串，返回 1；若 key 存在，则什么都不做，返回 0。</li>
<li>expire - expire key timeout：为 key 设置一个超时时间，单位为 second，超过这个时间锁会自动释放，避免死锁。</li>
<li>delete - delete key：删除 key</li>
</ul>
<h4 id="实现-2"><a class="markdownIt-Anchor" href="#实现-2"></a> 实现</h4>
<p>单点实现步骤：</p>
<ol>
<li>获取锁的使用，使用 setnx 加锁，锁的 value 值为一个随机生成的 UUID，再使用 expire 设置一个过期值。</li>
<li>获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。</li>
<li>释放锁的时候，通过 UUID 判断是不是该锁，若是该锁，则执行 delete 进行锁释放。</li>
</ol>
<h4 id="问题-2"><a class="markdownIt-Anchor" href="#问题-2"></a> 问题</h4>
<ul>
<li>单点问题。如果单机 redis 挂掉了，那么程序会跟着出错。</li>
<li>如果转移使用 slave 节点，复制不是同步复制，会出现多个程序获取锁的情况</li>
</ul>
<h4 id="小结-2"><a class="markdownIt-Anchor" href="#小结-2"></a> 小结</h4>
<p>可以考虑使用 <a href="https://github.com/redisson/redisson/wiki/8.-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%92%8C%E5%90%8C%E6%AD%A5%E5%99%A8" target="_blank" rel="noopener">redisson 的解决方案</a>。</p>
<h3 id="23-基于-zookeeper-实现分布式锁"><a class="markdownIt-Anchor" href="#23-基于-zookeeper-实现分布式锁"></a> 2.3. 基于 ZooKeeper 实现分布式锁</h3>
<h4 id="实现-3"><a class="markdownIt-Anchor" href="#实现-3"></a> 实现</h4>
<p>这也是 ZooKeeper 客户端 curator 的分布式锁实现。</p>
<ol>
<li>创建一个目录 mylock；</li>
<li>线程 A 想获取锁就在 mylock 目录下创建临时顺序节点；</li>
<li>获取 mylock 目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；</li>
<li>线程 B 获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点；</li>
<li>线程 A 处理完，删除自己的节点，线程 B 监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。</li>
</ol>
<h4 id="小结-3"><a class="markdownIt-Anchor" href="#小结-3"></a> 小结</h4>
<p>ZooKeeper 版本的分布式锁问题相对比较来说少。</p>
<ul>
<li>锁的占用时间限制：redis 就有占用时间限制，而 ZooKeeper 则没有，最主要的原因是 redis 目前没有办法知道已经获取锁的客户端的状态，是已经挂了呢还是正在执行耗时较长的业务逻辑。而 ZooKeeper 通过临时节点就能清晰知道，如果临时节点存在说明还在执行业务逻辑，如果临时节点不存在说明已经执行完毕释放锁或者是挂了。由此看来 redis 如果能像 ZooKeeper 一样添加一些与客户端绑定的临时键，也是一大好事。</li>
<li>是否单点故障：redis 本身有很多中玩法，如客户端一致性 hash，服务器端 sentinel 方案或者 cluster 方案，很难做到一种分布式锁方式能应对所有这些方案。而 ZooKeeper 只有一种玩法，多台机器的节点数据是一致的，没有 redis 的那么多的麻烦因素要考虑。</li>
</ul>
<p>总体上来说 ZooKeeper 实现分布式锁更加的简单，可靠性更高。但 ZooKeeper 因为需要频繁的创建和删除节点，性能上不如 Redis 方式。</p>
<h2 id="3-分布式-session"><a class="markdownIt-Anchor" href="#3-分布式-session"></a> 3. 分布式 Session</h2>
<p>在分布式场景下，一个用户的 Session 如果只存储在一个服务器上，那么当负载均衡器把用户的下一个请求转发到另一个服务器上，该服务器没有用户的 Session，就可能导致用户需要重新进行登录等操作。</p>
<p>分布式 Session 的几种实现策略：</p>
<ol>
<li>粘性 session</li>
<li>应用服务器间的 session 复制共享</li>
<li>基于 cache DB 缓存的 session 共享</li>
</ol>
<h3 id="31-sticky-sessions"><a class="markdownIt-Anchor" href="#31-sticky-sessions"></a> 3.1. Sticky Sessions</h3>
<p>需要配置负载均衡器，使得一个用户的所有请求都路由到一个服务器节点上，这样就可以把用户的 Session 存放在该服务器节点中。</p>
<p>缺点：当服务器节点宕机时，将丢失该服务器节点上的所有 Session。</p>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/architecture/MultiNode-StickySessions.jpg" />
</div>
<h3 id="32-session-replication"><a class="markdownIt-Anchor" href="#32-session-replication"></a> 3.2. Session Replication</h3>
<p>在服务器节点之间进行 Session 同步操作，这样的话用户可以访问任何一个服务器节点。</p>
<p>缺点：占用过多内存；同步过程占用网络带宽以及服务器处理器时间。</p>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/architecture/MultiNode-SessionReplication.jpg" />
</div>
<h3 id="33-session-server"><a class="markdownIt-Anchor" href="#33-session-server"></a> 3.3. Session Server</h3>
<p>使用一个单独的服务器存储 Session 数据，可以存在 MySQL 数据库上，也可以存在 Redis 或者 Memcached 这种内存型数据库。</p>
<p>缺点：需要去实现存取 Session 的代码。</p>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/architecture/MultiNode-SpringSession.jpg" />
</div>
<h2 id="4-分布式存储"><a class="markdownIt-Anchor" href="#4-分布式存储"></a> 4. 分布式存储</h2>
<p>通常有两种解决方案：</p>
<ol>
<li>数据分布：就是把数据分块存在不同的服务器上（分库分表）。</li>
<li>数据复制：让所有的服务器都有相同的数据，提供相当的服务。</li>
</ol>
<blockquote>
<p>参考：<a href="%E5%88%86%E5%B8%83%E5%BC%8F%E5%8E%9F%E7%90%86.md#2-%E6%95%B0%E6%8D%AE%E5%88%86%E5%B8%83">分布式原理.md#2-数据分布</a></p>
</blockquote>
<h2 id="5-分布式缓存"><a class="markdownIt-Anchor" href="#5-分布式缓存"></a> 5. 分布式缓存</h2>
<p>使用缓存的好处：</p>
<ul>
<li>提升数据读取速度</li>
<li>提升系统扩展能力，通过扩展缓存，提升系统承载能力</li>
<li>降低存储成本，Cache+DB 的方式可以承担原有需要多台 DB 才能承担的请求量，节省机器成本</li>
</ul>
<p>根据业务场景，通常缓存有以下几种使用方式</p>
<ul>
<li>懒汉式(读时触发)：写入 DB 后, 然后把相关的数据也写入 Cache</li>
<li>饥饿式(写时触发)：先查询 DB 里的数据, 然后把相关的数据写入 Cache</li>
<li>定期刷新：适合周期性的跑数据的任务，或者列表型的数据，而且不要求绝对实时性</li>
</ul>
<p>缓存分类：</p>
<ul>
<li>应用内缓存：如：EHCache</li>
<li>分布式缓存：如：Memached、Redis</li>
</ul>
<blockquote>
<p>参考：<a href="%E5%88%86%E5%B8%83%E5%BC%8F%E5%8E%9F%E7%90%86.md#6-%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98">分布式原理.md#6-分布式缓存问题</a></p>
</blockquote>
<h2 id="6-分布式计算"><a class="markdownIt-Anchor" href="#6-分布式计算"></a> 6. 分布式计算</h2>
<h2 id="7-负载均衡"><a class="markdownIt-Anchor" href="#7-负载均衡"></a> 7. 负载均衡</h2>
<h3 id="71-算法"><a class="markdownIt-Anchor" href="#71-算法"></a> 7.1. 算法</h3>
<h4 id="轮询round-robin"><a class="markdownIt-Anchor" href="#轮询round-robin"></a> 轮询（Round Robin）</h4>
<p>轮询算法把每个请求轮流发送到每个服务器上。下图中，一共有 6 个客户端产生了 6 个请求，这 6 个请求按 (1, 2, 3, 4, 5, 6) 的顺序发送。最后，(1, 3, 5) 的请求会被发送到服务器 1，(2, 4, 6) 的请求会被发送到服务器 2。</p>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/architecture/负载均衡算法之轮询-01.jpg" width="640"/>
</div>
<p>该算法比较适合每个服务器的性能差不多的场景，如果有性能存在差异的情况下，那么性能较差的服务器可能无法承担过大的负载（下图的 Server 2）。</p>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/architecture/负载均衡算法之轮询-02.jpg" width="640"/>
</div>
<h4 id="加权轮询weighted-round-robbin"><a class="markdownIt-Anchor" href="#加权轮询weighted-round-robbin"></a> 加权轮询（Weighted Round Robbin）</h4>
<p>加权轮询是在轮询的基础上，根据服务器的性能差异，为服务器赋予一定的权值。例如下图中，服务器 1 被赋予的权值为 5，服务器 2 被赋予的权值为 1，那么 (1, 2, 3, 4, 5) 请求会被发送到服务器 1，(6) 请求会被发送到服务器 2。</p>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/architecture/负载均衡算法之加权轮询.jpg" width="640"/>
</div>
<h4 id="最少连接least-connections"><a class="markdownIt-Anchor" href="#最少连接least-connections"></a> 最少连接（least Connections）</h4>
<p>由于每个请求的连接时间不一样，使用轮询或者加权轮询算法的话，可能会让一台服务器当前连接数过大，而另一台服务器的连接过小，造成负载不均衡。例如下图中，(1, 3, 5) 请求会被发送到服务器 1，但是 (1, 3) 很快就断开连接，此时只有 (5) 请求连接服务器 1；(2, 4, 6) 请求被发送到服务器 2，只有 (2) 的连接断开。该系统继续运行时，服务器 2 会承担过大的负载。</p>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/architecture/负载均衡算法之最少连接-01.jpg" width="640"/>
</div>
<p>最少连接算法就是将请求发送给当前最少连接数的服务器上。例如下图中，服务器 1 当前连接数最小，那么新到来的请求 6 就会被发送到服务器 1 上。</p>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/architecture/负载均衡算法之最少连接-02.jpg" width="640"/>
</div>
<h4 id="加权最少连接weighted-least-connection"><a class="markdownIt-Anchor" href="#加权最少连接weighted-least-connection"></a> 加权最少连接（Weighted Least Connection）</h4>
<p>在最少连接的基础上，根据服务器的性能为每台服务器分配权重，再根据权重计算出每台服务器能处理的连接数。</p>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/architecture/负载均衡算法之加权最少连接.jpg" width="640"/>
</div>
<h4 id="随机算法random"><a class="markdownIt-Anchor" href="#随机算法random"></a> 随机算法（Random）</h4>
<p>把请求随机发送到服务器上。和轮询算法类似，该算法比较适合服务器性能差不多的场景。</p>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/architecture/负载均衡算法之随机.jpg" width="640"/>
</div>
<h4 id="源地址哈希法-ip-hash"><a class="markdownIt-Anchor" href="#源地址哈希法-ip-hash"></a> 源地址哈希法 (IP Hash)</h4>
<p>源地址哈希通过对客户端 IP 哈希计算得到的一个数值，用该数值对服务器数量进行取模运算，取模结果便是目标服务器的序号。</p>
<ul>
<li>优点：保证同一 IP 的客户端都会被 hash 到同一台服务器上。</li>
<li>缺点：不利于集群扩展，后台服务器数量变更都会影响 hash 结果。可以采用一致性 Hash 改进。</li>
</ul>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/architecture/负载均衡算法之IpHash.jpg" width="640"/>
</div>
<h3 id="72-实现"><a class="markdownIt-Anchor" href="#72-实现"></a> 7.2. 实现</h3>
<h4 id="http-重定向"><a class="markdownIt-Anchor" href="#http-重定向"></a> HTTP 重定向</h4>
<p>HTTP 重定向负载均衡服务器收到 HTTP 请求之后会返回服务器的地址，并将该地址写入 HTTP 重定向响应中返回给浏览器，浏览器收到后需要再次发送请求。</p>
<p>缺点：</p>
<ul>
<li>用户访问的延迟会增加；</li>
<li>如果负载均衡器宕机，就无法访问该站点。</li>
</ul>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/architecture/Http重定向.png" width="640"/>
</div>
<h4 id="dns-重定向"><a class="markdownIt-Anchor" href="#dns-重定向"></a> DNS 重定向</h4>
<p>使用 DNS 作为负载均衡器，根据负载情况返回不同服务器的 IP 地址。大型网站基本使用了这种方式做为第一级负载均衡手段，然后在内部使用其它方式做第二级负载均衡。</p>
<p>缺点：</p>
<ul>
<li>DNS 查找表可能会被客户端缓存起来，那么之后的所有请求都会被重定向到同一个服务器。</li>
</ul>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/architecture/Dns重定向.png" width="640"/>
</div>
<h4 id="修改-mac-地址"><a class="markdownIt-Anchor" href="#修改-mac-地址"></a> 修改 MAC 地址</h4>
<p>使用 LVS（Linux Virtual Server）这种链路层负载均衡器，根据负载情况修改请求的 MAC 地址。</p>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/architecture/修改Mac地址.png" width="640"/>
</div>
<h4 id="修改-ip-地址"><a class="markdownIt-Anchor" href="#修改-ip-地址"></a> 修改 IP 地址</h4>
<p>在网络层修改请求的目的 IP 地址。</p>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/architecture/修改IP地址.png" width="640"/>
</div>
<h4 id="代理自动配置"><a class="markdownIt-Anchor" href="#代理自动配置"></a> 代理自动配置</h4>
<p>正向代理与反向代理的区别：</p>
<ul>
<li>正向代理：发生在客户端，是由用户主动发起的。比如翻墙，客户端通过主动访问代理服务器，让代理服务器获得需要的外网数据，然后转发回客户端。</li>
<li>反向代理：发生在服务器端，用户不知道代理的存在。</li>
</ul>
<p>PAC 服务器是用来判断一个请求是否要经过代理。</p>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/architecture/代理自动配置.jpg" width="640"/>
</div>
<h2 id="8-资料"><a class="markdownIt-Anchor" href="#8-资料"></a> 8. 资料</h2>
<ul>
<li><a href="https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html" target="_blank" rel="noopener">https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html</a></li>
<li><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90.md" target="_blank" rel="noopener">https://github.com/CyC2018/Interview-Notebook/blob/master/notes/分布式问题分析.md</a></li>
<li><a href="https://www.jianshu.com/p/453c6e7ff81c" target="_blank" rel="noopener">https://www.jianshu.com/p/453c6e7ff81c</a></li>
<li><a href="https://juejin.im/post/5a20cd8bf265da43163cdd9a" target="_blank" rel="noopener">https://juejin.im/post/5a20cd8bf265da43163cdd9a</a></li>
<li><a href="https://github.com/redisson/redisson/wiki/8.-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%92%8C%E5%90%8C%E6%AD%A5%E5%99%A8" target="_blank" rel="noopener">https://github.com/redisson/redisson/wiki/8.-分布式锁和同步器</a></li>
<li><a href="https://github.com/L316476844/distributed-session" target="_blank" rel="noopener">https://github.com/L316476844/distributed-session</a></li>
<li><a href="https://juejin.im/entry/57e39e320e3dd90058021bff" target="_blank" rel="noopener">分布式缓存架构基础</a></li>
<li><a href="https://www.toutiao.com/i6533812974807679495/?tt_from=weixin&amp;utm_campaign=client_share&amp;from=singlemessage&amp;timestamp=1521281305&amp;app=news_article&amp;utm_source=weixin&amp;iid=28128279343&amp;utm_medium=toutiao_android&amp;weixin_list=1&amp;wxshare_count=2&amp;pbid=6517746516513195523" target="_blank" rel="noopener">阿里 P8 技术专家细究分布式缓存问题</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/2018/07/05/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2018/07/05/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/" class="post-title-link" itemprop="url">深入浅出负载均衡</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-05 15:50:00" itemprop="dateCreated datePublished" datetime="2018-07-05T15:50:00+08:00">2018-07-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-14 16:45:53" itemprop="dateModified" datetime="2022-04-14T16:45:53+08:00">2022-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">分布式关键技术</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/%E6%B5%81%E9%87%8F%E8%B0%83%E5%BA%A6/" itemprop="url" rel="index">
                    <span itemprop="name">流量调度</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2018/07/05/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/07/05/深入浅出负载均衡/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>17k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>15 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="深入浅出负载均衡"><a class="markdownIt-Anchor" href="#深入浅出负载均衡"></a> 深入浅出负载均衡</h1>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200528155252.png" alt="img" /></p>
<h2 id="1-负载均衡简介"><a class="markdownIt-Anchor" href="#1-负载均衡简介"></a> 1. 负载均衡简介</h2>
<h3 id="11-大型网站面临的挑战"><a class="markdownIt-Anchor" href="#11-大型网站面临的挑战"></a> 1.1. 大型网站面临的挑战</h3>
<p>大型网站都要面对庞大的用户量，高并发，海量数据等挑战。</p>
<p>为了提升系统整体的性能，可以采用垂直扩展和水平扩展两种方式。</p>
<ul>
<li><strong>垂直扩展</strong>：在网站发展早期，可以从单机的角度通过<strong>增加硬件处理能力</strong>，比如 CPU 处理能力，内存容量，磁盘等方面，实现服务器处理能力的提升。但是，单机是有性能瓶颈的，一旦触及瓶颈，再想提升，付出的成本和代价会极高。这显然不能满足大型分布式系统（网站）所有应对的大流量，高并发，海量数据等挑战。</li>
<li><strong>水平扩展</strong>：通过集群来分担大型网站的流量。集群中的应用服务器（节点）通常被设计成无状态，用户可以请求任何一个节点，这些节点共同分担访问压力。水平扩展有两个要点：
<ul>
<li><strong>应用集群</strong>：将同一应用部署到多台机器上，组成处理集群，接收负载均衡设备分发的请求，进行处理，并返回相应数据。</li>
<li><strong>负载均衡</strong>：将用户访问请求，通过某种算法，分发到集群中的节点。</li>
</ul>
</li>
</ul>
<h3 id="12-什么是负载均衡"><a class="markdownIt-Anchor" href="#12-什么是负载均衡"></a> 1.2. 什么是负载均衡</h3>
<p>负载均衡（Load Balance，简称 LB）是高并发、高可用系统必不可少的关键组件，目标是 <strong>尽力将网络流量平均分发到多个服务器上，以提高系统整体的响应速度和可用性</strong>。</p>
<p>负载均衡的主要作用如下：</p>
<ul>
<li><strong>高并发</strong>：负载均衡通过算法调整负载，尽力均匀的分配应用集群中各节点的工作量，以此提高应用集群的并发处理能力（吞吐量）。</li>
<li><strong>伸缩性</strong>：添加或减少服务器数量，然后由负载均衡进行分发控制。这使得应用集群具备伸缩性。</li>
<li><strong>高可用</strong>：负载均衡器可以监控候选服务器，当服务器不可用时，自动跳过，将请求分发给可用的服务器。这使得应用集群具备高可用的特性。</li>
<li><strong>安全防护</strong>：有些负载均衡软件或硬件提供了安全性功能，如：黑白名单处理、防火墙，防 DDos 攻击等。</li>
</ul>
<h2 id="2-负载均衡的分类"><a class="markdownIt-Anchor" href="#2-负载均衡的分类"></a> 2. 负载均衡的分类</h2>
<p>支持负载均衡的技术很多，我们可以通过不同维度去进行分类。</p>
<h3 id="21-载体维度分类"><a class="markdownIt-Anchor" href="#21-载体维度分类"></a> 2.1. 载体维度分类</h3>
<p>从支持负载均衡的载体来看，可以将负载均衡分为两类：</p>
<ul>
<li>硬件负载均衡</li>
<li>软件负载均衡</li>
</ul>
<h4 id="硬件负载均衡"><a class="markdownIt-Anchor" href="#硬件负载均衡"></a> 硬件负载均衡</h4>
<p>硬件负载均衡，一般是在定制处理器上运行的独立负载均衡服务器，<strong>价格昂贵，土豪专属</strong>。</p>
<p>硬件负载均衡的 <strong>主流产品</strong> 有：<a href="https://f5.com/zh" target="_blank" rel="noopener">F5</a> 和 <a href="https://www.a10networks.com.cn/" target="_blank" rel="noopener">A10</a>。</p>
<p>硬件负载均衡的 <strong>优点</strong>：</p>
<ul>
<li><strong>功能强大</strong>：支持全局负载均衡并提供较全面的、复杂的负载均衡算法。</li>
<li><strong>性能强悍</strong>：硬件负载均衡由于是在专用处理器上运行，因此吞吐量大，可支持单机百万以上的并发。</li>
<li><strong>安全性高</strong>：往往具备防火墙，防 DDos 攻击等安全功能。</li>
</ul>
<p>硬件负载均衡的 <strong>缺点</strong>：</p>
<ul>
<li><strong>成本昂贵</strong>：购买和维护硬件负载均衡的成本都很高。</li>
<li><strong>扩展性差</strong>：当访问量突增时，超过限度不能动态扩容。</li>
</ul>
<h4 id="软件负载均衡"><a class="markdownIt-Anchor" href="#软件负载均衡"></a> 软件负载均衡</h4>
<p>软件负载均衡，<strong>应用最广泛</strong>，无论大公司还是小公司都会使用。</p>
<p>软件负载均衡从软件层面实现负载均衡，一般可以在任何标准物理设备上运行。</p>
<p>软件负载均衡的 <strong>主流产品</strong> 有：<a href="https://www.nginx.com/" target="_blank" rel="noopener">Nginx</a>、<a href="http://www.haproxy.org/" target="_blank" rel="noopener">HAProxy</a>、<a href="https://github.com/alibaba/LVS" target="_blank" rel="noopener">LVS</a>。</p>
<ul>
<li><a href="https://github.com/alibaba/LVS" target="_blank" rel="noopener">LVS</a> 可以作为四层负载均衡器。其负载均衡的性能要优于 Nginx。</li>
<li><a href="http://www.haproxy.org/" target="_blank" rel="noopener">HAProxy</a> 可以作为 HTTP 和 TCP 负载均衡器。</li>
<li><a href="https://www.nginx.com/" target="_blank" rel="noopener">Nginx</a>、<a href="http://www.haproxy.org/" target="_blank" rel="noopener">HAProxy</a> 可以作为四层或七层负载均衡器。</li>
</ul>
<p>软件负载均衡的 <strong>优点</strong>：</p>
<ul>
<li><strong>扩展性好</strong>：适应动态变化，可以通过添加软件负载均衡实例，动态扩展到超出初始容量的能力。</li>
<li><strong>成本低廉</strong>：软件负载均衡可以在任何标准物理设备上运行，降低了购买和运维的成本。</li>
</ul>
<p>软件负载均衡的 <strong>缺点</strong>：</p>
<ul>
<li><strong>性能略差</strong>：相比于硬件负载均衡，软件负载均衡的性能要略低一些。</li>
</ul>
<h3 id="22-网络通信分类"><a class="markdownIt-Anchor" href="#22-网络通信分类"></a> 2.2. 网络通信分类</h3>
<p>软件负载均衡从通信层面来看，又可以分为四层和七层负载均衡。</p>
<ul>
<li>七层负载均衡：就是可以根据访问用户的 HTTP 请求头、URL 信息将请求转发到特定的主机。
<ul>
<li>DNS 重定向</li>
<li>HTTP 重定向</li>
<li>反向代理</li>
</ul>
</li>
<li>四层负载均衡：基于 IP 地址和端口进行请求的转发。
<ul>
<li>修改 IP 地址</li>
<li>修改 MAC 地址</li>
</ul>
</li>
</ul>
<h4 id="dns-负载均衡"><a class="markdownIt-Anchor" href="#dns-负载均衡"></a> DNS 负载均衡</h4>
<p>DNS 负载均衡一般用于互联网公司，复杂的业务系统不适合使用。大型网站一般使用 DNS 负载均衡作为 <strong>第一级负载均衡手段</strong>，然后在内部使用其它方式做第二级负载均衡。DNS 负载均衡属于七层负载均衡。</p>
<p>DNS 即 <strong>域名解析服务</strong>，是 OSI 第七层网络协议。DNS 被设计为一个树形结构的分布式应用，自上而下依次为：根域名服务器，一级域名服务器，二级域名服务器，… ，本地域名服务器。显然，如果所有数据都存储在根域名服务器，那么 DNS 查询的负载和开销会非常庞大。</p>
<p>因此，DNS 查询相对于 DNS 层级结构，是一个逆向的递归流程，DNS 客户端依次请求本地 DNS 服务器，上一级 DNS 服务器，上上一级 DNS 服务器，… ，根 DNS 服务器（又叫权威 DNS 服务器），一旦命中，立即返回。为了减少查询次数，每一级 DNS 服务器都会设置 DNS 查询缓存。</p>
<p>DNS 负载均衡的工作原理就是：<strong>基于 DNS 查询缓存，按照负载情况返回不同服务器的 IP 地址</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20210117220007.png" alt="img" /></p>
<p>DNS 重定向的 <strong>优点</strong>：</p>
<ul>
<li><strong>使用简单</strong>：负载均衡工作，交给 DNS 服务器处理，省掉了负载均衡服务器维护的麻烦</li>
<li><strong>提高性能</strong>：可以支持基于地址的域名解析，解析成距离用户最近的服务器地址（类似 CDN 的原理），可以加快访问速度，改善性能；</li>
</ul>
<p>DNS 重定向的 <strong>缺点</strong>：</p>
<ul>
<li><strong>可用性差</strong>：DNS 解析是多级解析，新增/修改 DNS 后，解析时间较长；解析过程中，用户访问网站将失败；</li>
<li><strong>扩展性低</strong>：DNS 负载均衡的控制权在域名商那里，无法对其做更多的改善和扩展；</li>
<li><strong>维护性差</strong>：也不能反映服务器的当前运行状态；支持的算法少；不能区分服务器的差异（不能根据系统与服务的状态来判断负载）</li>
</ul>
<h4 id="http-负载均衡"><a class="markdownIt-Anchor" href="#http-负载均衡"></a> HTTP 负载均衡</h4>
<p><strong>HTTP 负载均衡是基于 HTTP 重定向实现的</strong>。HTTP 负载均衡属于七层负载均衡。</p>
<p>HTTP 重定向原理是：<strong>根据用户的 HTTP 请求计算出一个真实的服务器地址，将该服务器地址写入 HTTP 重定向响应中，返回给浏览器，由浏览器重新进行访问</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20210117220310.png" alt="img" /></p>
<p>HTTP 重定向的 <strong>优点</strong>：<strong>方案简单</strong>。</p>
<p>HTTP 重定向的 <strong>缺点</strong>：</p>
<ul>
<li><strong>性能较差</strong>：每次访问需要两次请求服务器，增加了访问的延迟。</li>
<li><strong>降低搜索排名</strong>：使用重定向后，搜索引擎会视为 SEO 作弊。</li>
<li>如果负载均衡器宕机，就无法访问该站点。</li>
</ul>
<p>由于其缺点比较明显，所以这种负载均衡策略实际应用较少。</p>
<h4 id="反向代理负载均衡"><a class="markdownIt-Anchor" href="#反向代理负载均衡"></a> 反向代理负载均衡</h4>
<p>反向代理（Reverse Proxy）方式是指以 <strong>代理服务器</strong> 来接受网络请求，然后 <strong>将请求转发给内网中的服务器</strong>，并将从内网中的服务器上得到的结果返回给网络请求的客户端。反向代理负载均衡属于七层负载均衡。</p>
<p>反向代理服务的主流产品：<strong>Nginx</strong>、<strong>Apache</strong>。</p>
<p>正向代理与反向代理有什么区别？</p>
<ul>
<li>正向代理：发生在 <strong>客户端</strong>，是由用户主动发起的。翻墙软件就是典型的正向代理，客户端通过主动访问代理服务器，让代理服务器获得需要的外网数据，然后转发回客户端。</li>
<li>反向代理：发生在 <strong>服务端</strong>，用户不知道代理的存在。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20210117222209.png" alt="img" /></p>
<p>反向代理是如何实现负载均衡的呢？以 Nginx 为例，如下所示：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/web/nginx/nginx-load-balance.png" alt="img" /></p>
<p>首先，在代理服务器上设定好负载均衡规则。然后，当收到客户端请求，反向代理服务器拦截指定的域名或 IP 请求，根据负载均衡算法，将请求分发到候选服务器上。其次，如果某台候选服务器宕机，反向代理服务器会有容错处理，比如分发请求失败 3 次以上，将请求分发到其他候选服务器上。</p>
<p>反向代理的 <strong>优点</strong>：</p>
<ul>
<li><strong>多种负载均衡算法</strong>：支持多种负载均衡算法，以应对不同的场景需求。</li>
<li><strong>可以监控服务器</strong>：基于 HTTP 协议，可以监控转发服务器的状态，如：系统负载、响应时间、是否可用、连接数、流量等，从而根据这些数据调整负载均衡的策略。</li>
</ul>
<p>反向代理的 <strong>缺点</strong>：</p>
<ul>
<li>
<p><strong>额外的转发开销</strong>：反向代理的转发操作本身是有性能开销的，可能会包括创建连接，等待连接响应，分析响应结果等操作。</p>
</li>
<li>
<p><strong>增加系统复杂度</strong>：反向代理常用于做分布式应用的水平扩展，但反向代理服务存在以下问题，为了解决以下问题会给系统整体增加额外的复杂度和运维成本：</p>
<ul>
<li>反向代理服务如果自身宕机，就无法访问站点，所以需要有 <strong>高可用</strong> 方案，常见的方案有：主备模式（一主一备）、双主模式（互为主备）。</li>
<li>反向代理服务自身也存在性能瓶颈，随着需要转发的请求量不断攀升，需要有 <strong>可扩展</strong> 方案。</li>
</ul>
</li>
</ul>
<h4 id="ip-负载均衡"><a class="markdownIt-Anchor" href="#ip-负载均衡"></a> IP 负载均衡</h4>
<p>IP 负载均衡是在网络层通过修改请求目的地址进行负载均衡。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20210119000529.png" alt="img" /></p>
<p>如上图所示，IP 均衡处理流程大致为：</p>
<ol>
<li>客户端请求 192.168.137.10，由负载均衡服务器接收到报文。</li>
<li>负载均衡服务器根据算法选出一个服务节点 192.168.0.1，然后将报文请求地址改为该节点的 IP。</li>
<li>真实服务节点收到请求报文，处理后，返回响应数据到负载均衡服务器。</li>
<li>负载均衡服务器将响应数据的源地址改负载均衡服务器地址，返回给客户端。</li>
</ol>
<p>IP 负载均衡在内核进程完成数据分发，较反向代理负载均衡有更好的从处理性能。但是，由于所有请求响应都要经过负载均衡服务器，集群的吞吐量受制于负载均衡服务器的带宽。</p>
<h4 id="数据链路层负载均衡"><a class="markdownIt-Anchor" href="#数据链路层负载均衡"></a> 数据链路层负载均衡</h4>
<p>数据链路层负载均衡是指在通信协议的数据链路层修改 mac 地址进行负载均衡。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20210117222127.png" alt="img" /></p>
<p>在 Linux 平台上最好的链路层负载均衡开源产品是 LVS (Linux Virtual Server)。</p>
<p>LVS 是基于 Linux 内核中 netfilter 框架实现的负载均衡系统。netfilter 是内核态的 Linux 防火墙机制，可以在数据包流经过程中，根据规则设置若干个关卡（hook 函数）来执行相关的操作。</p>
<p>LVS 的工作流程大致如下：</p>
<ul>
<li>当用户访问 <a href="http://www.sina.com.cn" target="_blank" rel="noopener">www.sina.com.cn</a> 时，用户数据通过层层网络，最后通过交换机进入 LVS 服务器网卡，并进入内核网络层。</li>
<li>进入 PREROUTING 后经过路由查找，确定访问的目的 VIP 是本机 IP 地址，所以数据包进入到 INPUT 链上</li>
<li>IPVS 是工作在 INPUT 链上，会根据访问的 <code>vip+port</code> 判断请求是否 IPVS 服务，如果是则调用注册的 IPVS HOOK 函数，进行 IPVS 相关主流程，强行修改数据包的相关数据，并将数据包发往 POSTROUTING 链上。</li>
<li>POSTROUTING 上收到数据包后，根据目标 IP 地址（后端服务器），通过路由选路，将数据包最终发往后端的服务器上。</li>
</ul>
<p>开源 LVS 版本有 3 种工作模式，每种模式工作原理截然不同，说各种模式都有自己的优缺点，分别适合不同的应用场景，不过最终本质的功能都是能实现均衡的流量调度和良好的扩展性。主要包括三种模式：DR 模式、NAT 模式、Tunnel 模式。</p>
<h2 id="3-负载均衡算法"><a class="markdownIt-Anchor" href="#3-负载均衡算法"></a> 3. 负载均衡算法</h2>
<p>负载均衡器的实现可以分为两个部分：</p>
<ul>
<li>根据负载均衡算法在候选服务器列表选出一个服务器；</li>
<li>将请求数据发送到该服务器上。</li>
</ul>
<p>负载均衡算法是负载均衡服务核心中的核心。负载均衡产品多种多样，但是各种负载均衡算法原理是共性的。</p>
<p>负载均衡算法有很多种，分别适用于不同的应用场景，本文仅介绍最为常见的负载均衡算法的特性及原理：轮询、随机、最小活跃数、源地址哈希、一致性哈希。</p>
<blockquote>
<p>注：负载均衡算法的实现，推荐阅读 <a href="https://dubbo.apache.org/zh/docs/v2.7/dev/source/loadbalance/" target="_blank" rel="noopener">Dubbo 官方负载均衡算法说明</a> ，源码讲解非常详细，非常值得借鉴。</p>
<p>下文中的各种算法的可执行示例已归档在 Github 仓库：<a href="https://github.com/dunwu/java-tutorial/tree/master/codes/java-distributed/java-load-balance%EF%BC%8C%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E6%89%A7%E8%A1%8C" target="_blank" rel="noopener">https://github.com/dunwu/java-tutorial/tree/master/codes/java-distributed/java-load-balance，可以通过执行</a> io.github.dunwu.javatech.LoadBalanceDemo 查看各算法执行效果。</p>
</blockquote>
<h3 id="31-随机"><a class="markdownIt-Anchor" href="#31-随机"></a> 3.1. 随机</h3>
<h4 id="随机算法"><a class="markdownIt-Anchor" href="#随机算法"></a> 随机算法</h4>
<p><strong><code>随机（Random）</code></strong> 算法 <strong>将请求随机分发到候选服务器</strong>。</p>
<p>随机算法 <strong>适合服务器硬件相同的场景</strong>。学习过概率论的都知道，调用量较小的时候，可能负载并不均匀，<strong>调用量越大，负载越均衡</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20210415165323.png" alt="img" /></p>
<p>【示例】随机算法实现示例</p>
<p>负载均衡接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LoadBalance</span>&lt;<span class="title">N</span> <span class="keyword">extends</span> <span class="title">Node</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">N <span class="title">select</span><span class="params">(List&lt;N&gt; nodes, String ip)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>负载均衡抽象类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseLoadBalance</span>&lt;<span class="title">N</span> <span class="keyword">extends</span> <span class="title">Node</span>&gt; <span class="keyword">implements</span> <span class="title">LoadBalance</span>&lt;<span class="title">N</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> N <span class="title">select</span><span class="params">(List&lt;N&gt; nodes, String ip)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtil.isEmpty(nodes)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 nodes 列表中仅有一个 node，直接返回即可，无需进行负载均衡</span></span><br><span class="line">        <span class="keyword">if</span> (nodes.size() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> doSelect(nodes, ip);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> N <span class="title">doSelect</span><span class="params">(List&lt;N&gt; nodes, String ip)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务器节点类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Node</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String url;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Integer weight;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Integer active;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>随机算法实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomLoadBalance</span>&lt;<span class="title">N</span> <span class="keyword">extends</span> <span class="title">Node</span>&gt; <span class="keyword">extends</span> <span class="title">BaseLoadBalance</span>&lt;<span class="title">N</span>&gt; <span class="keyword">implements</span> <span class="title">LoadBalance</span>&lt;<span class="title">N</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> N <span class="title">doSelect</span><span class="params">(List&lt;N&gt; nodes, String ip)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在列表中随机选取一个节点</span></span><br><span class="line">        <span class="keyword">int</span> index = random.nextInt(nodes.size());</span><br><span class="line">        <span class="keyword">return</span> nodes.get(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="加权随机算法"><a class="markdownIt-Anchor" href="#加权随机算法"></a> 加权随机算法</h4>
<p><strong><code>加权随机（Weighted Random）</code></strong> 算法在随机算法的基础上，按照概率调整权重，进行负载分配。</p>
<p>【示例】加权随机算法实现示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeightRandomLoadBalance</span>&lt;<span class="title">N</span> <span class="keyword">extends</span> <span class="title">Node</span>&gt; <span class="keyword">extends</span> <span class="title">BaseLoadBalance</span>&lt;<span class="title">N</span>&gt; <span class="keyword">implements</span> <span class="title">LoadBalance</span>&lt;<span class="title">N</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Random random = ThreadLocalRandom.current();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> N <span class="title">doSelect</span><span class="params">(List&lt;N&gt; nodes, String ip)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> length = nodes.size();</span><br><span class="line">        AtomicInteger totalWeight = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (N node : nodes) &#123;</span><br><span class="line">            Integer weight = node.getWeight();</span><br><span class="line">            totalWeight.getAndAdd(weight);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (totalWeight.get() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> offset = random.nextInt(totalWeight.get());</span><br><span class="line">            <span class="keyword">for</span> (N node : nodes) &#123;</span><br><span class="line">                <span class="comment">// 让随机值 offset 减去权重值</span></span><br><span class="line">                offset -= node.getWeight();</span><br><span class="line">                <span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 返回相应的 Node</span></span><br><span class="line">                    <span class="keyword">return</span> node;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 直接随机返回一个</span></span><br><span class="line">        <span class="keyword">return</span> nodes.get(random.nextInt(length));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="32-轮询"><a class="markdownIt-Anchor" href="#32-轮询"></a> 3.2. 轮询</h3>
<h4 id="轮询算法"><a class="markdownIt-Anchor" href="#轮询算法"></a> 轮询算法</h4>
<p><strong><code>轮询（Round Robin）</code></strong> 算法的策略是：<strong>将请求依次分发到候选服务器</strong>。</p>
<p>如下图所示，负载均衡器收到来自客户端的 6 个请求，(1, 3, 5) 的请求会被发送到服务器 1，(2, 4, 6) 的请求会被发送到服务器 2。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20210415164758.png" alt="img" /></p>
<p>该算法适合场景：各服务器处理能力相近，且每个事务工作量差异不大。如果存在较大差异，那么处理较慢的服务器就可能会积压请求，最终无法承担过大的负载。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20210415165041.png" alt="img" /></p>
<p>【示例】轮询算法示例</p>
<p>轮询负载均衡算法实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoundRobinLoadBalance</span>&lt;<span class="title">N</span> <span class="keyword">extends</span> <span class="title">Node</span>&gt; <span class="keyword">extends</span> <span class="title">BaseLoadBalance</span>&lt;<span class="title">N</span>&gt; <span class="keyword">implements</span> <span class="title">LoadBalance</span>&lt;<span class="title">N</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger position = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> N <span class="title">doSelect</span><span class="params">(List&lt;N&gt; nodes, String ip)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = nodes.size();</span><br><span class="line">        <span class="comment">// 如果位置值已经等于节点数，重置为 0</span></span><br><span class="line">        position.compareAndSet(length, <span class="number">0</span>);</span><br><span class="line">        N node = nodes.get(position.get());</span><br><span class="line">        position.getAndIncrement();</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="加权轮询算法"><a class="markdownIt-Anchor" href="#加权轮询算法"></a> 加权轮询算法</h4>
<p><strong><code>加权轮询（Weighted Round Robbin）</code></strong> 算法在轮询算法的基础上，增加了权重属性来调节转发服务器的请求数目。性能高、处理速度快的节点应该设置更高的权重，使得分发时优先将请求分发到权重较高的节点上。</p>
<p>如下图所示，服务器 A 设置权重为 5，服务器 B 设置权重为 1，负载均衡器收到来自客户端的 6 个请求，那么 (1, 2, 3, 4, 5) 请求会被发送到服务器 A，(6) 请求会被发送到服务器 B。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20210415165140.png" alt="img" /></p>
<p>【示例】加权轮询算法实现示例</p>
<p>以下实现基于 Dubbo 加权轮询算法做了一些简化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeightRoundRobinLoadBalance</span>&lt;<span class="title">N</span> <span class="keyword">extends</span> <span class="title">Node</span>&gt; <span class="keyword">extends</span> <span class="title">BaseLoadBalance</span>&lt;<span class="title">N</span>&gt; <span class="keyword">implements</span> <span class="title">LoadBalance</span>&lt;<span class="title">N</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 60秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RECYCLE_PERIOD = <span class="number">60000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Node hashcode 到 WeightedRoundRobin 的映射关系</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ConcurrentMap&lt;Integer, WeightedRoundRobin&gt; weightMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 原子更新锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> AtomicBoolean updateLock = <span class="keyword">new</span> AtomicBoolean();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> N <span class="title">doSelect</span><span class="params">(List&lt;N&gt; nodes, String ip)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> totalWeight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> maxCurrent = Long.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前时间</span></span><br><span class="line">        <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">        N selectedNode = <span class="keyword">null</span>;</span><br><span class="line">        WeightedRoundRobin selectedWRR = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面这个循环主要做了这样几件事情：</span></span><br><span class="line">        <span class="comment">//   1. 遍历 Node 列表，检测当前 Node 是否有相应的 WeightedRoundRobin，没有则创建</span></span><br><span class="line">        <span class="comment">//   2. 检测 Node 权重是否发生了变化，若变化了，则更新 WeightedRoundRobin 的 weight 字段</span></span><br><span class="line">        <span class="comment">//   3. 让 current 字段加上自身权重，等价于 current += weight</span></span><br><span class="line">        <span class="comment">//   4. 设置 lastUpdate 字段，即 lastUpdate = now</span></span><br><span class="line">        <span class="comment">//   5. 寻找具有最大 current 的 Node，以及 Node 对应的 WeightedRoundRobin，</span></span><br><span class="line">        <span class="comment">//      暂存起来，留作后用</span></span><br><span class="line">        <span class="comment">//   6. 计算权重总和</span></span><br><span class="line">        <span class="keyword">for</span> (N node : nodes) &#123;</span><br><span class="line">            <span class="keyword">int</span> hashCode = node.hashCode();</span><br><span class="line">            WeightedRoundRobin weightedRoundRobin = weightMap.get(hashCode);</span><br><span class="line">            <span class="keyword">int</span> weight = node.getWeight();</span><br><span class="line">            <span class="keyword">if</span> (weight &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                weight = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检测当前 Node 是否有对应的 WeightedRoundRobin，没有则创建</span></span><br><span class="line">            <span class="keyword">if</span> (weightedRoundRobin == <span class="keyword">null</span>) &#123;</span><br><span class="line">                weightedRoundRobin = <span class="keyword">new</span> WeightedRoundRobin();</span><br><span class="line">                <span class="comment">// 设置 Node 权重</span></span><br><span class="line">                weightedRoundRobin.setWeight(weight);</span><br><span class="line">                <span class="comment">// 存储 url 唯一标识 identifyString 到 weightedRoundRobin 的映射关系</span></span><br><span class="line">                weightMap.putIfAbsent(hashCode, weightedRoundRobin);</span><br><span class="line">                weightedRoundRobin = weightMap.get(hashCode);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Node 权重不等于 WeightedRoundRobin 中保存的权重，说明权重变化了，此时进行更新</span></span><br><span class="line">            <span class="keyword">if</span> (weight != weightedRoundRobin.getWeight()) &#123;</span><br><span class="line">                weightedRoundRobin.setWeight(weight);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 让 current 加上自身权重，等价于 current += weight</span></span><br><span class="line">            <span class="keyword">long</span> current = weightedRoundRobin.increaseCurrent();</span><br><span class="line">            <span class="comment">// 设置 lastUpdate，表示近期更新过</span></span><br><span class="line">            weightedRoundRobin.setLastUpdate(now);</span><br><span class="line">            <span class="comment">// 找出最大的 current</span></span><br><span class="line">            <span class="keyword">if</span> (current &gt; maxCurrent) &#123;</span><br><span class="line">                maxCurrent = current;</span><br><span class="line">                <span class="comment">// 将具有最大 current 权重的 Node 赋值给 selectedNode</span></span><br><span class="line">                selectedNode = node;</span><br><span class="line">                <span class="comment">// 将 Node 对应的 weightedRoundRobin 赋值给 selectedWRR，留作后用</span></span><br><span class="line">                selectedWRR = weightedRoundRobin;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算权重总和</span></span><br><span class="line">            totalWeight += weight;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对 weightMap 进行检查，过滤掉长时间未被更新的节点。</span></span><br><span class="line">        <span class="comment">// 该节点可能挂了，nodes 中不包含该节点，所以该节点的 lastUpdate 长时间无法被更新。</span></span><br><span class="line">        <span class="comment">// 若未更新时长超过阈值后，就会被移除掉，默认阈值为60秒。</span></span><br><span class="line">        <span class="keyword">if</span> (!updateLock.get() &amp;&amp; nodes.size() != weightMap.size()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (updateLock.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 遍历修改，即移除过期记录</span></span><br><span class="line">                    weightMap.entrySet().removeIf(item -&gt; now - item.getValue().getLastUpdate() &gt; RECYCLE_PERIOD);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    updateLock.set(<span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (selectedNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 让 current 减去权重总和，等价于 current -= totalWeight</span></span><br><span class="line">            selectedWRR.decreaseCurrent(totalWeight);</span><br><span class="line">            <span class="comment">// 返回具有最大 current 的 Node</span></span><br><span class="line">            <span class="keyword">return</span> selectedNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// should not happen here</span></span><br><span class="line">        <span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WeightedRoundRobin</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 服务提供者权重</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> weight;</span><br><span class="line">        <span class="comment">// 当前权重</span></span><br><span class="line">        <span class="keyword">private</span> AtomicLong current = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 最后一次更新时间</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> lastUpdate;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">increaseCurrent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// current = current + weight；</span></span><br><span class="line">            <span class="keyword">return</span> current.addAndGet(weight);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">decreaseCurrent</span><span class="params">(<span class="keyword">int</span> total)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// current = current - total;</span></span><br><span class="line">            <span class="keyword">return</span> current.addAndGet(-<span class="number">1</span> * total);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> weight;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWeight</span><span class="params">(<span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.weight = weight;</span><br><span class="line">            <span class="comment">// 初始情况下，current = 0</span></span><br><span class="line">            current.set(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> AtomicLong <span class="title">getCurrent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> current;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCurrent</span><span class="params">(AtomicLong current)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.current = current;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getLastUpdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> lastUpdate;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLastUpdate</span><span class="params">(<span class="keyword">long</span> lastUpdate)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.lastUpdate = lastUpdate;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="33-最小活跃数"><a class="markdownIt-Anchor" href="#33-最小活跃数"></a> 3.3. 最小活跃数</h3>
<p><strong><code>最小活跃数（Least Active）</code></strong> 算法 <strong>将请求分发到连接数/请求数最少的候选服务器</strong>（目前处理请求最少的服务器）。</p>
<ul>
<li>特点：根据候选服务器当前的请求连接数，动态分配。</li>
<li>场景：<strong>适用于对系统负载较为敏感或请求连接时长相差较大的场景</strong>。</li>
</ul>
<p>由于每个请求的连接时长不一样，如果采用简单的轮循或随机算法，都可能出现<strong>某些服务器当前连接数过大，而另一些服务器的连接过小</strong>的情况，这就造成了负载并非真正均衡。虽然，轮询或算法都可以通过加权重属性的方式进行负载调整，但加权方式难以应对动态变化。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20210415171432.png" alt="img" /></p>
<p>最小活跃数算法会记录当前时刻，每个候选节点正在处理的连接数，然后选择连接数最小的节点。该策略能够动态、实时地反应服务器的当前状况，较为合理地将负责分配均匀，适用于对当前系统负载较为敏感的场景。</p>
<p>例如下图中，服务器 1 当前连接数最小，那么新到来的请求 6 就会被发送到服务器 1 上。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20210415165935.png" alt="img" /></p>
<p>加权最小活跃数（Weighted Least Connection）在最小活跃数的基础上，根据服务器的性能为每台服务器分配权重，再根据权重计算出每台服务器能处理的连接数。</p>
<p>最小活跃数算法实现要点：活跃调用数越小，表明该服务节点处理能力越高，单位时间内可处理更多的请求，应优先将请求分发给该服务。在具体实现中，每个服务节点对应一个活跃数 active。初始情况下，所有服务提供者活跃数均为 0。每收到一个请求，活跃数加 1，完成请求后则将活跃数减 1。在服务运行一段时间后，性能好的服务提供者处理请求的速度更快，因此活跃数下降的也越快，此时这样的服务提供者能够优先获取到新的服务请求、这就是最小活跃数负载均衡算法的基本思想。</p>
<p>【示例】最小活跃数算法实现</p>
<p>以下实现基于 Dubbo 最小活跃数负载均衡算法做了些许改动。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeastActiveLoadBalance</span>&lt;<span class="title">N</span> <span class="keyword">extends</span> <span class="title">Node</span>&gt; <span class="keyword">extends</span> <span class="title">BaseLoadBalance</span>&lt;<span class="title">N</span>&gt; <span class="keyword">implements</span> <span class="title">LoadBalance</span>&lt;<span class="title">N</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> N <span class="title">doSelect</span><span class="params">(List&lt;N&gt; nodes, String ip)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = nodes.size();</span><br><span class="line">        <span class="comment">// 最小的活跃数</span></span><br><span class="line">        <span class="keyword">int</span> leastActive = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 具有相同“最小活跃数”的服务者提供者（以下用 Node 代称）数量</span></span><br><span class="line">        <span class="keyword">int</span> leastCount = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// leastIndexs 用于记录具有相同“最小活跃数”的 Node 在 nodes 列表中的下标信息</span></span><br><span class="line">        <span class="keyword">int</span>[] leastIndexs = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">int</span> totalWeight = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 第一个最小活跃数的 Node 权重值，用于与其他具有相同最小活跃数的 Node 的权重进行对比，</span></span><br><span class="line">        <span class="comment">// 以检测是否“所有具有相同最小活跃数的 Node 的权重”均相等</span></span><br><span class="line">        <span class="keyword">int</span> firstWeight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> sameWeight = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历 nodes 列表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            N node = nodes.get(i);</span><br><span class="line">            <span class="comment">// 发现更小的活跃数，重新开始</span></span><br><span class="line">            <span class="keyword">if</span> (leastActive == -<span class="number">1</span> || node.getActive() &lt; leastActive) &#123;</span><br><span class="line">                <span class="comment">// 使用当前活跃数更新最小活跃数 leastActive</span></span><br><span class="line">                leastActive = node.getActive();</span><br><span class="line">                <span class="comment">// 更新 leastCount 为 1</span></span><br><span class="line">                leastCount = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 记录当前下标值到 leastIndexs 中</span></span><br><span class="line">                leastIndexs[<span class="number">0</span>] = i;</span><br><span class="line">                totalWeight = node.getWeight();</span><br><span class="line">                firstWeight = node.getWeight();</span><br><span class="line">                sameWeight = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 当前 Node 的活跃数 node.getActive() 与最小活跃数 leastActive 相同</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.getActive() == leastActive) &#123;</span><br><span class="line">                <span class="comment">// 在 leastIndexs 中记录下当前 Node 在 nodes 集合中的下标</span></span><br><span class="line">                leastIndexs[leastCount++] = i;</span><br><span class="line">                <span class="comment">// 累加权重</span></span><br><span class="line">                totalWeight += node.getWeight();</span><br><span class="line">                <span class="comment">// 检测当前 Node 的权重与 firstWeight 是否相等，</span></span><br><span class="line">                <span class="comment">// 不相等则将 sameWeight 置为 false</span></span><br><span class="line">                <span class="keyword">if</span> (sameWeight &amp;&amp; i &gt; <span class="number">0</span></span><br><span class="line">                    &amp;&amp; node.getWeight() != firstWeight) &#123;</span><br><span class="line">                    sameWeight = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当只有一个 Node 具有最小活跃数，此时直接返回该 Node 即可</span></span><br><span class="line">        <span class="keyword">if</span> (leastCount == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nodes.get(leastIndexs[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有多个 Node 具有相同的最小活跃数，但它们之间的权重不同</span></span><br><span class="line">        <span class="keyword">if</span> (!sameWeight &amp;&amp; totalWeight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 随机生成一个 [0, totalWeight) 之间的数字</span></span><br><span class="line">            <span class="keyword">int</span> offsetWeight = random.nextInt(totalWeight);</span><br><span class="line">            <span class="comment">// 循环让随机数减去具有最小活跃数的 Node 的权重值，</span></span><br><span class="line">            <span class="comment">// 当 offset 小于等于0时，返回相应的 Node</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; leastCount; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> leastIndex = leastIndexs[i];</span><br><span class="line">                <span class="comment">// 获取权重值，并让随机数减去权重值</span></span><br><span class="line">                offsetWeight -= nodes.get(leastIndex).getWeight();</span><br><span class="line">                <span class="keyword">if</span> (offsetWeight &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> nodes.get(leastIndex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果权重相同或权重为0时，随机返回一个 Node</span></span><br><span class="line">        <span class="keyword">return</span> nodes.get(leastIndexs[random.nextInt(leastCount)]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="34-哈希"><a class="markdownIt-Anchor" href="#34-哈希"></a> 3.4. 哈希</h3>
<p><code>哈希（IP Hash）</code> 算法<strong>根据一个 key （可以是唯一 ID、IP 等），通过哈希计算得到一个数值，用该数值在候选服务器列表的进行取模运算，得到的结果便是选中的服务器</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20210415172716.png" alt="img" /></p>
<p>可以保证同一 IP 的客户端的请求会转发到同一台服务器上，用来实现会话粘滞（Sticky Session）。</p>
<ul>
<li>特点：保证特定用户总是请求到相同的服务器，若服务器宕机，会话会丢失。</li>
</ul>
<p>【示例】源地址哈希算法实现示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IpHashLoadBalance</span>&lt;<span class="title">N</span> <span class="keyword">extends</span> <span class="title">Node</span>&gt; <span class="keyword">extends</span> <span class="title">BaseLoadBalance</span>&lt;<span class="title">N</span>&gt; <span class="keyword">implements</span> <span class="title">LoadBalance</span>&lt;<span class="title">N</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> N <span class="title">doSelect</span><span class="params">(List&lt;N&gt; nodes, String ip)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(ip)) &#123;</span><br><span class="line">            ip = <span class="string">"127.0.0.1"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> length = nodes.size();</span><br><span class="line">        <span class="keyword">int</span> index = hash(ip) % length;</span><br><span class="line">        <span class="keyword">return</span> nodes.get(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> HashUtil.fnvHash(text);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="35-一致性哈希"><a class="markdownIt-Anchor" href="#35-一致性哈希"></a> 3.5. 一致性哈希</h3>
<p>一致性哈希（Consistent Hash）算法的目标是：<strong>相同的请求尽可能落到同一个服务器上</strong>。</p>
<p><strong>一致性哈希</strong> 可以很好的解决 <strong>稳定性问题</strong>，可以将所有的 <strong>存储节点</strong> 排列在 <strong>首尾相接</strong> 的 <code>Hash</code> 环上，每个 <code>key</code> 在计算 <code>Hash</code> 后会 <strong>顺时针</strong> 找到 <strong>临接</strong> 的 <strong>存储节点</strong> 存放。而当有节点 <strong>加入</strong> 或 <strong>退出</strong> 时，仅影响该节点在 <code>Hash</code> 环上 <strong>顺时针相邻</strong> 的 <strong>后续节点</strong>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/architecture/partition-consistent-hash.png" alt="img" /></p>
<ul>
<li>相同的请求是指：一般在使用一致性哈希时，需要指定一个 key 用于 hash 计算，可能是：
<ul>
<li>用户 ID</li>
<li>请求方 IP</li>
<li>请求服务名称，参数列表构成的串</li>
</ul>
</li>
<li>尽可能是指：服务器可能发生上下线，少数服务器的变化不应该影响大多数的请求。</li>
</ul>
<p>当某台候选服务器宕机时，原本发往该服务器的请求，会基于虚拟节点，平摊到其它候选服务器，不会引起剧烈变动。</p>
<ul>
<li><strong>优点</strong></li>
</ul>
<p><strong>加入</strong> 和 <strong>删除</strong> 节点只影响 <strong>哈希环</strong> 中 <strong>顺时针方向</strong> 的 <strong>相邻的节点</strong>，对其他节点无影响。</p>
<ul>
<li><strong>缺点</strong></li>
</ul>
<p><strong>加减节点</strong> 会造成 <strong>哈希环</strong> 中部分数据 <strong>无法命中</strong>。当使用 <strong>少量节点</strong> 时，<strong>节点变化</strong> 将大范围影响 <strong>哈希环</strong> 中 <strong>数据映射</strong>，不适合 <strong>少量数据节点</strong> 的分布式方案。<strong>普通</strong> 的 <strong>一致性哈希分区</strong> 在增减节点时需要 <strong>增加一倍</strong> 或 <strong>减去一半</strong> 节点才能保证 <strong>数据</strong> 和 <strong>负载的均衡</strong>。</p>
<blockquote>
<p><strong>注意</strong>：因为 <strong>一致性哈希分区</strong> 的这些缺点，一些分布式系统采用 <strong>虚拟槽</strong> 对 <strong>一致性哈希</strong> 进行改进，比如 <code>Dynamo</code> 系统。</p>
</blockquote>
<p>【示例】一致性哈希算法示例</p>
<p>以下示例基于 Dubbo 的一致性哈希负载均衡算法做了一些简化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsistentHashLoadBalance</span>&lt;<span class="title">N</span> <span class="keyword">extends</span> <span class="title">Node</span>&gt; <span class="keyword">extends</span> <span class="title">BaseLoadBalance</span>&lt;<span class="title">N</span>&gt; <span class="keyword">implements</span> <span class="title">LoadBalance</span>&lt;<span class="title">N</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, ConsistentHashSelector&lt;?&gt;&gt; selectors = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> N <span class="title">doSelect</span><span class="params">(List&lt;N&gt; nodes, String ip)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 分片数，这里设为节点数的 4 倍</span></span><br><span class="line">        Integer replicaNum = nodes.size() * <span class="number">4</span>;</span><br><span class="line">        <span class="comment">// 获取 nodes 原始的 hashcode</span></span><br><span class="line">        <span class="keyword">int</span> identityHashCode = System.identityHashCode(nodes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 nodes 是一个新的 List 对象，意味着节点数量发生了变化</span></span><br><span class="line">        <span class="comment">// 此时 selector.identityHashCode != identityHashCode 条件成立</span></span><br><span class="line">        ConsistentHashSelector&lt;N&gt; selector = (ConsistentHashSelector&lt;N&gt;) selectors.get(ip);</span><br><span class="line">        <span class="keyword">if</span> (selector == <span class="keyword">null</span> || selector.identityHashCode != identityHashCode) &#123;</span><br><span class="line">            <span class="comment">// 创建新的 ConsistentHashSelector</span></span><br><span class="line">            selectors.put(ip, <span class="keyword">new</span> ConsistentHashSelector&lt;&gt;(nodes, identityHashCode, replicaNum));</span><br><span class="line">            selector = (ConsistentHashSelector&lt;N&gt;) selectors.get(ip);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用 ConsistentHashSelector 的 select 方法选择 Node</span></span><br><span class="line">        <span class="keyword">return</span> selector.select(ip);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一致性哈希选择器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsistentHashSelector</span>&lt;<span class="title">N</span> <span class="keyword">extends</span> <span class="title">Node</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 存储虚拟节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> TreeMap&lt;Long, N&gt; virtualNodes;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> identityHashCode;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 构造器</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> nodes            节点列表</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> identityHashCode hashcode</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> replicaNum       分片数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ConsistentHashSelector(List&lt;N&gt; nodes, <span class="keyword">int</span> identityHashCode, Integer replicaNum) &#123;</span><br><span class="line">            <span class="keyword">this</span>.virtualNodes = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">            <span class="keyword">this</span>.identityHashCode = identityHashCode;</span><br><span class="line">            <span class="comment">// 获取虚拟节点数，默认为 100</span></span><br><span class="line">            <span class="keyword">if</span> (replicaNum == <span class="keyword">null</span>) &#123;</span><br><span class="line">                replicaNum = <span class="number">100</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (N node : nodes) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; replicaNum / <span class="number">4</span>; i++) &#123;</span><br><span class="line">                    <span class="comment">// 对 url 进行 md5 运算，得到一个长度为16的字节数组</span></span><br><span class="line">                    <span class="keyword">byte</span>[] digest = md5(node.getUrl());</span><br><span class="line">                    <span class="comment">// 对 digest 部分字节进行 4 次 hash 运算，得到四个不同的 long 型正整数</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                        <span class="comment">// h = 0 时，取 digest 中下标为 0 ~ 3 的4个字节进行位运算</span></span><br><span class="line">                        <span class="comment">// h = 1 时，取 digest 中下标为 4 ~ 7 的4个字节进行位运算</span></span><br><span class="line">                        <span class="comment">// h = 2, h = 3 时过程同上</span></span><br><span class="line">                        <span class="keyword">long</span> m = hash(digest, j);</span><br><span class="line">                        <span class="comment">// 将 hash 到 node 的映射关系存储到 virtualNodes 中，</span></span><br><span class="line">                        <span class="comment">// virtualNodes 需要提供高效的查询操作，因此选用 TreeMap 作为存储结构</span></span><br><span class="line">                        virtualNodes.put(m, node);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> N <span class="title">select</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 对参数 key 进行 md5 运算</span></span><br><span class="line">            <span class="keyword">byte</span>[] digest = md5(key);</span><br><span class="line">            <span class="comment">// 取 digest 数组的前四个字节进行 hash 运算，再将 hash 值传给 selectForKey 方法，</span></span><br><span class="line">            <span class="comment">// 寻找合适的 Node</span></span><br><span class="line">            <span class="keyword">return</span> selectForKey(hash(digest, <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> N <span class="title">selectForKey</span><span class="params">(<span class="keyword">long</span> hash)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 查找第一个大于或等于当前 hash 的节点</span></span><br><span class="line">            Map.Entry&lt;Long, N&gt; entry = virtualNodes.ceilingEntry(hash);</span><br><span class="line">            <span class="comment">// 如果 hash 大于 Node 在哈希环上最大的位置，此时 entry = null，</span></span><br><span class="line">            <span class="comment">// 需要将 TreeMap 的头节点赋值给 entry</span></span><br><span class="line">            <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">                entry = virtualNodes.firstEntry();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 返回 Node</span></span><br><span class="line">            <span class="keyword">return</span> entry.getValue();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算 hash 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">hash</span><span class="params">(<span class="keyword">byte</span>[] digest, <span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (((<span class="keyword">long</span>) (digest[<span class="number">3</span> + number * <span class="number">4</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">24</span>)</span><br><span class="line">            | ((<span class="keyword">long</span>) (digest[<span class="number">2</span> + number * <span class="number">4</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">16</span>)</span><br><span class="line">            | ((<span class="keyword">long</span>) (digest[<span class="number">1</span> + number * <span class="number">4</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">8</span>)</span><br><span class="line">            | (digest[number * <span class="number">4</span>] &amp; <span class="number">0xFF</span>))</span><br><span class="line">            &amp; <span class="number">0xFFFFFFFFL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算 MD5 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] md5(String value) &#123;</span><br><span class="line">        MessageDigest md5;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            md5 = MessageDigest.getInstance(<span class="string">"MD5"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">        md5.reset();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = value.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        md5.update(bytes);</span><br><span class="line">        <span class="keyword">return</span> md5.digest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-参考资料"><a class="markdownIt-Anchor" href="#4-参考资料"></a> 4. 参考资料</h2>
<ul>
<li><a href="https://www.youtube.com/watch?reload=9&amp;app=desktop&amp;v=iqOTT7_7qXY" target="_blank" rel="noopener">Comparing Load Balancing Algorithms</a></li>
<li><a href="https://item.jd.com/11322972.html" target="_blank" rel="noopener">《大型网站技术架构：核心原理与案例分析》</a></li>
<li><a href="https://www.cnblogs.com/itfly8/p/5043435.html" target="_blank" rel="noopener">大型网站架构系列：负载均衡详解（1）</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/32841479" target="_blank" rel="noopener">什么是负载均衡</a></li>
<li><a href="https://avinetworks.com/what-is-load-balancing/" target="_blank" rel="noopener">What Is Load Balancing</a></li>
<li><a href="https://dubbo.apache.org/zh/docs/v2.7/dev/source/loadbalance/" target="_blank" rel="noopener">Dubbo 官方负载均衡算法说明</a></li>
<li><a href="https://segmentfault.com/a/1190000004492447" target="_blank" rel="noopener">负载均衡算法及手段</a></li>
<li><a href="https://segmentfault.com/a/1190000002578457" target="_blank" rel="noopener">利用 dns 解析来实现网站的负载均衡</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/2018/07/05/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E6%A6%82%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2018/07/05/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E6%A6%82%E8%BF%B0/" class="post-title-link" itemprop="url">系统架构概述</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-05 15:11:00" itemprop="dateCreated datePublished" datetime="2018-07-05T15:11:00+08:00">2018-07-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-14 16:45:53" itemprop="dateModified" datetime="2022-04-14T16:45:53+08:00">2022-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2018/07/05/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E6%A6%82%E8%BF%B0/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/07/05/系统架构概述/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="系统架构概述"><a class="markdownIt-Anchor" href="#系统架构概述"></a> 系统架构概述</h1>
<h2 id="1-大型系统架构演化"><a class="markdownIt-Anchor" href="#1-大型系统架构演化"></a> 1. 大型系统架构演化</h2>
<p>一个大型系统的架构是一个渐进的演化过程。罗马不是一天建成的，同理，微信、淘宝等大型系统绝不是一蹴而就的。随着业务的不断发展，用户体量的增加，系统的复杂度势必不断攀升，最终迫使系统架构进化，以应对挑战。</p>
<p>了解大型系统架构的演化过程，有利于我们了解架构进化的发展规律和业界一些成熟的应对方案。帮助我们在实际工作中，如何去思考架构，如何去凝练解决方案。</p>
<p>大型系统架构演化比较具有代表性的就是大型网站的演化过程。这里介绍一下大型网站演化的一般规律。</p>
<h3 id="11-单机架构"><a class="markdownIt-Anchor" href="#11-单机架构"></a> 1.1. 单机架构</h3>
<ul>
<li><strong>问题</strong>：网站运营初期，访问用户少，一台服务器绰绰有余。</li>
<li><strong>特征</strong>：<strong>应用程序、数据库、文件等所有的资源都在一台服务器上。</strong></li>
<li><strong>描述</strong>：通常服务器操作系统使用 linux，应用程序使用 PHP 开发，然后部署在 Apache 上，数据库使用 Mysql，通俗称为 LAMP。汇集各种免费开源软件以及一台廉价服务器就可以开始系统的发展之路了。</li>
</ul>
<img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20211102174033.png" style="width: 500px" />
<h3 id="12-应用服务和数据服务分离"><a class="markdownIt-Anchor" href="#12-应用服务和数据服务分离"></a> 1.2. 应用服务和数据服务分离</h3>
<ul>
<li><strong>问题</strong>：越来越多的用户访问导致性能越来越差，越来越多的数据导致存储空间不足，一台服务器已不足以支撑。</li>
<li><strong>特征</strong>：<strong>应用服务器、数据库服务器、文件服务器分别独立部署。</strong></li>
<li><strong>描述</strong>：三台服务器对性能要求各不相同：
<ul>
<li>应用服务器要处理大量业务逻辑，因此需要更快更强大的 CPU；</li>
<li>数据库服务器需要快速磁盘检索和数据缓存，因此需要更快的硬盘和更大的内存；</li>
<li>文件服务器需要存储大量文件，因此需要更大容量的硬盘。</li>
</ul>
</li>
</ul>
<img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20211102174220.png" style="width: 500px" />
<h3 id="13-使用缓存改善性能"><a class="markdownIt-Anchor" href="#13-使用缓存改善性能"></a> 1.3. 使用缓存改善性能</h3>
<ul>
<li><strong>问题</strong>：随着用户逐渐增多，数据库压力太大导致访问延迟。</li>
<li><strong>特征</strong>：由于网站访问和财富分配一样遵循二八定律：<em>80% 的业务访问集中在 20% 的数据上</em>。<strong>将数据库中访问较集中的少部分数据缓存在内存中，可以减少数据库的访问次数，降低数据库的访问压力。</strong></li>
<li><strong>描述</strong>：缓存分为两种：应用服务器上的本地缓存和分布式缓存服务器上的远程缓存。
<ul>
<li>本地缓存访问速度更快，但缓存数据量有限，同时存在与应用程序争用内存的情况。</li>
<li>分布式缓存可以采用集群方式，理论上可以做到不受内存容量限制的缓存服务。</li>
</ul>
</li>
</ul>
<img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20211102174506.png" style="width: 500px" />
<h3 id="14-负载均衡"><a class="markdownIt-Anchor" href="#14-负载均衡"></a> 1.4. 负载均衡</h3>
<ul>
<li><strong>问题</strong>：使用缓存后，数据库访问压力得到有效缓解。但是单一应用服务器能够处理的请求连接有限，在访问高峰期，成为瓶颈。</li>
<li><strong>特征</strong>：<strong>多台服务器通过负载均衡同时向外部提供服务，解决单一服务器处理能力和存储空间不足的问题。</strong></li>
<li><strong>描述</strong>：使用集群是系统解决高并发、海量数据问题的常用手段。通过向集群中追加资源，提升系统的并发处理能力，使得服务器的负载压力不再成为整个系统的瓶颈。</li>
</ul>
<img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20211102174630.png" style="width: 800px" />
<h3 id="15-数据库读写分离"><a class="markdownIt-Anchor" href="#15-数据库读写分离"></a> 1.5. 数据库读写分离</h3>
<ul>
<li><strong>问题</strong>：网站使用缓存后，使绝大部分数据读操作访问都可以不通过数据库就能完成，但是仍有一部分读操作和全部的写操作需要访问数据库，在网站的用户达到一定规模后，数据库因为负载压力过高而成为网站的瓶颈。</li>
<li><strong>特征</strong>：目前大部分的主流数据库都提供主从热备功能，通过配置两台数据库主从关系，可以将一台数据库服务器的数据更新同步到一台服务器上。<strong>网站利用数据库的主从热备功能，实现数据库读写分离，从而改善数据库负载压力。</strong></li>
<li><strong>描述</strong>：应用服务器在写操作的时候，访问主数据库，主数据库通过主从复制机制将数据更新同步到从数据库。这样当应用服务器在读操作的时候，访问从数据库获得数据。为了便于应用程序访问读写分离后的数据库，通常在应用服务器端使用专门的数据访问模块，使数据库读写分离的对应用透明。</li>
</ul>
<img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20211102174744.png" style="width: 800px" />
<h3 id="16-多级缓存"><a class="markdownIt-Anchor" href="#16-多级缓存"></a> 1.6. 多级缓存</h3>
<ul>
<li><strong>问题</strong>：中国网络环境复杂，不同地区的用户访问网站时，速度差别也极大。</li>
<li><strong>特征</strong>：<strong>采用 CDN 和反向代理加快系统的静态资源访问速度。</strong></li>
<li><strong>描述</strong>：CDN 和反向代理的基本原理都是缓存，区别在于：
<ul>
<li>CDN 部署在网络提供商的机房，使用户在请求网站服务时，可以从距离自己最近的网络提供商机房获取数据；</li>
<li>而反向代理则部署在网站的中心机房，当用户请求到达中心机房后，首先访问的服务器时反向代理服务器，如果反向代理服务器中缓存着用户请求的资源，就将其直接返回给用户。</li>
</ul>
</li>
</ul>
<img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20211102174848.png" style="width: 800px" />
<h3 id="17-业务拆分"><a class="markdownIt-Anchor" href="#17-业务拆分"></a> 1.7. 业务拆分</h3>
<ul>
<li><strong>问题</strong>：大型网站的业务场景日益复杂，分为多个产品线。</li>
<li><strong>特征</strong>：采用分而治之的手段将整个网站业务分成不同的产品线。<strong>系统上按照业务进行拆分改造，应用服务器按照业务区分进行分别部署。</strong></li>
<li><strong>描述</strong>：应用之间可以通过超链接建立关系，也可以通过消息队列进行数据分发，当然更多的还是通过访问同一个数据存储系统来构成一个关联的完整系统。
<ul>
<li><strong>纵向拆分</strong>：<strong>将一个大应用拆分为多个小应用</strong>，如果新业务较为独立，那么就直接将其设计部署为一个独立的 Web 应用系统。纵向拆分相对较为简单，通过梳理业务，将较少相关的业务剥离即可。</li>
<li><strong>横向拆分</strong>：<strong>将复用的业务拆分出来，独立部署为分布式服务</strong>，新增业务只需要调用这些分布式服务横向拆分需要识别可复用的业务，设计服务接口，规范服务依赖关系。</li>
</ul>
</li>
</ul>
<img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20211102175001.png" style="width: 800px" />
<h3 id="18-分库分表"><a class="markdownIt-Anchor" href="#18-分库分表"></a> 1.8. 分库分表</h3>
<ul>
<li><strong>问题</strong>：随着大型网站业务持续增长，数据库经过读写分离，从一台服务器拆分为两台服务器，依然不能满足需求。</li>
<li><strong>特征</strong>：<strong>数据库采用分布式数据库。</strong></li>
<li><strong>描述</strong>：分布式数据库是数据库拆分的最后方法，只有在单表数据规模非常庞大的时候才使用。不到不得已时，更常用的数据库拆分手段是业务分库，将不同的业务数据库部署在不同的物理服务器上。</li>
</ul>
<img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20211102175326.png" style="width: 800px" />
<h3 id="19-分布式组件"><a class="markdownIt-Anchor" href="#19-分布式组件"></a> 1.9. 分布式组件</h3>
<ul>
<li><strong>问题</strong>：随着网站业务越来越复杂，对数据存储和检索的需求也越来越复杂。</li>
<li><strong>特征</strong>：<strong>系统引入 NoSQL 数据库及搜索引擎。</strong></li>
<li><strong>描述</strong>：NoSQL 数据库及搜索引擎对可伸缩的分布式特性具有更好的支持。应用服务器通过统一数据访问模块访问各种数据，减轻应用程序管理诸多数据源的麻烦。</li>
</ul>
<img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20211102175125.png" style="width: 800px" />
<h3 id="110-微服务"><a class="markdownIt-Anchor" href="#110-微服务"></a> 1.10. 微服务</h3>
<ul>
<li><strong>问题</strong>：随着业务越拆越小，存储系统越来越庞大，应用系统整体复杂程度呈指数级上升，部署维护越来越困难。由于所有应用要和所有数据库系统连接，最终导致数据库连接资源不足，拒绝服务。</li>
<li><strong>特征</strong>：<strong>公共业务提取出来，独立部署。由这些可复用的业务连接数据库，通过分布式服务提供共用业务服务。</strong></li>
<li>描述：大型网站的架构演化到这里，基本上大多数的技术问题都得以解决，诸如跨数据中心的实时数据同步和具体网站业务相关的问题也都可以组合改进现有技术架构来解决。</li>
</ul>
<img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20211102175430.png" style="width: 1024px" />
<h2 id="2-架构设计的考量"><a class="markdownIt-Anchor" href="#2-架构设计的考量"></a> 2. 架构设计的考量</h2>
<blockquote>
<p><strong>每一个模式描述了一个不但重复发生的问题及该问题解决方案的核心。这样，就可以不断复用该方案而减少重复工作</strong>。</p>
</blockquote>
<h3 id="21-什么是架构"><a class="markdownIt-Anchor" href="#21-什么是架构"></a> 2.1. 什么是架构</h3>
<p>架构是一个非常抽象的概念，每个人由于技术的深度、思维的视角等差异，对于架构的理解，各不相同。</p>
<p>这里摘抄网上某段比较精髓的定义：</p>
<ul>
<li><strong>架构是软件系统的顶层设计</strong>。</li>
<li><strong>框架是面向编程或配置的半成品</strong>。</li>
<li><strong>组件是从技术维度上的复用</strong>。</li>
<li><strong>模块是从业务维度上职责的划分</strong>。</li>
<li><strong>系统是相互协同可运行的实体</strong>。</li>
</ul>
<h3 id="22-架构设计的目标"><a class="markdownIt-Anchor" href="#22-架构设计的目标"></a> 2.2. 架构设计的目标</h3>
<p><strong>架构设计的主要目的是为了解决软件系统复杂度带来的问题</strong>。</p>
<p>架构设计应该<strong>按需设计</strong>。任何网站都是随着业务逐步发展，不断演化而成，不要指望一劳永逸。</p>
<p>关于架构设计的目的，常见的<strong>误区</strong>有：</p>
<ul>
<li>因为架构很重要，所以要做架构设计</li>
<li>为了高性能、高可用、可扩展，所以要做架构设计</li>
<li>大厂都是这么做的，所以我们也这么做</li>
<li>这种新技术很牛逼，我们也一定要引入</li>
</ul>
<p>架构的原则：</p>
<ul>
<li>架构设计应该<strong>按需设计</strong>。任何网站都是随着业务逐步发展，不断演化而成，不要指望一劳永逸。</li>
<li><strong>驱动技术发展的主要力量是业务发展</strong>。</li>
<li><strong>不要盲目跟风</strong>大公司的解决方案。</li>
<li><strong>不要盲目追求流行技术</strong>，而脱离了业务发展的实际情况。</li>
<li><strong>不要把所有问题都丢给技术</strong>。现实中，有很多案例告诉我们，很多问题不一定需要通过技术来解决。归根结底，技术始终都是业务的辅助，业务问题究竟是通过技术来解决还是直接通过业务来解决，需要根据实际情况去分析判断。这就需要对业务领域有比较深入的理解和思考。</li>
</ul>
<h3 id="23-架构设计的原则"><a class="markdownIt-Anchor" href="#23-架构设计的原则"></a> 2.3. 架构设计的原则</h3>
<blockquote>
<p>合适优于先进&gt;演化优于一步到位&gt;简单优于复杂</p>
</blockquote>
<h4 id="231-合适原则"><a class="markdownIt-Anchor" href="#231-合适原则"></a> 2.3.1. 合适原则</h4>
<p>没那么多人，却想干那么多活，是失败的第一个主要原因。</p>
<p>没有那么多积累，却想一步登天，是失败的第二个主要原因。</p>
<p>没有那么卓越的业务场景，却幻想灵光一闪成为天才，是失败的第三个主要原因。</p>
<h4 id="232-简单原则"><a class="markdownIt-Anchor" href="#232-简单原则"></a> 2.3.2. 简单原则</h4>
<p>再高大上的解决方案如果不能落地，也是白扯。</p>
<p>所以，应对需求</p>
<h4 id="233-演化原则"><a class="markdownIt-Anchor" href="#233-演化原则"></a> 2.3.3. 演化原则</h4>
<p>演化优于一步到位。</p>
<p>不要妄图设计一个一步到位，永久不变的架构。</p>
<h4 id="234-墨菲定律"><a class="markdownIt-Anchor" href="#234-墨菲定律"></a> 2.3.4. 墨菲定律</h4>
<ul>
<li>任何事都没有表面看起来那么简单；</li>
<li>所有的事都会比你预计的时间长；</li>
<li>会出错的事总会出错；</li>
<li>如果你担心某种情况发生，那么它就更有可能发生。</li>
</ul>
<h4 id="235-康威定律"><a class="markdownIt-Anchor" href="#235-康威定律"></a> 2.3.5. 康威定律</h4>
<p>系统设计(产品结构)等同组织形式，每个设计系统的组织，其产生的设计等同于组织之间的沟通结构（简单点说就是，系统的设计受限于设计系统的组织的人员架构形式。</p>
<h4 id="236-二八定律"><a class="markdownIt-Anchor" href="#236-二八定律"></a> 2.3.6. 二八定律</h4>
<h3 id="24-高性能"><a class="markdownIt-Anchor" href="#24-高性能"></a> 2.4. 高性能</h3>
<blockquote>
<p>性能是软件系统的重要衡量标准。很多扩展性、伸缩性、可用性的问题，是为了解决性能问题而引入的。</p>
</blockquote>
<h4 id="241-性能指标"><a class="markdownIt-Anchor" href="#241-性能指标"></a> 2.4.1. 性能指标</h4>
<p>响应延时、并发处理能力、内存、CPU、IO 开销等都可以视为系统的性能指标。</p>
<p>分析用户体量、日访问量的峰值，估算出为了平稳应对峰值访问流量所需的并发量、吞吐量。如果是应用型系统，性能够用就好，没必要一味追求高性能。比如：用户体量可能还不过万，一天总访问量可能也就一两千 PV，峰值也就几百 QPS，这样的系统如果要考虑每秒几万的 QPS，显然有些多虑了。</p>
<h4 id="242-性能提升手段"><a class="markdownIt-Anchor" href="#242-性能提升手段"></a> 2.4.2. 性能提升手段</h4>
<p>常见的性能提升手段有：</p>
<ul>
<li>前端
<ul>
<li>浏览器缓存</li>
<li>静态资源压缩</li>
<li>合理布局页面</li>
<li>减少 cookie 传输</li>
<li>CDN</li>
</ul>
</li>
<li>应用服务
<ul>
<li>负载均衡和反向代理</li>
<li>本地缓存</li>
<li>分布式缓存</li>
<li>异步消息队列</li>
<li>集群</li>
<li>代码层面：使用多线程、改善内存管理</li>
</ul>
</li>
<li>数据库
<ul>
<li>索引</li>
<li>数据库缓存</li>
<li>SQL 优化</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意：<strong>缓存是改善软件性能的第一手段</strong>。缓存除了可以加快数据访问速度以外，还可以减轻后端应用和数据存储的负载压力。所以，如果要提升系统性能，应该第一时间想到缓存。</p>
<p>使用缓存有两个前提：</p>
<ul>
<li>数据访问热点不均匀，频繁访问的数据应该放在缓存中。</li>
<li>数据在某个时间段有效，不过很快过期，否则缓存数据会因已经失效而产生脏读。</li>
</ul>
</blockquote>
<h3 id="25-高可用"><a class="markdownIt-Anchor" href="#25-高可用"></a> 2.5. 高可用</h3>
<blockquote>
<p>系统无中断地执行其功能的能力，代表系统的可用性程度，是进行系统设计时的准则之一。</p>
</blockquote>
<p><strong>高性能增加机器目的在于“扩展”处理性能；高可用增加机器目的在于“冗余”处理单元</strong>。</p>
<p>单点系统，是无法保证高可用的。系统自身故障、断电、硬件故障、网络等等，都可能导致服务不可用。高可用方案五花八门，本质上都是通过“<strong>冗余</strong>”来实现高可用。</p>
<h4 id="251-无状态应用的高可用"><a class="markdownIt-Anchor" href="#251-无状态应用的高可用"></a> 2.5.1. 无状态应用的高可用</h4>
<p>无状态应用一般具有幂等性，即**无论在哪台机器上进行计算，同样的算法和输入数据，产出的结果都是一样的。**所以，计算在任意节点服务器上执行，结果都一样。</p>
<p>无状态应用的高可用：</p>
<ul>
<li>需要增加一个任务分配器，选择合适的任务分配器也是一件复杂的事情，需要综合考虑性能、成本、可维护性、可用性等各方面因素。</li>
<li>任务分配器和真正的业务服务器之间有连接和交互，需要选择合适的连接方式，并且对连接进行管理。例如，连接建立、连接检测、连接中断后如何处理等。</li>
<li>任务分配器需要增加分配算法。例如，常见的双机算法有主备、主主，主备方案又可以细分为冷备、温备、热备。</li>
</ul>
<h4 id="252-有状态应用的高可用"><a class="markdownIt-Anchor" href="#252-有状态应用的高可用"></a> 2.5.2. 有状态应用的高可用</h4>
<p>有状态应用，是指需要存储数据的系统，比如各种分布式存储。和无状态应用相比，有一个本质上的区别：<strong>各节点需要通过同步保持数据一致</strong>。分布式领域里面有一个著名的 CAP 定理，从理论上论证了存储高可用的复杂度。也就是说，存储高可用不可能同时满足“一致性、可用性、分区容错性”，最多满足其中两个，这就要求我们在做架构设计时结合业务进行取舍。</p>
<h4 id="253-高可用手段"><a class="markdownIt-Anchor" href="#253-高可用手段"></a> 2.5.3. 高可用手段</h4>
<p>高可用的常用手段：</p>
<ul>
<li><strong>负载均衡</strong> - 通过负载均衡设备建立集群共同对外提供服务。</li>
<li><strong>备份</strong> - 数据存储在多台服务器，互相备份。即使访问和负载很小的服务也必须部署至少两台服务器，构成一个集群，目的就是通过冗余实现服务的高可用。
<ul>
<li><strong>冷备份</strong> - 数据应该定期备份；</li>
<li><strong>热备份</strong> - 为了保证在线业务高可用，还需要对数据库进行主从分离，实时同步 。</li>
<li><strong>灾备</strong> - 为了抵御地震、海啸等不可抗因素导致的网站完全瘫痪，某些大型网站会对整个数据中心进行备份，全球范围内部署 <strong>灾备数据中心</strong>。网站程序和数据实时同步到多个灾备数据中心。</li>
</ul>
</li>
<li><strong>自动化</strong> - 自动化是指，大型系统有必要通过预发布验证、自动化测试、自动化发布、灰度发布等手段，减少将故障引入线上环境的可能。常见自动化手段有：
<ul>
<li>发布过程自动化
<ul>
<li>自动化代码管理</li>
<li>自动化测试</li>
<li>自动化安全监测</li>
<li>自动化部署</li>
</ul>
</li>
<li>运维自动化
<ul>
<li>自动化监控</li>
<li>自动化报警</li>
<li>自动化失效转移</li>
<li>自动化失效恢复</li>
<li>自动化降级</li>
<li>自动化分配资源</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="26-扩展性"><a class="markdownIt-Anchor" href="#26-扩展性"></a> 2.6. 扩展性</h3>
<blockquote>
<p><strong>可扩展性指系统为了应对将来需求变化而提供的一种扩展能力</strong>，当有新的需求出现时，系统不需要或者仅需要少量修改就可以支持，无须整个系统重构或者重建。</p>
<p>衡量扩展性的标准就是增加新的业务产品时，是否可以实现对现有产品透明无影响，不需要任何改动或很少改动，既有功能就可以上线新产品。</p>
<p>软件发展的一个重要目标和驱动力是降低软件耦合性。事物之间直接关系越少，彼此影响就越小，也就更容易独立发展，即扩展性好。</p>
</blockquote>
<p>主要手段有：</p>
<ul>
<li>
<p><strong>分层</strong> - 分层是扩展性设计的最基本手段。通过分层，可以将一个的软件系统切分为不同的部分，便于分工合作开发和维护；各层间具有一定的独立性。</p>
<ul>
<li>分层架构的约束：<strong>禁止跨层次的调用及逆向调用</strong>。</li>
<li>即使系统规模很小，也应该考虑采用分层的架构，这样便于以后扩展。</li>
</ul>
</li>
<li>
<p><strong>分割</strong> - 将不同的功能和服务分割开来，包装成高内聚、低耦合的模块单元。这有助于软件的开发和维护，便于不同模块的分布式部署，提高系统的并发处理能力和功能扩展能力。</p>
</li>
<li>
<p><strong>异步</strong> - 业务间的消息传递不是同步调用，而是将一个业务操作拆分成多阶段，每个阶段间通过共享数据的方式异步执行进行协作。</p>
<ul>
<li><strong>在单一服务器内部可通过多线程共享内存队列的方式实现异步</strong>，处在业务操作前面的线程将操作输出到队列，后面的线程从队列中读取数据进行处理；</li>
<li>在分布式系统中，<strong>多个服务器集群通过分布式消息队列实现异步</strong>。</li>
</ul>
</li>
<li>
<p><strong>分布式</strong> - 将业务和可复用服务分离，通过分布式服务框架调用。分布式是指多台服务器部署相同应用构成一个集群，通过负载均衡设备共同对外提供服务。着意味着服务可以用更多的机器工作，即扩展 CPU、内存、IO 等资源，从而提高系统整体的吞吐量和并发处理能力。</p>
<ul>
<li>常用的分布式方案：
<ul>
<li>分布式应用和服务</li>
<li>分布式静态资源</li>
<li>分布式数据和存储</li>
<li>分布式计算</li>
</ul>
</li>
<li>分布式也引入了一些问题：
<ul>
<li>服务调用必须通过网络，网络延迟会影响性能。</li>
<li>服务器越多，宕机概率也越大，导致可用性降低。</li>
<li>数据一致性非常困难，分布式事务也难以保证。</li>
<li>网站依赖错综复杂，开发管理维护困难。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="27-伸缩性"><a class="markdownIt-Anchor" href="#27-伸缩性"></a> 2.7. 伸缩性</h3>
<blockquote>
<p>衡量伸缩的标准就是是否可以用多台服务器构建集群，是否容易向集群中增删服务器节点。增删服务器节点后是否可以提供和之前无差别的服务。集群中可容纳的总服务器数是否有限制。</p>
</blockquote>
<p>伸缩性是指<strong>通过增/减服务器节点数，来灵活的提高/降低系统处理能力</strong>。</p>
<p>主要手段有:</p>
<ul>
<li><strong>应用服务器集群</strong> - 只要服务器上保存数据，则所有服务器都是对等的，通过负载均衡设备向集群中不断加入服务器即可</li>
<li><strong>缓存服务器集群</strong> - 加入新的服务器可能会导致缓存路由失效，进而导致集群中的大部分缓存数据都无法访问。虽然缓存数据可以通过数据库重新加载，但是如果应用严重依赖缓存，可能会导致网站崩溃。需要改进缓存路由算法保证缓存数据的可访问性。</li>
<li><strong>关系型数据库集群</strong> - 关系型数据库虽然支持数据复制，主从热备等机制，但是很难做到大规模集群的可伸缩性，因此关系型数据库的集群伸缩性方案必须在数据库之外实现，通过路由分区等手段将部署有多个数据库的服务器组成一个集群。</li>
<li><strong>Nosql 数据库集群</strong> - 由于先天就是为了应对海量数据而产生，因此对伸缩性的支持通常都非常好。</li>
</ul>
<h3 id="28-安全性"><a class="markdownIt-Anchor" href="#28-安全性"></a> 2.8. 安全性</h3>
<p>安全是指系统应该对恶意攻击有一定的抵抗能力，保护重要数据不被窃取。</p>
<ul>
<li><strong>密码</strong> 和 <strong>手机校验码</strong> 进行身份认证</li>
<li>登录、交易等重要操作需要对网络通信进行 <strong>加密</strong>，存储的敏感数据如用户信息等也进行加密处理</li>
<li>防止机器人程序攻击网站，使用 <strong>验证码</strong> 进行识别</li>
<li>对常见用于 <strong>攻击</strong> 网站的 XSS 攻击、SQL 注入、进行编码转换等相应处理</li>
<li>对垃圾信息、敏感信息进行 <strong>过滤</strong></li>
<li>对交易转账等重要操作根据交易模式和交易信息进行 <strong>风险控制</strong></li>
</ul>
<h2 id="3-常见架构模型"><a class="markdownIt-Anchor" href="#3-常见架构模型"></a> 3. 常见架构模型</h2>
<h3 id="31-分层架构"><a class="markdownIt-Anchor" href="#31-分层架构"></a> 3.1. 分层架构</h3>
<p>分层架构（layered architecture）是最常见的软件架构，也是事实上的标准架构。</p>
<p>这种架构将软件分成若干个水平层，每一层都有清晰的角色和分工，不需要知道其他层的细节。层与层之间通过接口通信。</p>
<p>四层的结构最常见。</p>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/architecture/layered-architecture.png" width="500"/>
</div>
<ul>
<li>表现层（presentation）：用户界面，负责视觉和用户互动</li>
<li>业务层（business）：实现业务逻辑</li>
<li>持久层（persistence）：提供数据，SQL 语句就放在这一层</li>
<li>数据库（database） ：保存数据</li>
</ul>
<p>优点</p>
<ul>
<li>结构简单，容易理解和开发</li>
<li>不同技能的程序员可以分工，负责不同的层，天然适合大多数软件公司的组织架构</li>
<li>每一层都可以独立测试，其他层的接口通过模拟解决</li>
</ul>
<p>缺点</p>
<ul>
<li>一旦环境变化，需要代码调整或增加功能时，通常比较麻烦和费时</li>
<li>部署比较麻烦，即使只修改一个小地方，往往需要整个软件重新部署，不容易做持续发布</li>
<li>软件升级时，可能需要整个服务暂停</li>
<li>扩展性差。用户请求大量增加时，必须依次扩展每一层，由于每一层内部是耦合的，扩展会很困难</li>
</ul>
<h3 id="32-事件驱动架构"><a class="markdownIt-Anchor" href="#32-事件驱动架构"></a> 3.2. 事件驱动架构</h3>
<p>事件（event）是状态发生变化时，软件发出的通知。</p>
<p>事件驱动架构（event-driven architecture）就是通过事件进行通信的软件架构。它分成四个部分。</p>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/architecture/event-driven-architecture.png" width="500"/>
</div>
<ul>
<li>事件队列（event queue）：接收事件的入口</li>
<li>分发器（event mediator）：将不同的事件分发到不同的业务逻辑单元</li>
<li>事件通道（event channel）：分发器与处理器之间的联系渠道</li>
<li>事件处理器（event processor）：实现业务逻辑，处理完成后会发出事件，触发下一步操作</li>
</ul>
<p>对于简单的项目，事件队列、分发器和事件通道，可以合为一体，整个软件就分成事件代理和事件处理器两部分。</p>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/architecture/simple-event-driven-architecture.png" width="500"/>
</div>
<p>优点</p>
<ul>
<li>分布式的异步架构，事件处理器之间高度解耦，软件的扩展性好</li>
<li>适用性广，各种类型的项目都可以用</li>
<li>性能较好，因为事件的异步本质，软件不易产生堵塞</li>
<li>事件处理器可以独立地加载和卸载，容易部署</li>
</ul>
<p>缺点</p>
<ul>
<li>涉及异步编程（要考虑远程通信、失去响应等情况），开发相对复杂</li>
<li>难以支持原子性操作，因为事件通过会涉及多个处理器，很难回滚</li>
<li>分布式和异步特性导致这个架构较难测试</li>
</ul>
<h3 id="33-微核架构"><a class="markdownIt-Anchor" href="#33-微核架构"></a> 3.3. 微核架构</h3>
<p>微核架构（microkernel architecture）又称为&quot;插件架构&quot;（plug-in architecture），指的是软件的内核相对较小，主要功能和业务逻辑都通过插件实现。</p>
<p>内核（core）通常只包含系统运行的最小功能。插件则是互相独立的，插件之间的通信，应该减少到最低，避免出现互相依赖的问题。</p>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/architecture/plug-in-architecture.png" width="500"/>
</div>
<p>优点</p>
<ul>
<li>良好的功能延伸性（extensibility），需要什么功能，开发一个插件即可</li>
<li>功能之间是隔离的，插件可以独立的加载和卸载，使得它比较容易部署，</li>
<li>可定制性高，适应不同的开发需要</li>
<li>可以渐进式地开发，逐步增加功能</li>
</ul>
<p>缺点</p>
<ul>
<li>扩展性（scalability）差，内核通常是一个独立单元，不容易做成分布式</li>
<li>开发难度相对较高，因为涉及到插件与内核的通信，以及内部的插件登记机制</li>
</ul>
<h3 id="34-微服务架构"><a class="markdownIt-Anchor" href="#34-微服务架构"></a> 3.4. 微服务架构</h3>
<p>微服务架构（microservices architecture）是服务导向架构（service-oriented architecture，缩写 SOA）的升级。</p>
<p>每一个服务就是一个独立的部署单元（separately deployed unit）。这些单元都是分布式的，互相解耦，通过远程通信协议（比如 REST、SOAP）联系。</p>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/architecture/microservices-architecture.png" width="500"/>
</div>
<p>微服务架构分成三种实现模式。</p>
<ul>
<li>RESTful API 模式：服务通过 API 提供，云服务就属于这一类</li>
<li>RESTful 应用模式：服务通过传统的网络协议或者应用协议提供，背后通常是一个多功能的应用程序，常见于企业内部</li>
<li>集中消息模式：采用消息代理（message broker），可以实现消息队列、负载均衡、统一日志和异常处理，缺点是会出现单点失败，消息代理可能要做成集群</li>
</ul>
<p>优点</p>
<ul>
<li>扩展性好，各个服务之间低耦合</li>
<li>容易部署，软件从单一可部署单元，被拆成了多个服务，每个服务都是可部署单元</li>
<li>容易开发，每个组件都可以进行持续集成式的开发，可以做到实时部署，不间断地升级</li>
<li>易于测试，可以单独测试每一个服务</li>
</ul>
<p>缺点</p>
<ul>
<li>由于强调互相独立和低耦合，服务可能会拆分得很细。这导致系统依赖大量的微服务，变得很凌乱和笨重，性能也会不佳。</li>
<li>一旦服务之间需要通信（即一个服务要用到另一个服务），整个架构就会变得复杂。典型的例子就是一些通用的 Utility 类，一种解决方案是把它们拷贝到每一个服务中去，用冗余换取架构的简单性。</li>
<li>分布式的本质使得这种架构很难实现原子性操作，交易回滚会比较困难。</li>
</ul>
<h3 id="35-云架构"><a class="markdownIt-Anchor" href="#35-云架构"></a> 3.5. 云架构</h3>
<p>云结构（cloud architecture）主要解决扩展性和并发的问题，是最容易扩展的架构。</p>
<p>它的高扩展性，主要原因是没使用中央数据库，而是把数据都复制到内存中，变成可复制的内存数据单元。然后，业务处理能力封装成一个个处理单元（prcessing unit）。访问量增加，就新建处理单元；访问量减少，就关闭处理单元。由于没有中央数据库，所以扩展性的最大瓶颈消失了。由于每个处理单元的数据都在内存里，最好要进行数据持久化。</p>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/architecture/cloud-architecture.png" width="500"/>
</div>
<p>这个模式主要分成两部分：处理单元（processing unit）和虚拟中间件（virtualized middleware）。</p>
<ul>
<li>处理单元：实现业务逻辑</li>
<li>虚拟中间件：负责通信、保持 sessions、数据复制、分布式处理、处理单元的部署。</li>
</ul>
<p>虚拟中间件又包含四个组件。</p>
<blockquote>
<ul>
<li><strong>消息中间件</strong>（Messaging Grid）：管理用户请求和 session，当一个请求进来以后，决定分配给哪一个处理单元。</li>
<li><strong>数据中间件</strong>（Data Grid）：将数据复制到每一个处理单元，即数据同步。保证某个处理单元都得到同样的数据。</li>
<li><strong>处理中间件</strong>（Processing Grid）：可选，如果一个请求涉及不同类型的处理单元，该中间件负责协调处理单元</li>
<li><strong>部署中间件</strong>（Deployment Manager）：负责处理单元的启动和关闭，监控负载和响应时间，当负载增加，就新启动处理单元，负载减少，就关闭处理单元。</li>
</ul>
</blockquote>
<p>优点</p>
<ul>
<li>高负载，高扩展性</li>
<li>动态部署</li>
</ul>
<p>缺点</p>
<ul>
<li>实现复杂，成本较高</li>
<li>主要适合网站类应用，不合适大量数据吞吐的大型数据库应用</li>
<li>较难测试</li>
</ul>
<h2 id="4-参考资料"><a class="markdownIt-Anchor" href="#4-参考资料"></a> 4. 参考资料</h2>
<ul>
<li><a href="https://item.jd.com/11322972.html" target="_blank" rel="noopener">《大型网站技术架构：核心原理与案例分析》</a></li>
<li>《从 0 开始学架构》</li>
<li><a href="http://www.ruanyifeng.com/blog/2016/09/software-architecture.html" target="_blank" rel="noopener">软件架构入门- 阮一峰的网络日志</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/2018/07/05/%E7%B3%BB%E7%BB%9F%E9%AB%98%E6%80%A7%E8%83%BD%E6%9E%B6%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2018/07/05/%E7%B3%BB%E7%BB%9F%E9%AB%98%E6%80%A7%E8%83%BD%E6%9E%B6%E6%9E%84/" class="post-title-link" itemprop="url">系统高性能架构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-05 15:11:00" itemprop="dateCreated datePublished" datetime="2018-07-05T15:11:00+08:00">2018-07-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-14 16:45:53" itemprop="dateModified" datetime="2022-04-14T16:45:53+08:00">2022-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2018/07/05/%E7%B3%BB%E7%BB%9F%E9%AB%98%E6%80%A7%E8%83%BD%E6%9E%B6%E6%9E%84/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/07/05/系统高性能架构/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="系统高性能架构"><a class="markdownIt-Anchor" href="#系统高性能架构"></a> 系统高性能架构</h1>
<h2 id="性能简介"><a class="markdownIt-Anchor" href="#性能简介"></a> 性能简介</h2>
<p>要设计高性能的系统架构，应该有以下的思维步骤：</p>
<p>首先，要明确影响性能的因素有哪些？性能的指标有哪些？——做到有的放矢。</p>
<p>其次，要了解如何测试性能指标？性能优化，必须要有前后的效果对比，才能证明性能确实有改善。</p>
<p>接下来，学习针对不同场景下，不同性指标的优化策略以及具体实施方案。——见招拆招。</p>
<h3 id="计算机资源"><a class="markdownIt-Anchor" href="#计算机资源"></a> 计算机资源</h3>
<p>了解性能指标前，需要先知道哪些计算机资源会影响性能。一般来说，影响性能的计算机资源包括：</p>
<ul>
<li><strong>CPU</strong></li>
<li><strong>内存</strong></li>
<li><strong>磁盘 I/O</strong></li>
<li><strong>网络 I/O</strong></li>
<li><strong>数据库</strong></li>
<li><strong>锁竞争</strong></li>
</ul>
<h3 id="性能指标"><a class="markdownIt-Anchor" href="#性能指标"></a> 性能指标</h3>
<p>性能测试的主要指标有：</p>
<ul>
<li><strong>响应时间</strong></li>
<li><strong>并发数</strong></li>
<li><strong>吞吐量</strong>
<ul>
<li>QPS</li>
<li>TPS</li>
</ul>
</li>
<li><strong>资源分配使用率</strong></li>
</ul>
<h4 id="响应时间"><a class="markdownIt-Anchor" href="#响应时间"></a> 响应时间</h4>
<p>响应时间(RT)是指从客户端发一个请求开始计时，到客户端接收到从服务器端返回的响应结果结束所经历的时间，响应时间由请求发送时间、网络传输时间和服务器处理时间三部分组成。</p>
<p><strong>响应时间越短，性能越好</strong>，一般一个接口的响应时间是在毫秒级。</p>
<p>响应时间可以进一步细分：</p>
<ul>
<li>客户端响应时间</li>
<li>网络响应时间</li>
<li>服务端响应时间</li>
<li>数据库响应时间</li>
</ul>
<h4 id="并发数"><a class="markdownIt-Anchor" href="#并发数"></a> 并发数</h4>
<p><strong>并发数是指系统能同时处理的请求、事务数</strong>。</p>
<p>系统自身的 CPU 处理能力、内存、以及系统自身的线程复用、锁竞争等都会影响并发数。</p>
<h4 id="吞吐量"><a class="markdownIt-Anchor" href="#吞吐量"></a> 吞吐量</h4>
<p>吞吐量计算公式：</p>
<figure class="highlight fix"><table><tr><td class="code"><pre><span class="line"><span class="attr">吞吐量 </span>=<span class="string"> 并发数 / 平均响应时间</span></span><br></pre></td></tr></table></figure>
<p><strong>吞吐量越大，性能越好</strong>。</p>
<p>一般，系统呈现给外部的最常见的吞吐量指标，就是：</p>
<ul>
<li><strong><code>QPS(每秒查询数)</code></strong> - 即系统每秒可以处理的读请求。</li>
<li><strong><code>TPS(每秒事务数)</code></strong> - 即系统每秒可以处理的写请求。</li>
</ul>
<p>而在系统内部，存在以下吞吐量：</p>
<ul>
<li>磁盘吞吐量 - 体现了磁盘随机读写的性能。</li>
<li>网络吞吐量 - 除了受限于网络带宽，CPU 的处理能力、网卡、防火墙、外部接口以及 I/O、系统 IO 算法都会影响到网络吞吐量。</li>
</ul>
<h4 id="资源分配使用率"><a class="markdownIt-Anchor" href="#资源分配使用率"></a> 资源分配使用率</h4>
<p>通常由 CPU 占用率、内存使用率、磁盘 I/O、网络 I/O 、对象与线程数来表示资源使用率。这些指标也是系统监控的重要参数。</p>
<h3 id="性能测试"><a class="markdownIt-Anchor" href="#性能测试"></a> 性能测试</h3>
<p>性能测试手段：</p>
<ul>
<li>性能测试</li>
<li>负载测试</li>
<li>压力测试</li>
<li>稳定性测试</li>
</ul>
<p>对于 Java 应用而言，最简单的，可以使用 Jmeter 进行性能测试。</p>
<p>性能测试报告示例：</p>
<div align="center">
<img src="https://upload-images.jianshu.io/upload_images/3101171-3d533a36f42608a1.png" />
</div>
#### 性能测试的问题
<p>性能测试时，需要注意一些问题：</p>
<ul>
<li><strong>热身问题</strong> - 系统刚开始运行时，自身可能加载缓存，JVM 可能会优化热点代码等，这些行为都可能使得前后有较大的性能差异。所以，性能测试时，应该先跳过一段热身时间，等趋于稳定后，再开始性能测试。</li>
<li><strong>测试结果不稳定</strong> - 性能测试中，有很多不稳定的因素，如环境、网络等，几乎不可能每次都是一样的结果。所以应该多次测试，求平均值。</li>
<li><strong>多 JVM 情况下的影响</strong> - 应尽量避免一台机器部署多个 JVM 的情况。因为任意一个 JVM 都拥有整个系统的资源使用权，所以在性能测试时，可能会彼此干扰。</li>
</ul>
<h3 id="性能优化策略"><a class="markdownIt-Anchor" href="#性能优化策略"></a> 性能优化策略</h3>
<ol>
<li><strong>性能分析</strong> - 如果请求响应慢，存在性能问题。需要对请求经历的各个环节逐一分析，排查可能出现性能瓶颈的地方，定位问题。检查监控数据，分析影响性能的主要因素：内存、磁盘、网络、CPU，可能是代码或架构设计不合理，又或者是系统资源确实不足。</li>
<li><strong>性能优化</strong> - 性能优化根据网站分层架构，大致可分为前端性能优化、应用服务性能优化、存储服务性能优化。</li>
</ol>
<h2 id="应用服务性能优化"><a class="markdownIt-Anchor" href="#应用服务性能优化"></a> 应用服务性能优化</h2>
<h3 id="缓存"><a class="markdownIt-Anchor" href="#缓存"></a> 缓存</h3>
<p>网站性能优化第一定律：<strong>第一优先考虑使用缓存提升性能</strong>。</p>
<p>缓存是用于存储数据的硬件或软件的组成部分，以使得后续更快访问相应的数据。缓存中的数据可能是提前计算好的结果、数据的副本等。</p>
<ul>
<li>单点应用可以使用进程内缓存（如：ConcurrentHashMap、Caffeine）；</li>
<li>分布式应用可以使用分布式缓存（如：Redis、Memcached），或进程缓存+分布式缓存的多级缓存方案。</li>
</ul>
<blockquote>
<p>缓存解决方案请参考：<a href="https://dunwu.github.io/design/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98.html">缓存基本原理</a></p>
</blockquote>
<h3 id="并发模型"><a class="markdownIt-Anchor" href="#并发模型"></a> 并发模型</h3>
<p>高并发需要根据两个条件划分：连接数量，请求数量。</p>
<ul>
<li>海量连接（成千上万）海量请求：例如抢购，双十一等</li>
<li>常量连接（几十上百）海量请求：例如中间件</li>
<li>海量连接常量请求：例如门户网站</li>
<li>常量连接常量请求：例如内部运营系统，管理系统</li>
</ul>
<p>单服务器高性能的关键之一就是<strong>服务器采取的并发模型</strong></p>
<ul>
<li>服务器如何管理连接。</li>
<li>服务器如何处理请求。</li>
</ul>
<p>以上两个设计点最终都和操作系统的 I/O 模型及进程模型相关。</p>
<ul>
<li>I/O 模型：阻塞、非阻塞、同步、异步。</li>
<li>进程模型：单进程、多进程、多线程。</li>
</ul>
<h4 id="ppc"><a class="markdownIt-Anchor" href="#ppc"></a> PPC</h4>
<p>PPC 是 Process Per Connection 的缩写，其含义是指每次有新的连接就新建一个进程去专门处理这个连接的请求，这是传统的 UNIX 网络服务器所采用的模型。基本的流程图是：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200608103701.png" alt="img" /></p>
<ul>
<li>父进程接受连接（图中 accept）。</li>
<li>父进程“fork”子进程（图中 fork）。</li>
<li>子进程处理连接的读写请求（图中子进程 read、业务处理、write）。</li>
<li>子进程关闭连接（图中子进程中的 close）。</li>
</ul>
<p>这种模式的缺点：</p>
<ul>
<li>fork 代价高</li>
<li>父子进程通信复杂</li>
<li>支持的并发连接数量有限</li>
</ul>
<h4 id="prefork"><a class="markdownIt-Anchor" href="#prefork"></a> prefork</h4>
<p>PPC 模式中，当连接进来时才 fork 新进程来处理连接请求，由于 fork 进程代价高，用户访问时可能感觉比较慢，prefork 模式的出现就是为了解决这个问题。</p>
<p>顾名思义，prefork 就是提前创建进程（pre-fork）。系统在启动的时候就预先创建好进程，然后才开始接受用户的请求，当有新的连接进来的时候，就可以省去 fork 进程的操作，让用户访问更快、体验更好。prefork 的基本示意图是：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200608104151.png" alt="img" /></p>
<p>prefork 的实现关键就是多个子进程都 accept 同一个 socket，当有新的连接进入时，操作系统保证只有一个进程能最后 accept 成功。但这里也存在一个小小的问题：“惊群”现象，就是指虽然只有一个子进程能 accept 成功，但所有阻塞在 accept 上的子进程都会被唤醒，这样就导致了不必要的进程调度和上下文切换了。幸运的是，操作系统可以解决这个问题，例如 Linux 2.6 版本后内核已经解决了 accept 惊群问题。</p>
<p>prefork 模式和 PPC 一样，还是存在父子进程通信复杂、支持的并发连接数量有限的问题，因此目前实际应用也不多。Apache 服务器提供了 MPM prefork 模式，推荐在需要可靠性或者与旧软件兼容的站点时采用这种模式，默认情况下最大支持 256 个并发连接。</p>
<h4 id="tpc"><a class="markdownIt-Anchor" href="#tpc"></a> TPC</h4>
<p>TPC 是 Thread Per Connection 的缩写，其含义是指每次有新的连接就新建一个线程去专门处理这个连接的请求。与进程相比，线程更轻量级，创建线程的消耗比进程要少得多；同时多线程是共享进程内存空间的，线程通信相比进程通信更简单。因此，TPC 实际上是解决或者弱化了 PPC fork 代价高的问题和父子进程通信复杂的问题。</p>
<p>TPC 的基本流程是：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200608104311.png" alt="img" /></p>
<ul>
<li>父进程接受连接（图中 accept）。</li>
<li>父进程创建子线程（图中 pthread）。</li>
<li>子线程处理连接的读写请求（图中子线程 read、业务处理、write）。</li>
<li>子线程关闭连接（图中子线程中的 close）。</li>
</ul>
<p>注意，和 PPC 相比，主进程不用“close”连接了。原因是在于子线程是共享主进程的进程空间的，连接的文件描述符并没有被复制，因此只需要一次 close 即可。</p>
<p>TPC 虽然解决了 fork 代价高和进程通信复杂的问题，但是也引入了新的问题，具体表现在：</p>
<ul>
<li>创建线程虽然比创建进程代价低，但并不是没有代价，高并发时（例如每秒上万连接）还是有性能问题。</li>
<li>无须进程间通信，但是线程间的互斥和共享又引入了复杂度，可能一不小心就导致了死锁问题。</li>
<li>多线程会出现互相影响的情况，某个线程出现异常时，可能导致整个进程退出（例如内存越界）。</li>
</ul>
<p>除了引入了新的问题，TPC 还是存在 CPU 线程调度和切换代价的问题。因此，TPC 方案本质上和 PPC 方案基本类似，在并发几百连接的场景下，反而更多地是采用 PPC 的方案，因为 PPC 方案不会有死锁的风险，也不会多进程互相影响，稳定性更高。</p>
<h4 id="prethread"><a class="markdownIt-Anchor" href="#prethread"></a> prethread</h4>
<p>TPC 模式中，当连接进来时才创建新的线程来处理连接请求，虽然创建线程比创建进程要更加轻量级，但还是有一定的代价，而 prethread 模式就是为了解决这个问题。</p>
<p>和 prefork 类似，prethread 模式会预先创建线程，然后才开始接受用户的请求，当有新的连接进来的时候，就可以省去创建线程的操作，让用户感觉更快、体验更好。</p>
<p>由于多线程之间数据共享和通信比较方便，因此实际上 prethread 的实现方式相比 prefork 要灵活一些，常见的实现方式有下面几种：</p>
<ul>
<li>主进程 accept，然后将连接交给某个线程处理。</li>
<li>子线程都尝试去 accept，最终只有一个线程 accept 成功，方案的基本示意图如下：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200608104922.png" alt="img" /></p>
<p>Apache 服务器的 MPM worker 模式本质上就是一种 prethread 方案，但稍微做了改进。Apache 服务器会首先创建多个进程，每个进程里面再创建多个线程，这样做主要是为了考虑稳定性，即：即使某个子进程里面的某个线程异常导致整个子进程退出，还会有其他子进程继续提供服务，不会导致整个服务器全部挂掉。</p>
<p>prethread 理论上可以比 prefork 支持更多的并发连接，Apache 服务器 MPM worker 模式默认支持 16 × 25 = 400 个并发处理线程。</p>
<h4 id="reactor"><a class="markdownIt-Anchor" href="#reactor"></a> Reactor</h4>
<p>I/O 多路复用技术归纳起来有两个关键实现点：</p>
<ul>
<li>当多条连接共用一个阻塞对象后，进程只需要在一个阻塞对象上等待，而无须再轮询所有连接，常见的实现方式有 <code>select</code>、<code>epoll</code>、<code>kqueue</code> 等。</li>
<li>当某条连接有新的数据可以处理时，操作系统会通知进程，进程从阻塞状态返回，开始进行业务处理。</li>
</ul>
<p>I/O 多路复用结合线程池，完美地解决了 PPC 和 TPC 的问题</p>
<p>Reactor 模式的核心组成部分包括 Reactor 和处理资源池（进程池或线程池），其中 Reactor 负责监听和分配事件，处理资源池负责处理事件。初看 Reactor 的实现是比较简单的，但实际上结合不同的业务场景，Reactor 模式的具体实现方案灵活多变，主要体现在：</p>
<ul>
<li>Reactor 的数量可以变化：可以是一个 Reactor，也可以是多个 Reactor。</li>
<li>资源池的数量可以变化：以进程为例，可以是单个进程，也可以是多个进程（线程类似）。</li>
</ul>
<p>最终 Reactor 模式有这三种典型的实现方案：</p>
<ul>
<li>单 Reactor 单进程 / 线程。</li>
<li>单 Reactor 多线程。</li>
<li>多 Reactor 多进程 / 线程。</li>
</ul>
<h3 id="异步操作"><a class="markdownIt-Anchor" href="#异步操作"></a> 异步操作</h3>
<p>异步处理不仅可以减少系统服务间的耦合度，提高扩展性，事实上，它还可以提高系统的性能。异步处理可以有效减少响应等待时间，从而提高响应速度。</p>
<p>异步处理一般是通过分布式消息队列的方式。</p>
<p>异步处理可以解决以下问题：</p>
<ul>
<li>异步响应</li>
<li>应用解耦</li>
<li>流量削锋</li>
<li>日志处理</li>
<li>消息通讯</li>
</ul>
<h3 id="负载均衡"><a class="markdownIt-Anchor" href="#负载均衡"></a> 负载均衡</h3>
<p>在高并发场景下，使用负载均衡技术为一个应用构建一个由多台服务器组成的服务器集群，将并发访问请求分发到多台服务器上处理，避免单一服务器因负载压力过大而响应缓慢，使用户请求具有更好的响应延迟特性。</p>
<p><strong>高性能集群的复杂性主要体现在需要增加一个任务分配器，以及为任务选择一个合适的任务分配算法</strong>。</p>
<blockquote>
<p>缓存解决方案请参考：<a href="https://github.com/dunwu/blog/blob/master/source/_posts/theory/load-balance.md" target="_blank" rel="noopener">负载均衡</a></p>
</blockquote>
<h3 id="代码优化"><a class="markdownIt-Anchor" href="#代码优化"></a> 代码优化</h3>
<h4 id="多线程"><a class="markdownIt-Anchor" href="#多线程"></a> 多线程</h4>
<p>从资源利用的角度看，使用多线程的原因主要有两个：IO 阻塞和多 CPU。</p>
<p>线程数并非越多越好，那么启动多少线程合适呢？</p>
<p>有个参考公式：</p>
<figure class="highlight fix"><table><tr><td class="code"><pre><span class="line"><span class="attr">启动线程数 </span>=<span class="string"> (任务执行时间 / (任务执行时间 - IO 等待时间)) * CPU 内核数</span></span><br></pre></td></tr></table></figure>
<p>最佳启动线程数和 CPU 内核数成正比，和 IO 阻塞时间成反比。</p>
<ul>
<li>如果任务都是 CPU 计算型任务，那么线程数最多不要超过 CPU 内核数，因为启动再多线程，CPU 也来不及调度；</li>
<li>相反，如果是任务需要等待磁盘操作，网络响应，那么多启动线程有助于任务并罚赌，提高系统吞吐量。</li>
</ul>
<h5 id="线程安全问题"><a class="markdownIt-Anchor" href="#线程安全问题"></a> 线程安全问题</h5>
<p>线程安全问题时指多个线程并发访问某个资源，导致数据混乱。</p>
<p>解决手段有：</p>
<ul>
<li><strong>将对象设计为无状态对象</strong> - 典型应用：Servlet 就是无状态对象，可以被服务器多线程并发调用处理用户请求。</li>
<li><strong>使用局部对象</strong></li>
<li><strong>并发访问资源时使用锁</strong> - 但是引入锁会产生性能开销，应尽量使用轻量级的锁。</li>
</ul>
<h4 id="资源复用"><a class="markdownIt-Anchor" href="#资源复用"></a> 资源复用</h4>
<p>应该尽量减少那些开销很大的系统资源的创建和销毁，如数据库连接、网络通信连接、线程、复杂对象等。从编程角度，资源复用主要有两种模式：单例模式和对象池。</p>
<h4 id="数据结构"><a class="markdownIt-Anchor" href="#数据结构"></a> 数据结构</h4>
<p>根据具体场景，选择合适的数据结构。</p>
<h4 id="垃圾回收"><a class="markdownIt-Anchor" href="#垃圾回收"></a> 垃圾回收</h4>
<p>如果 Web 应用运行在 JVM 等具有垃圾回收功能的环境中，那么垃圾回收可能会对系统的性能特性产生巨大影响。立即垃圾回收机制有助于程序优化和参数调优，以及编写内存安全的代码。</p>
<h2 id="存储性能优化"><a class="markdownIt-Anchor" href="#存储性能优化"></a> 存储性能优化</h2>
<h3 id="数据库"><a class="markdownIt-Anchor" href="#数据库"></a> 数据库</h3>
<h4 id="数据库读写分离"><a class="markdownIt-Anchor" href="#数据库读写分离"></a> 数据库读写分离</h4>
<p><strong>读写分离的基本原理是将数据库读写操作分散到不同的节点上</strong></p>
<blockquote>
<p>详细解决方案参考：<a href="https://github.com/dunwu/blog/blob/master/source/_posts/theory/distributed-storage.md" target="_blank" rel="noopener">分布式存储</a></p>
</blockquote>
<h4 id="数据库分库分表"><a class="markdownIt-Anchor" href="#数据库分库分表"></a> 数据库分库分表</h4>
<p><strong>数据分片指按照某个维度将存放在单一数据库中的数据分散地存放至多个数据库或表中以达到提升性能瓶颈以及可用性的效果</strong>。</p>
<blockquote>
<p>详细解决方案参考：<a href="https://github.com/dunwu/blog/blob/master/source/_posts/theory/distributed-storage.md" target="_blank" rel="noopener">分布式存储</a></p>
</blockquote>
<h4 id="nosql"><a class="markdownIt-Anchor" href="#nosql"></a> Nosql</h4>
<p>关系型数据库的优势在于：存储结构化数据，有利于进行各种复杂查询。</p>
<p>但是，它也存在一些缺点：</p>
<ul>
<li>关系数据库存储的是行记录，无法存储数据结构</li>
<li>关系数据库的 schema 扩展很不方便</li>
<li>关系数据库在大数据场景下 I/O 较高</li>
<li>关系数据库的全文搜索功能比较弱</li>
</ul>
<p>为了解决上述问题，分别诞生了解决不同问题的 Nosql 数据库。</p>
<p>常见的 NoSQL 数据库可以分为四类：</p>
<ul>
<li><strong>K-V 数据库</strong>：KV 存储非常适合存储<strong>不涉及过多数据关系业务关系的数据</strong>，同时能有效减少读写磁盘的次数，比 SQL 数据库存储拥有更好的读写性能，能够<strong>解决关系型数据库无法存储数据结构的问题</strong>。以 Redis 为代表。</li>
<li><strong>列式数据库</strong>：<strong>适合于批量数据处理和即时查询，解决关系数据库大数据场景下的 I/O 问题</strong>。以 HBase 为代表。</li>
<li><strong>文档数据库</strong>：文档数据库（也称为文档型数据库）是<strong>旨在将半结构化数据存储为文档的一种数据库，它可以解决关系型数据库表结构 schema 扩展不方便的问题</strong>。文档数据库<strong>通常以 JSON 或 XML 格式存储数据</strong>。以 MongoDB 为代表。</li>
<li><strong>全文搜索引擎</strong>：<strong>解决关系型数据库全文搜索功能较弱的问题</strong>。以 Elasticsearch 为代表。</li>
</ul>
<blockquote>
<p>详情参考：<a href="https://github.com/dunwu/db-tutorial/blob/master/docs/nosql/nosql-selection.md" target="_blank" rel="noopener">Nosql 技术选型</a></p>
</blockquote>
<h3 id="文件存储"><a class="markdownIt-Anchor" href="#文件存储"></a> 文件存储</h3>
<h4 id="机械键盘和固态硬盘"><a class="markdownIt-Anchor" href="#机械键盘和固态硬盘"></a> 机械键盘和固态硬盘</h4>
<p>考虑使用固态硬盘替代机械键盘，因为它的读写速度更快。</p>
<h4 id="b数和-lsm-树"><a class="markdownIt-Anchor" href="#b数和-lsm-树"></a> B+数和 LSM 树</h4>
<p>传统关系数据库的数据库索引一般都使用两级索引的 <strong>B+ 树</strong> 结构，树的层次最多三层。因此可能需要 5 次磁盘访问才能更新一条记录（三次磁盘访问获得数据索引及行 ID，然后再进行一次数据文件读操作及一次数据文件写操作）。</p>
<p>由于磁盘访问是随机的，传统机械键盘在数据随机访问时性能较差，每次数据访问都需要多次访问磁盘影响数据访问性能。</p>
<p>许多 Nosql 数据库中的索引采用 <strong>LSM 树</strong> 作为主要数据结构。LSM 树可视为一个 N 阶合并树。数据写操作都在内存中进行。在 <strong>LSM 树上进行一次数据更新不需要磁盘访问，速度远快于 B+ 树</strong>。</p>
<h4 id="raid-和-hdfs"><a class="markdownIt-Anchor" href="#raid-和-hdfs"></a> RAID 和 HDFS</h4>
<p>RAID 是 Redundant Array of Independent Disks 的缩写，中文简称为独立冗余磁盘阵列。</p>
<p>RAID 是一种把多块独立的硬盘（物理硬盘）按不同的方式组合起来形成一个硬盘组（逻辑硬盘），从而提供比单个硬盘更高的存储性能和提供数据备份技术。</p>
<p>HDFS(分布式文件系统) 更被大型网站所青睐。它可以配合 <code>MapReduce</code> 并发计算任务框架进行大数据处理，可以在整个集群上并发访问所有磁盘，无需 RAID 支持。</p>
<p>HDFS 对数据存储空间的管理以数据块（Block）为单位，默认为 64 MB。所以，HDFS 更适合存储较大的文件。</p>
<h2 id="前端性能优化"><a class="markdownIt-Anchor" href="#前端性能优化"></a> 前端性能优化</h2>
<h3 id="浏览器访问优化"><a class="markdownIt-Anchor" href="#浏览器访问优化"></a> 浏览器访问优化</h3>
<ol>
<li><strong>减少 HTTP 请求</strong> - HTTP 请求需要建立通信链路，进行数据传输，开销高昂，所以减少 HTTP 请求数可以有效提高访问性能。减少 HTTP 的主要手段是合并 Css、JavaScript、图片。</li>
<li><strong>使用浏览器缓存</strong> - 因为静态资源文件更新频率低，可以缓存浏览器中以提高性能。设置 HTTP 头中的 <code>Cache-Control</code> 和 <code>Expires</code> 属性，可设定浏览器缓存。</li>
<li><strong>启用压缩</strong> - 在服务器端压缩静态资源文件，在浏览器端解压缩，可以有效减少传输的数据量。由于文本文件压缩率可达 80% 以上，所以可以对静态资源，如 Html、Css、JavaScrip 进行压缩。</li>
<li><strong>CSS 放在页面最上面，JavaScript 放在页面最下面</strong> - 浏览器会在下载完全部的 Css 后才对整个页面进行渲染，所以最好的做法是将 Css 放在页面最上面，让浏览器尽快下载 Css；JavaScript 则相反，浏览器加载 JavaScript 后立即执行，可能会阻塞整个页面，造成页面显示缓慢，因此 JavaScript 最好放在页面最下面。</li>
<li><strong>减少 Cookie 传输</strong> - Cookie 包含在 HTTP 每次的请求和响应中，太大的 Cookie 会严重影响数据传输。</li>
</ol>
<h3 id="cdn"><a class="markdownIt-Anchor" href="#cdn"></a> CDN</h3>
<p>CDN 一般缓存的是静态资源。</p>
<p>CDN 的本质仍然是一个缓存，而且将数据缓存在离用户最近的地方，使用户已最快速度获取数据，即所谓网络访问第一跳。</p>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/architecture/cdn.png" width="640" />
</div>
<h3 id="反向代理"><a class="markdownIt-Anchor" href="#反向代理"></a> 反向代理</h3>
<p>传统代理服务器位于浏览器一侧，代理浏览器将 HTTP 请求发送到互联网上，而反向代理服务器位于网站机房一侧，代理网站服务器接收 HTTP 请求。</p>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/architecture/reverse-proxy.jpg" width="640" />
</div>
<p>反向代理服务器可以配置缓存功能加速 Web 请求，当用户第一次访问静态内容时，静态内容就会被缓存在反向代理服务器上。</p>
<p>反向代理还可以实现负载均衡，通过负载均衡构建的集群可以提高系统总体处理能力。</p>
<p>因为所有请求都必须先经过反向代理服务器，所以可以屏蔽一些攻击 IP，达到保护网站安全的作用。</p>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><a href="https://item.jd.com/11322972.html" target="_blank" rel="noopener">《大型网站技术架构：核心原理与案例分析》</a></li>
<li><a href="https://time.geekbang.org/column/intro/100028001" target="_blank" rel="noopener">Java 性能调优实战</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/2018/07/05/%E7%B3%BB%E7%BB%9F%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2018/07/05/%E7%B3%BB%E7%BB%9F%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84/" class="post-title-link" itemprop="url">系统高可用架构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-05 15:11:00" itemprop="dateCreated datePublished" datetime="2018-07-05T15:11:00+08:00">2018-07-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-14 16:45:53" itemprop="dateModified" datetime="2022-04-14T16:45:53+08:00">2022-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2018/07/05/%E7%B3%BB%E7%BB%9F%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/07/05/系统高可用架构/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="系统高可用架构"><a class="markdownIt-Anchor" href="#系统高可用架构"></a> 系统高可用架构</h1>
<h2 id="1-高可用架构简介"><a class="markdownIt-Anchor" href="#1-高可用架构简介"></a> 1. 高可用架构简介</h2>
<h3 id="11-系统可用性的度量"><a class="markdownIt-Anchor" href="#11-系统可用性的度量"></a> 1.1. 系统可用性的度量</h3>
<p>系统不可用也被称作系统故障，<strong>业界通常用多个 9 来衡量系统的可用性</strong>。如 QQ 的可用性为 4 个 9，即 99.99% 可用。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">网站不可用时间 = 故障修复时间点 - 故障发现时间点</span><br><span class="line">网站年度可用性指标 = (<span class="number">1</span> - 网站不可用时间/年度总时间) * <span class="number">100</span>%</span><br></pre></td></tr></table></figure>
<p>可用性计量表：</p>
<table>
<thead>
<tr>
<th style="text-align:center">可用性级别</th>
<th style="text-align:center">系统可用性%</th>
<th style="text-align:center">宕机时间/年</th>
<th style="text-align:center">宕机时间/月</th>
<th style="text-align:center">宕机时间/周</th>
<th style="text-align:center">宕机时间/天</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">不可用</td>
<td style="text-align:center">90%</td>
<td style="text-align:center">36.5 天</td>
<td style="text-align:center">73 小时</td>
<td style="text-align:center">16.8 小时</td>
<td style="text-align:center">144 分钟</td>
</tr>
<tr>
<td style="text-align:center">基本可用</td>
<td style="text-align:center">99%</td>
<td style="text-align:center">87.6 小时</td>
<td style="text-align:center">7.3 小时</td>
<td style="text-align:center">1.68 小时</td>
<td style="text-align:center">14.4 分钟</td>
</tr>
<tr>
<td style="text-align:center">较高可用</td>
<td style="text-align:center">99.9%</td>
<td style="text-align:center">8.76 小时</td>
<td style="text-align:center">43.8 分钟</td>
<td style="text-align:center">10.1 分钟</td>
<td style="text-align:center">1.44 分钟</td>
</tr>
<tr>
<td style="text-align:center">高可用</td>
<td style="text-align:center">99.99%</td>
<td style="text-align:center">52.56 分钟</td>
<td style="text-align:center">4.38 分钟</td>
<td style="text-align:center">1.01 秒</td>
<td style="text-align:center">8.64 秒</td>
</tr>
<tr>
<td style="text-align:center">极高可用</td>
<td style="text-align:center">99.999%</td>
<td style="text-align:center">5.26 分钟</td>
<td style="text-align:center">26.28 秒</td>
<td style="text-align:center">6.06 秒</td>
<td style="text-align:center">0.86 秒</td>
</tr>
</tbody>
</table>
<h3 id="12-故障原因"><a class="markdownIt-Anchor" href="#12-故障原因"></a> 1.2. 故障原因</h3>
<p>系统宕机原因主要有以下：</p>
<p><strong>无计划的</strong></p>
<ul>
<li>系统级故障，包括主机、操作系统、中间件、数据库、网络、电源以及外围设备。</li>
<li>数据和中介的故障，包括人员误操作、硬盘故障、数据乱了。</li>
<li>还有自然灾害、人为破坏，以及供电问题等。</li>
</ul>
<p><strong>有计划的</strong></p>
<ul>
<li>日常任务：备份，容量规划，用户和安全管理，后台批处理应用。</li>
<li>运维相关：数据库维护、应用维护、中间件维护、操作系统维护、网络维护。</li>
<li>升级相关：数据库、应用、中间件、操作系统、网络，包括硬件升级。</li>
</ul>
<p>我们再给它们归个类。</p>
<ol>
<li><strong>网络问题</strong>。网络链接出现问题，网络带宽出现拥塞……</li>
<li><strong>性能问题</strong>。数据库慢 SQL、Java Full GC、硬盘 IO 过大、CPU 飙高、内存不足……</li>
<li><strong>安全问题</strong>。被网络攻击，如 DDoS 等。</li>
<li><strong>运维问题</strong>。系统总是在被更新和修改，架构也在不断地被调整，监控问题……</li>
<li><strong>管理问题</strong>。没有梳理出关键服务以及服务的依赖关系，运行信息没有和控制系统同步……</li>
<li><strong>硬件问题</strong>。硬盘损坏、网卡出问题、交换机出问题、机房掉电、挖掘机问题……</li>
</ol>
<h3 id="13-什么是高可用的系统架构"><a class="markdownIt-Anchor" href="#13-什么是高可用的系统架构"></a> 1.3. 什么是高可用的系统架构</h3>
<p>通常，企业级应用系统为提高系统可用性，会采用较昂贵的软硬件设备，当然这样的设备也比较稳定。</p>
<p>互联网公司或一些初创型公司基于成本考虑，更多采用 PC 级软硬件设备，节约成本所付出的代价就是设备较为不稳定。服务器一年中出现几次宕机，高强度读写磁盘导致磁盘损坏等事件实属正常。</p>
<p>综上，硬件出现故障应视为必然的，而<strong>高可用的系统架构设计目标就是要保证当出现硬件故障时，服务依然可用，数据依然能够保存并被访问</strong>。<strong>实现高可用的系统架构的主要手段是数据和服务的冗余备份及失效转移</strong>，一旦某些服务器宕机，就将服务切换到其他可用的服务器上；如果磁盘损坏，则从备份的磁盘读取数据。</p>
<p><strong>大型系统的分层架构及物理服务器的分布式部署使得位于不同层次的服务器具有不同的可用性特点。关闭服务或服务器宕机时产生的影响也不相同，高可用的解决方案也差异甚大</strong>。大致可以分为：</p>
<ul>
<li>高可用的应用 - 主要手段是：负载均衡</li>
<li>高可用的服务 - 主要手段是：分级管理、超时重试、异步调用、限流、降解、断路、幂等性设计</li>
<li>高可用的数据 - 主要手段是：数据备份和失效转移</li>
</ul>
<h2 id="2-高可用架构理论"><a class="markdownIt-Anchor" href="#2-高可用架构理论"></a> 2. 高可用架构理论</h2>
<p>学习高可用架构，首先需要了解分布式基础理论：CAP 和 BASE。</p>
<p>然后，很多著名的分布式系统，都利用选举机制，来保证主节点宕机时的故障恢复。如果要深入理解选举机制，有必要了解：<a href="https://github.com/dunwu/blog/blob/master/source/_posts/theory/paxos.md" target="_blank" rel="noopener">Paxos 算法</a> 和 <a href="https://github.com/dunwu/blog/blob/master/source/_posts/theory/raft.md" target="_blank" rel="noopener">Raft 算法</a>。Paxos 和 Raft 是为了实现分布式系统中高可用架构而提出的共识性算法，已经成为业界标准。</p>
<p>CAP 定理又称为 CAP 原则，指的是：<strong>在一个分布式系统中， <code>一致性（C：Consistency）</code>、<code>可用性（A：Availability）</code> 和 <code>分区容忍性（P：Partition Tolerance）</code>，最多只能同时满足其中两项</strong>。</p>
<p>BASE 是 <strong><code>基本可用（Basically Available）</code></strong>、<strong><code>软状态（Soft State）</code></strong> 和 <strong><code>最终一致性（Eventually Consistent）</code></strong> 三个短语的缩写。BASE 理论是对 CAP 中一致性和可用性权衡的结果，它的理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</p>
<blockquote>
<p>CAP 和 BASE 理论的详细说明请参考：<a href="https://github.com/dunwu/blog/blob/master/source/_posts/theory/distributed-base-theory.md" target="_blank" rel="noopener">分布式理论</a></p>
<p>Paxos 和 Raft 的详细说明请参考：<a href="https://github.com/dunwu/blog/blob/master/source/_posts/theory/paxos.md" target="_blank" rel="noopener">Paxos 算法</a> 和 <a href="https://github.com/dunwu/blog/blob/master/source/_posts/theory/raft.md" target="_blank" rel="noopener">Raft 算法</a></p>
</blockquote>
<h2 id="3-架构模式"><a class="markdownIt-Anchor" href="#3-架构模式"></a> 3. 架构模式</h2>
<h3 id="31-主备复制"><a class="markdownIt-Anchor" href="#31-主备复制"></a> 3.1. 主备复制</h3>
<p>主备复制是最常见也是最简单的一种存储高可用方案，几乎所有的存储系统都提供了主备复制的功能，例如 MySQL、Redis、MongoDB 等。</p>
<p>主备复制要点：</p>
<ul>
<li>存在<strong>一主多备</strong>。</li>
<li>主机负责读&amp;写，并定期复制数据给备机。</li>
<li>一旦主机宕机，可以通过人工手段，将其中一个备节点作为主节点。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200614173351.png" alt="img" /></p>
<p><strong>优点</strong></p>
<ul>
<li>主备复制架构中，客户端可以不感知备机的存在。即使灾难恢复后，原来的备机被人工修改为主机后，对于客户端来说，只是认为主机的地址换了而已，无须知道是原来的备机升级为主机。</li>
<li>主备复制架构中，主机和备机之间，只需要进行数据复制即可，无须进行状态判断和主备切换这类复杂的操作。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>主备复制架构中，故障后需要人工干预，无法自动恢复。</li>
</ul>
<p><strong>适用场景</strong></p>
<p>综合主备复制架构的优缺点，内部的后台管理系统使用主备复制架构的情况会比较多，例如学生管理系统、员工管理系统、假期管理系统等，因为这类系统的数据变更频率低，即使在某些场景下丢失数据，也可以通过人工的方式补全。</p>
<h3 id="32-主从复制"><a class="markdownIt-Anchor" href="#32-主从复制"></a> 3.2. 主从复制</h3>
<p>主从复制和主备复制只有一字之差，区别在于：<strong>主从复制模式中，从机要承担读操作</strong>。</p>
<p>主从复制要点：</p>
<ul>
<li>存在<strong>一主多从</strong>。</li>
<li>主机负责读&amp;写，并定期复制数据给从机。</li>
<li>从机只负责读。</li>
<li>一旦主机宕机，可以通过人工手段，将其中一个从节点作为主节点。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200614173527.png" alt="img" /></p>
<p><strong>优点</strong></p>
<ul>
<li>主从复制架构中，主机故障时，读操作相关的业务可以继续运行。</li>
<li>主从复制架构中，从机提供读操作，发挥了硬件的性能。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>主从复制架构中，客户端需要感知主从关系，并将不同的操作发给不同的机器进行处理，复杂度比主备复制要高。</li>
<li>主从复制架构中，从机提供读业务，如果主从复制延迟比较大，业务会因为数据不一致出现问题。</li>
<li>主从复制架构中，故障时需要人工干预。</li>
</ul>
<p><strong>适用场景</strong></p>
<p>综合主从复制的优缺点，一般情况下，写少读多的业务使用主从复制的存储架构比较多。例如，论坛、BBS、新闻网站这类业务，此类业务的读操作数量是写操作数量的 10 倍甚至 100 倍以上。</p>
<h3 id="33-集群分区"><a class="markdownIt-Anchor" href="#33-集群分区"></a> 3.3. 集群+分区</h3>
<p>在主备复制和主从复制模式中，都由一个共性问题：</p>
<p>每个机器上存储的都是全量数据。但是，单机的数据存储量总是有上限的，当数据量上升为 TB 级甚至 PB 级数据，单机终究有无法支撑的时候。这时，就需要对数据进行分片（sharding）。</p>
<p>分片后的节点可以视为一个独立的子集，针对子集，任然需要保证高可用。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200614184921.png" alt="img" /></p>
<h2 id="4-高可用的应用"><a class="markdownIt-Anchor" href="#4-高可用的应用"></a> 4. 高可用的应用</h2>
<p>应用层主要处理网站应用的业务逻辑，一个显著的特点是应用的 <strong>无状态</strong> 性。</p>
<p>所谓的 <strong>无状态</strong> 的应用是指应用服务器不保存业务的上下文信息，而仅根据每次请求提交的数据进行相应的业务逻辑处理，多个服务实例之间完全对等，请求提交到任意服务器，处理结果都是完全一样的。</p>
<p>由于无状态应用，各实例之间不用考虑数据一致性问题，所以其高可用方案相对简单。主要手段是：</p>
<ul>
<li>负载均衡</li>
<li>分布式 Session</li>
</ul>
<h3 id="41-负载均衡"><a class="markdownIt-Anchor" href="#41-负载均衡"></a> 4.1. 负载均衡</h3>
<p>负载均衡，顾名思义，主要使用在业务量和数据量较高的情况下，当单台服务器不足以承担所有的负载压力时，通过负载均衡手段，将流量和数据分摊到一个集群组成的多台服务器上，以提高整体的负载处理能力。</p>
<p><strong>无状态应用的失效转移可以利用负载均衡来实现</strong>。</p>
<p>无状态的应用实现高可用架构十分简单，由于服务器不保存请求状态，那么所有服务器完全对等，在任意节点执行同样的请求，结果总是一致的。这种情况下，最简单的高可用方案就是使用负载均衡。</p>
<blockquote>
<p>负载均衡原理可以参考：<a href="https://github.com/dunwu/blog/blob/master/source/_posts/theory/load-balance.md" target="_blank" rel="noopener">负载均衡基本原理</a></p>
</blockquote>
<h3 id="42-分布式-session"><a class="markdownIt-Anchor" href="#42-分布式-session"></a> 4.2. 分布式 Session</h3>
<p>应用服务器的高可用架构设计主要基于服务无状态这一特性。事实上，业务总是有状态的，如购物车记录用户的购买信息；用户的登录状态；最新发布的消息等等。</p>
<p>在分布式场景下，一个用户的 Session 如果只存储在一个服务器上，那么当负载均衡器把用户的下一个请求转发到另一个服务器上，该服务器没有用户的 Session，就可能导致用户需要重新进行登录等操作。</p>
<p>为了解决分布式 Session 问题，常见的解决方案有：</p>
<ul>
<li>粘性 session</li>
<li>应用服务器间的 session 复制共享</li>
<li>基于缓存的 session 共享 ✅</li>
</ul>
<blockquote>
<p>分布式会话原理可以参考：<a href="https://github.com/dunwu/blog/blob/master/source/_posts/theory/distributed-session.md" target="_blank" rel="noopener">分布式会话基本原理</a></p>
</blockquote>
<h2 id="5-高可用的服务"><a class="markdownIt-Anchor" href="#5-高可用的服务"></a> 5. 高可用的服务</h2>
<p><strong>可复用的服务</strong>为业务产品提供基础公共服务，大型系统中这些服务通常都独立分布式部署，被具体应用远程调用。可复用的服务和应用一样，一般也是无状态的服务，因此，<strong>同样可以使用负载均衡的失效转移策略来实现高可用</strong>。</p>
<p>除此以外，还有以下手段来保证服务的高可用：</p>
<ul>
<li>分级管理</li>
<li>超时重试</li>
<li>异步调用</li>
<li>过载保护
<ul>
<li>限流</li>
<li>降级</li>
<li>断路</li>
</ul>
</li>
<li>幂等性设计</li>
</ul>
<h3 id="51-分级管理"><a class="markdownIt-Anchor" href="#51-分级管理"></a> 5.1. 分级管理</h3>
<p>将服务根据业务重要性进行分级管理，核心应用和服务优先使用更好的硬件，在运维响应速度上也格外迅速。</p>
<p>在服务部署上进行必要的隔离，避免故障的连锁反应。低优先级的服务通过启动不同的线程或部署在不同的虚拟机上进行隔离，而高优先级的服务则需要部署在不同的物理机上，核心服务和数据甚至要部署在不同地域的数据中心。</p>
<h3 id="52-超时重试"><a class="markdownIt-Anchor" href="#52-超时重试"></a> 5.2. 超时重试</h3>
<p>由于服务器宕机、线程死锁等原因，可能导致应用程序对服务端的调用失去响应。所以有必要引入<strong>超时机制</strong>，一旦调用超时，服务化框架抛出异常，应用程序根据服务调度策略，选择重试或请求转移到其他机器上。</p>
<h3 id="53-异步调用"><a class="markdownIt-Anchor" href="#53-异步调用"></a> 5.3. 异步调用</h3>
<p>对于需要即时响应的业务，应用在调用服务时可以通过消息队列等异步方式完成，避免一个服务失败导致整个应用请求失败的情况。当然不是所有服务调用都可以异步调用，对于获取用户信息这类调用，采用异步方式会延长响应时间，得不偿失；此外，对于那些必须确认服务调用才能继续下一步操作的应用也不适宜食用异步调用。</p>
<h3 id="54-过载保护"><a class="markdownIt-Anchor" href="#54-过载保护"></a> 5.4. 过载保护</h3>
<p>过载保护的手段，一般有：限流、降级、熔断。</p>
<h4 id="限流"><a class="markdownIt-Anchor" href="#限流"></a> 限流</h4>
<p>降级是从系统功能优先级的角度考虑如何应对故障，而限流则是从用户访问压力的角度来考虑如何应对故障。限流指只允许系统能够承受的访问量进来，超出系统访问能力的请求将被丢弃。</p>
<p>常见的限流方式可以分为两类：基于请求限流和基于资源限流。</p>
<h5 id="基于请求限流"><a class="markdownIt-Anchor" href="#基于请求限流"></a> 基于请求限流</h5>
<p>基于请求限流指从外部访问的请求角度考虑限流，常见的方式有：限制总量、限制时间量。</p>
<p>限制总量的方式是限制<strong>某个指标的累积上限</strong>，常见的是限制当前系统服务的用户总量，例如某个直播间限制总用户数上限为 100 万，超过 100 万后新的用户无法进入；某个抢购活动商品数量只有 100 个，限制参与抢购的用户上限为 1 万个，1 万以后的用户直接拒绝。限制时间量指限制<strong>一段时间内某个指标的上限</strong>，例如，1 分钟内只允许 10000 个用户访问，每秒请求峰值最高为 10 万。</p>
<p>无论是限制总量还是限制时间量，共同的特点都是实现简单，但在实践中面临的主要问题是比较难以找到合适的阈值。</p>
<h5 id="基于资源限流"><a class="markdownIt-Anchor" href="#基于资源限流"></a> 基于资源限流</h5>
<p>基于请求限流是从系统外部考虑的，而基于资源限流是从系统内部考虑的，即：找到系统内部影响性能的关键资源，对其使用上限进行限制。常见的内部资源有：连接数、文件句柄、线程数、请求队列等。</p>
<p>基于资源限流相比基于请求限流能够更加有效地反映当前系统的压力，但实践中设计也面临两个主要的难点：如何确定关键资源，如何确定关键资源的阈值。</p>
<h4 id="降级"><a class="markdownIt-Anchor" href="#降级"></a> 降级</h4>
<p>降级指系统将某些业务或者接口的功能降低，可以是只提供部分功能，也可以是完全停掉所有功能。</p>
<p>在服务访问的高峰期，服务可能因为大量并发调用而性能下降，严重时可能会导致宕机。为了保证核心功能的正常运行，需要对服务进行降级。降级有两种手段：</p>
<p><strong>拒绝服务</strong> - 拒绝低优先级应用的调用，减少服务调用并发数，确保核心应用正常使用。或者随机拒绝部分调用，节约资源，避免要死大家一起死的惨剧。</p>
<p><strong>关闭服务</strong> - 关闭部分不重要的服务，或者服务内部关闭部分不重要的功能，以节约资源。</p>
<h4 id="熔断"><a class="markdownIt-Anchor" href="#熔断"></a> 熔断</h4>
<p>熔断和降级是两个比较容易混淆的概念，因为单纯从名字上看好像都有禁止某个功能的意思，但其实内在含义是不同的，原因在于降级的目的是应对系统自身的故障，而熔断的目的是应对依赖的外部系统故障的情况。</p>
<p>熔断机制实现的关键是需要有一个统一的 API 调用层，由 API 调用层来进行采样或者统计，如果接口调用散落在代码各处就没法进行统一处理了。</p>
<h3 id="55-幂等性设计"><a class="markdownIt-Anchor" href="#55-幂等性设计"></a> 5.5. 幂等性设计</h3>
<p>服务调用失败后，调用方会将请求转发到其他服务器上，但是这个失败可能是虚假的失败。比如服务已经处理成功，但因为网络故障导致调用方没有收到应答，或等待超时。这种情况下，重新发起请求，可能会导致重复操作，如：向数据库写入两条记录。如果这个操作是比较敏感的交易操作，就会产生严重后果。</p>
<p>服务重复调用时无法避免的，但是只要能从业务实现上保证，重复调用和一次调用的处理结果一致，则业务就没有问题，这就是幂等性设计。</p>
<p>有些服务的业务天然具有幂等性，比如将用户性别设为男性，不管执行多少次，结果是一致的。但有些复杂的业务，要想保证幂等性，就需要根据全局性的 ID 去进行有效性验证，验证通过才能继续执行。</p>
<h2 id="6-高可用的存储"><a class="markdownIt-Anchor" href="#6-高可用的存储"></a> 6. 高可用的存储</h2>
<p>对于绝大部分软件系统而言，数据都是最宝贵的虚拟资产，一旦丢失，可以说是毁灭性的打击。</p>
<p>保证存储高可用的<strong>主要手段</strong>是：<strong>数据备份</strong>和<strong>失效转移</strong>。</p>
<p>存储高可用架构的<strong>复杂性</strong>主要体现在：<strong>如何应对副本同步延迟和中断导致的数据一致性问题</strong>。</p>
<blockquote>
<p>提示：再开始学习这部分内容前，建议先学习 <strong>二、高可用架构理论</strong></p>
</blockquote>
<h3 id="61-数据备份"><a class="markdownIt-Anchor" href="#61-数据备份"></a> 6.1. 数据备份</h3>
<p>数据备份是保证数据有多个副本，任意副本的丢失都不会导致数据的永久丢失。</p>
<ul>
<li><strong>冷备份</strong> - 定期将数据复制到某种存储介质。</li>
<li><strong>热备份</strong>
<ul>
<li><strong>异步热备方式</strong> - 异步热备方式是指多份数据副本的写入操作异步完成，应用程序收到数据服务系统的写操作成功响应时，只写成功了一份，存储系统将会异步地写其他副本。</li>
<li><strong>同步热备方式</strong> - 同步热备方式是指多份数据副本的写入操作同步完成，即应用程序收到数据服务系统的写成功响应时，多份数据都已经写操作成功。但是当应用程序收到数据写操作失败的响应式，可能有部分副本或者全部副本都已经写入成功了（因为网络或者系统故障，无法返回操作成功的响应）。</li>
</ul>
</li>
</ul>
<h3 id="62-失效转移"><a class="markdownIt-Anchor" href="#62-失效转移"></a> 6.2. 失效转移</h3>
<p>失效转移是保证任意一个副本不可访问时，可以快速切换访问其他副本，保证系统整体可用。</p>
<h4 id="失效确认"><a class="markdownIt-Anchor" href="#失效确认"></a> 失效确认</h4>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/architecture/check-fail.png" width="500" />
</div>
<p>判断服务器宕机的手段有两种：<strong>心跳检测</strong>和<strong>访问失败报告</strong>。</p>
<p>对于应用程序的访问失败报告，控制中心还需要再一次发送心跳检测进行确认，以免错误判断服务器宕机。因为一旦进行数据访问的失效转移，意味着数据存储多份副本不一致，需要进行后续一系列的复杂动作。</p>
<h4 id="访问转移"><a class="markdownIt-Anchor" href="#访问转移"></a> 访问转移</h4>
<p>确认某台数据服务器宕机后，就需要将数据读写访问重新路由到其他服务器上。对于完全对等存储的服务器，当其中一台宕机后，应用程序根据配置直接切换到对等服务器上。如果存储不对等，就需要重新计算路由，选择存储服务器。</p>
<h4 id="数据恢复"><a class="markdownIt-Anchor" href="#数据恢复"></a> 数据恢复</h4>
<p>因为某台服务器宕机，所以数据存储的副本数目会减少，必须将副本的数目恢复到系统设定的值，否则，再有服务器宕机时，就可能出现无法访问转移，数据永久丢失的情况。因此系统需要从健康的服务器复制数据，将数据副本数目恢复到设定值。</p>
<h2 id="7-辅助手段"><a class="markdownIt-Anchor" href="#7-辅助手段"></a> 7. 辅助手段</h2>
<h3 id="71-异地多活"><a class="markdownIt-Anchor" href="#71-异地多活"></a> 7.1. 异地多活</h3>
<p>异地多活架构的关键点就是异地、多活，其中异地就是指地理位置上不同的地方，类似于“不要把鸡蛋都放在同一篮子里”；多活就是指不同地理位置上的系统都能够提供业务服务，这里的“活”是活动、活跃的意思。</p>
<p>异地多活架构可以分为同城异区、跨城异地、跨国异地。</p>
<p>异地多活架构的代价：</p>
<ul>
<li>系统复杂度会发生质的变化，需要设计复杂的异地多活架构。</li>
<li>成本会上升，毕竟要多在一个或者多个机房搭建独立的一套业务系统。</li>
</ul>
<p>异地多活的设计原则：</p>
<ul>
<li>保证核心业务的异地多活</li>
<li>保证核心数据最终一致性</li>
<li>采用多种手段同步数据</li>
<li>只保证绝大部分用户的异地多活</li>
</ul>
<p>异地多活设计步骤：</p>
<ul>
<li>业务分级 - 常见的分级标准有：
<ul>
<li>流量大的业务</li>
<li>核心业务</li>
<li>盈利业务</li>
</ul>
</li>
<li>数据分类 - 常见的数据分析维度有：
<ul>
<li>数据量</li>
<li>唯一性</li>
<li>实时性</li>
<li>可丢实性</li>
<li>可恢复性</li>
</ul>
</li>
<li>数据同步 - 常见的数据同步方案
<ul>
<li>存储系统同步</li>
<li>消息队列同步</li>
<li>重复生成</li>
</ul>
</li>
<li>异常处理 - 常见异常处理措施：
<ul>
<li>多通道同步</li>
<li>同步和访问结合</li>
<li>日志记录</li>
<li>用户补偿</li>
</ul>
</li>
</ul>
<h3 id="72-发布流程"><a class="markdownIt-Anchor" href="#72-发布流程"></a> 7.2. 发布流程</h3>
<p>高可用的软件质量保证的手段：</p>
<ul>
<li>自动化测试</li>
<li>预发布验证</li>
<li>代码控制</li>
<li>自动化发布</li>
<li>灰度发布</li>
</ul>
<h3 id="73-系统监控"><a class="markdownIt-Anchor" href="#73-系统监控"></a> 7.3. 系统监控</h3>
<blockquote>
<p>不允许没有监控的系统上线。</p>
</blockquote>
<ul>
<li><strong>监控数据采集</strong>
<ul>
<li><strong>用户行为日志收集</strong>
<ul>
<li>服务端日志收集 - Apache、Nginx 等几乎所有 Web 服务器都具备日志记录功能，只要开启日志记录即可。如果是服务器比较多，需要集中采集日志，通常会使用 Elastic 来进行收集。</li>
<li>客户端日志收集 - 利用页面嵌入专门的 JavaScript 脚本可以收集用户真实的操作行为。</li>
<li>日志分析 - 可以利用 ElasticSearch 做语义分析及搜索；利用实时计算框架 Storm、Flink 等开发日志统计与分析工具。</li>
</ul>
</li>
<li><strong>服务器性能监控</strong> - 收集服务器性能指标，如系统负载、内存占用、CPU 占用、磁盘 IO、网络 IO 等。常用的监控工具有：<a href="https://github.com/apache/skywalking" target="_blank" rel="noopener">Apache SkyWalking</a> 、<a href="https://github.com/naver/pinpoint" target="_blank" rel="noopener">Pinpoint</a> 等。</li>
<li><strong>运行数据报告</strong> - 应该监控一些与具体业务场景相关的技术和业务指标，如：缓存命中率、平均响应时延、TPS、QPS 等。</li>
</ul>
</li>
<li><strong>监控管理</strong>
<ul>
<li><strong>系统报警</strong> - 设置阈值。当达到阈值，及时触发告警（短信、邮件、通信工具均可），通过及时判断状况，防患于未然。</li>
<li><strong>失效转移</strong> - 监控系统可以在发现故障的情况下主动通知应用进行失效转移。</li>
<li><strong>自动优雅降级</strong>
<ul>
<li>优雅降级是为了应付突然爆发的访问高峰，主动关闭部分功能，释放部分资源，以保证核心功能的优先访问。</li>
<li>系统在监控管理基础之上实现自动优雅降级，是柔性架构的理想状态。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="8-参考资料"><a class="markdownIt-Anchor" href="#8-参考资料"></a> 8. 参考资料</h2>
<ul>
<li><a href="https://item.jd.com/11322972.html" target="_blank" rel="noopener">《大型网站技术架构：核心原理与案例分析》</a></li>
<li><a href="https://item.jd.com/12153914.html" target="_blank" rel="noopener">《亿级流量网站架构核心技术：跟开涛学搭建高可用高并发系统》</a></li>
<li><a href="https://time.geekbang.org/column/intro/48" target="_blank" rel="noopener">左耳听风</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/blog/2018/07/05/%E7%B3%BB%E7%BB%9F%E4%BC%B8%E7%BC%A9%E6%80%A7%E6%9E%B6%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Zhang Peng">
      <meta itemprop="description" content="Dunwu's Blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2018/07/05/%E7%B3%BB%E7%BB%9F%E4%BC%B8%E7%BC%A9%E6%80%A7%E6%9E%B6%E6%9E%84/" class="post-title-link" itemprop="url">系统伸缩性架构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-05 15:11:00" itemprop="dateCreated datePublished" datetime="2018-07-05T15:11:00+08:00">2018-07-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-14 16:45:53" itemprop="dateModified" datetime="2022-04-14T16:45:53+08:00">2022-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/blog/2018/07/05/%E7%B3%BB%E7%BB%9F%E4%BC%B8%E7%BC%A9%E6%80%A7%E6%9E%B6%E6%9E%84/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/07/05/系统伸缩性架构/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="系统伸缩性架构"><a class="markdownIt-Anchor" href="#系统伸缩性架构"></a> 系统伸缩性架构</h1>
<blockquote>
<p>伸缩性架构是指不需要改变系统的软硬件设计，仅通过改变部署服务器数量就可以扩大或缩小系统的服务处理能力。</p>
</blockquote>
<h2 id="1-系统架构的伸缩性设计"><a class="markdownIt-Anchor" href="#1-系统架构的伸缩性设计"></a> 1. 系统架构的伸缩性设计</h2>
<h3 id="11-不同功能进行物理分离实现伸缩"><a class="markdownIt-Anchor" href="#11-不同功能进行物理分离实现伸缩"></a> 1.1. 不同功能进行物理分离实现伸缩</h3>
<ul>
<li><strong>纵向分离（分层后分离）</strong> - 将业务处理流程上的不同部分分离部署，实现系统伸缩性。</li>
<li><strong>横向分离（业务分割后分离）</strong> - 将不同的业务模块分离部署，实现系统伸缩性。</li>
</ul>
<h3 id="12-单一功能通过集群规模实现伸缩"><a class="markdownIt-Anchor" href="#12-单一功能通过集群规模实现伸缩"></a> 1.2. 单一功能通过集群规模实现伸缩</h3>
<p>将不同功能分离部署可以实现一定程度的伸缩性，但是随着访问量逐步增加，即使分离到最小粒度的独立部署，单一的服务器也不能满足业务规模的要求。因此必须使用服务器集群，即将相同服务部署在多态服务器上构成一个集群整体对外提供服务。</p>
<h2 id="2-应用服务器集群的伸缩性设计"><a class="markdownIt-Anchor" href="#2-应用服务器集群的伸缩性设计"></a> 2. 应用服务器集群的伸缩性设计</h2>
<p>如果 HTTP 请求分发装置可以感知或者可以配置集群的服务器数量，可以及时发现集群中新上线或下线的服务器，并能向新上线的服务器分发请求，停止向已下线的服务器分发请求，那么就实现了应用服务器集群的伸缩性。</p>
<h3 id="21-http-重定向负载均衡"><a class="markdownIt-Anchor" href="#21-http-重定向负载均衡"></a> 2.1. HTTP 重定向负载均衡</h3>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/architecture/负载均衡-HTTP重定向.png" width="500"/>
</div>
<p>利用 HTTP 重定向协议实现负载均衡。</p>
<p>这种负载均衡方案的优点是比较简单。</p>
<p>缺点是浏览器需要两次请求服务器才能完成一次访问，性能较差：重定向服务器自身的处理能力有可能成为瓶颈，整个集群的伸缩性规模有限；使用 HTTP 302 响应码重定向，可能使搜索引擎判断为 SEO 作弊，降低搜索排名。</p>
<h3 id="22-dns-域名解析负载均衡"><a class="markdownIt-Anchor" href="#22-dns-域名解析负载均衡"></a> 2.2. DNS 域名解析负载均衡</h3>
<p>利用 DNS 处理域名解析请求的同时进行负载均衡处理的一种方案。</p>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/architecture/负载均衡-DNS域名解析.png" width="500"/>
</div>
<p>在 DNS 服务器中配置多个 A 记录，如：</p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line"><span class="number">114.100.40.1</span> www.mysite.com</span><br><span class="line"><span class="number">114.100.40.2</span> www.mysite.com</span><br><span class="line"><span class="number">114.100.40.3</span> www.mysite.com</span><br></pre></td></tr></table></figure>
<p>每次域名解析请求都会根据负载均衡算法计算一个不同的 IP 地址返回，这样 A 记录中配置的多个服务器就构成一个集群，并可以实现负载均衡。</p>
<p>DNS 域名解析负载均衡的优点：</p>
<ul>
<li>将负载均衡的工作转交给了 DNS，省掉了网站管理维护的麻烦。</li>
<li>同时，许多 DNS 服务器还支持基于地理位置的域名解析，即将域名解析成距离用户地理最近的一个服务器地址，这样可以加快用户访问速度，改善性能。</li>
</ul>
<p>DNS 域名解析负载均衡的缺点：</p>
<ul>
<li>DNS 是多级解析，每一级 DNS 都可能缓存 A 记录，当某台服务器下线后，即使修改了 DNS 的 A 记录，要使其生效也需要较长时间。这段时间，依然会域名解析到已经下线的服务器，导致用户访问失败。</li>
<li>DNS 的负载均衡的控制权在域名服务商那里，网站无法对其做更多改善和更强大的管理。</li>
</ul>
<h3 id="23-反向代理负载均衡"><a class="markdownIt-Anchor" href="#23-反向代理负载均衡"></a> 2.3. 反向代理负载均衡</h3>
<p>大多数反向代理服务器同时提供反向代理和负载均衡的功能。</p>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/architecture/负载均衡-反向代理.png" width="500"/>
</div>
<p>反向代理服务器的优点是部署简单。缺点是反向代理服务器是所有请求和响应的中转站，其性能可能会成为瓶颈。</p>
<h3 id="24-ip-负载均衡"><a class="markdownIt-Anchor" href="#24-ip-负载均衡"></a> 2.4. IP 负载均衡</h3>
<p>在网络层通过修改请求目标地址进行负载均衡。</p>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/architecture/负载均衡-IP层.png" width="500"/>
</div>
<p>负载均衡服务器（网关服务器）在操作系统内核获取网络数据包，根据负载均衡算法计算得到一台真实 Web 服务器 10.0.0.1，然后将目的 IP 地址修改为 10.0.0.1，不需要通过用户进程。真实 Web 服务器处理完成后，响应数据包回到负载均衡服务器，负载均衡服务器再将数据包原地址修改为自身的 IP 地址（114.100.80.10）发送给浏览器。</p>
<p>IP 负载均衡在内核完成数据分发，所以处理性能优于反向代理负载均衡。但是因为所有请求响应都要经过负载均衡服务器，集群的最大响应数据吞吐量受制于负载均衡服务器网卡带宽。</p>
<h3 id="25-数据链路层负载均衡"><a class="markdownIt-Anchor" href="#25-数据链路层负载均衡"></a> 2.5. 数据链路层负载均衡</h3>
<p>数据链路层负载均衡是指在通信协议的数据链路层修改 mac 地址进行负载均衡。</p>
<div align="center">
<img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/architecture/负载均衡-数据链路层.png" width="500"/>
</div>
<p>这种方式又称作三角传输方式，负载均衡数据分发过程中不修改 IP 地址，只修改目的 mac 地址，通过配置真实物理服务器集群所有机器虚拟 IP 和负载均衡服务器 IP 地址一致，从而达到不修改数据包的源地址和目的地址就可以进行数据分发的目的，由于实际处理请求的真实物理服务器 IP 和数据请求目的 IP 一致，不需要通过负载均衡服务器进行地址转换，可将响应数据包直接返回给用户浏览器，避免负载均衡服务器网卡带宽成为瓶颈。这种负载方式又称作直接路由方式。</p>
<p>在 Linux 平台上最好的链路层负载均衡开源产品是 <strong>LVS(Linux Virtual Server)</strong>。</p>
<h3 id="26-负载均衡算法"><a class="markdownIt-Anchor" href="#26-负载均衡算法"></a> 2.6. 负载均衡算法</h3>
<p>负载均衡服务器的实现可以分为两个部分：</p>
<ol>
<li>根据负载均衡算法和 Web 服务器列表计算得到集群中一台 Web 服务器的地址。</li>
<li>将请求数据发送到该地址对应的 Web 服务器上。</li>
</ol>
<p>负载均衡算法通常有以下几种：</p>
<ul>
<li><strong>轮询（Round Robin）</strong> - 所有请求被依次分发到每台应用服务器上，即每台服务器需要处理的请求数据都相同，适合于所有服务器硬件都相同的场景。</li>
<li><strong>加权轮询（Weighted Round Robin）</strong> - 根据服务器硬件性能情况，在轮询的基础上，按照配置权重将请求分发到每个服务器，高性能服务器能分配更多请求。</li>
<li><strong>随机（Random）</strong> - 请求被随机分配到各个应用服务器，在许多场合下，这种方案都很简单实用，因为好的随机数本身就很平均，即使应用服务器硬件配置不同，也可以使用加权随机算法。</li>
<li><strong>最少连接（Least Connection）</strong> - 记录每个应用服务器正在处理的连接数，将新到的请求分发到最少连接的服务器上，应该说，这是最符合负载均衡定义的算法。</li>
<li><strong>源地址 Hash（Source Hash）</strong> - 根据请求来源的 IP 地址进行 Hash 计算，得到应用服务器，这样来自同一个 IP 地址的请求总在同一个服务器上处理，该请求的上下文信息可以存储在这台服务器上，在一个会话周期内重复使用，从而实现会话粘滞。</li>
</ul>
<h2 id="3-分布式缓存集群的伸缩性设计"><a class="markdownIt-Anchor" href="#3-分布式缓存集群的伸缩性设计"></a> 3. 分布式缓存集群的伸缩性设计</h2>
<p>目前比较流行的分布式集群伸缩性方案就是：一致性 HASH 算法</p>
<h2 id="4-数据存储服务集群的伸缩性设计"><a class="markdownIt-Anchor" href="#4-数据存储服务集群的伸缩性设计"></a> 4. 数据存储服务集群的伸缩性设计</h2>
<h3 id="41-关系型数据库的伸缩性设计"><a class="markdownIt-Anchor" href="#41-关系型数据库的伸缩性设计"></a> 4.1. 关系型数据库的伸缩性设计</h3>
<ul>
<li><strong>主从复制</strong> - 主流关系型数据库一般都支持主从复制。</li>
<li><strong>分库</strong> - 根据业务对数据库进行分割。制约条件是跨库的表不能进行 Join 操作。</li>
<li><strong>分表</strong> - 使用数据库分片中间件，如 Cobar 等。</li>
</ul>
<h3 id="42-nosql-数据库的伸缩性设计"><a class="markdownIt-Anchor" href="#42-nosql-数据库的伸缩性设计"></a> 4.2. NoSql 数据库的伸缩性设计</h3>
<p>一般而言，Nosql 不支持 SQL 和 ACID，但是强化了对于高可用和伸缩性的支持。</p>
<h2 id="5-参考资料"><a class="markdownIt-Anchor" href="#5-参考资料"></a> 5. 参考资料</h2>
<ul>
<li><a href="https://item.jd.com/11322972.html" target="_blank" rel="noopener">《大型网站技术架构：核心原理与案例分析》</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blog/page/13/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/13/">13</a><span class="page-number current">14</span><a class="page-number" href="/blog/page/15/">15</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/18/">18</a><a class="extend next" rel="next" href="/blog/page/15/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="Zhang Peng"
    src="/blog/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Zhang Peng</p>
  <div class="site-description" itemprop="description">Dunwu's Blog</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">173</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">102</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/dunwu" title="GitHub &amp;rarr; https:&#x2F;&#x2F;github.com&#x2F;dunwu" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:forbreak@163.com" title="E-Mail &amp;rarr; mailto:forbreak@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/blog/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-paper-plane"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhang Peng</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">976k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">14:48</span>
</div>

        












        
      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1/canvas-nest.min.js"></script>
  <script src="/blog/lib/anime.min.js"></script>
  <script src="/blog/lib/velocity/velocity.min.js"></script>
  <script src="/blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/pisces.js"></script>


<script src="/blog/js/next-boot.js"></script>

<script src="/blog/js/bookmark.js"></script>




  




  
<script src="/blog/js/local-search.js"></script>














  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://blog-ajay4qmfci.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>

</body>
</html>
